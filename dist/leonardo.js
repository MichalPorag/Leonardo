/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (require, exports, module) params
 */

(function() {

  var ACE_NAMESPACE = "ace";

  var global = (function() { return this; })();
  if (!global && typeof window != "undefined") global = window; // strict mode


  if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
    return;


  var define = function(module, deps, payload) {
    if (typeof module !== "string") {
      if (define.original)
        define.original.apply(this, arguments);
      else {
        console.error("dropping module because define wasn\'t a string.");
        console.trace();
      }
      return;
    }
    if (arguments.length == 2)
      payload = deps;
    if (!define.modules[module]) {
      define.payloads[module] = payload;
      define.modules[module] = null;
    }
  };

  define.modules = {};
  define.payloads = {};

  /**
   * Get at functionality define()ed using the function above
   */
  var _require = function(parentId, module, callback) {
    if (typeof module === "string") {
      var payload = lookup(parentId, module);
      if (payload != undefined) {
        callback && callback();
        return payload;
      }
    } else if (Object.prototype.toString.call(module) === "[object Array]") {
      var params = [];
      for (var i = 0, l = module.length; i < l; ++i) {
        var dep = lookup(parentId, module[i]);
        if (dep == undefined && require.original)
          return;
        params.push(dep);
      }
      return callback && callback.apply(null, params) || true;
    }
  };

  var require = function(module, callback) {
    var packagedModule = _require("", module, callback);
    if (packagedModule == undefined && require.original)
      return require.original.apply(this, arguments);
    return packagedModule;
  };

  var normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf("!") !== -1) {
      var chunks = moduleName.split("!");
      return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == ".") {
      var base = parentId.split("/").slice(0, -1).join("/");
      moduleName = base + "/" + moduleName;

      while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
        var previous = moduleName;
        moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
      }
    }
    return moduleName;
  };

  /**
   * Internal function to lookup moduleNames and resolve them by calling the
   * definition function if needed.
   */
  var lookup = function(parentId, moduleName) {
    moduleName = normalizeModule(parentId, moduleName);

    var module = define.modules[moduleName];
    if (!module) {
      module = define.payloads[moduleName];
      if (typeof module === 'function') {
        var exports = {};
        var mod = {
          id: moduleName,
          uri: '',
          exports: exports,
          packaged: true
        };

        var req = function(module, callback) {
          return _require(moduleName, module, callback);
        };

        var returnValue = module(req, exports, mod);
        exports = returnValue || mod.exports;
        define.modules[moduleName] = exports;
        delete define.payloads[moduleName];
      }
      module = define.modules[moduleName] = exports || module;
    }
    return module;
  };

  function exportAce(ns) {
    var root = global;
    if (ns) {
      if (!global[ns])
        global[ns] = {};
      root = global[ns];
    }

    if (!root.define || !root.define.packaged) {
      define.original = root.define;
      root.define = define;
      root.define.packaged = true;
    }

    if (!root.require || !root.require.packaged) {
      require.original = root.require;
      root.require = require;
      root.require.packaged = true;
    }
  }

  exportAce(ACE_NAMESPACE);

})();

ace.define("ace/lib/regexp",["require","exports","module"], function(require, exports, module) {
  "use strict";

  var real = {
      exec: RegExp.prototype.exec,
      test: RegExp.prototype.test,
      match: String.prototype.match,
      replace: String.prototype.replace,
      split: String.prototype.split
    },
    compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
    compliantLastIndexIncrement = function () {
      var x = /^/g;
      real.test.call(x, "");
      return !x.lastIndex;
    }();

  if (compliantLastIndexIncrement && compliantExecNpcg)
    return;
  RegExp.prototype.exec = function (str) {
    var match = real.exec.apply(this, arguments),
      name, r2;
    if ( typeof(str) == 'string' && match) {
      if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
        r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
        real.replace.call(str.slice(match.index), r2, function () {
          for (var i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined)
              match[i] = undefined;
          }
        });
      }
      if (this._xregexp && this._xregexp.captureNames) {
        for (var i = 1; i < match.length; i++) {
          name = this._xregexp.captureNames[i - 1];
          if (name)
            match[name] = match[i];
        }
      }
      if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
        this.lastIndex--;
    }
    return match;
  };
  if (!compliantLastIndexIncrement) {
    RegExp.prototype.test = function (str) {
      var match = real.exec.call(this, str);
      if (match && this.global && !match[0].length && (this.lastIndex > match.index))
        this.lastIndex--;
      return !!match;
    };
  }

  function getNativeFlags (regex) {
    return (regex.global     ? "g" : "") +
      (regex.ignoreCase ? "i" : "") +
      (regex.multiline  ? "m" : "") +
      (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
      (regex.sticky     ? "y" : "");
  }

  function indexOf (array, item, from) {
    if (Array.prototype.indexOf) // Use the native array method if available
      return array.indexOf(item, from);
    for (var i = from || 0; i < array.length; i++) {
      if (array[i] === item)
        return i;
    }
    return -1;
  }

});

ace.define("ace/lib/es5-shim",["require","exports","module"], function(require, exports, module) {

  function Empty() {}

  if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
      var target = this;
      if (typeof target != "function") {
        throw new TypeError("Function.prototype.bind called on incompatible " + target);
      }
      var args = slice.call(arguments, 1); // for normal call
      var bound = function () {

        if (this instanceof bound) {

          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;

        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );

        }

      };
      if(target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
  var call = Function.prototype.call;
  var prototypeOfArray = Array.prototype;
  var prototypeOfObject = Object.prototype;
  var slice = prototypeOfArray.slice;
  var _toString = call.bind(prototypeOfObject.toString);
  var owns = call.bind(prototypeOfObject.hasOwnProperty);
  var defineGetter;
  var defineSetter;
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors;
  if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
  }
  if ([1,2].splice(0).length != 2) {
    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
          var a = new Array(l+2);
          a[0] = a[1] = 0;
          return a;
        }
        var array = [], lengthBefore;

        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));

        lengthBefore = array.length; //46
        array.splice(5, 0, "XXX"); // add one element

        lengthBefore + 1 == array.length

        if (lengthBefore + 1 == array.length) {
          return true;// has right splice implementation without bugs
        }
      }()) {//IE 6/7
      var array_splice = Array.prototype.splice;
      Array.prototype.splice = function(start, deleteCount) {
        if (!arguments.length) {
          return [];
        } else {
          return array_splice.apply(this, [
            start === void 0 ? 0 : start,
            deleteCount === void 0 ? (this.length - start) : deleteCount
          ].concat(slice.call(arguments, 2)))
        }
      };
    } else {//IE8
      Array.prototype.splice = function(pos, removeCount){
        var length = this.length;
        if (pos > 0) {
          if (pos > length)
            pos = length;
        } else if (pos == void 0) {
          pos = 0;
        } else if (pos < 0) {
          pos = Math.max(length + pos, 0);
        }

        if (!(pos+removeCount < length))
          removeCount = length - pos;

        var removed = this.slice(pos, pos+removeCount);
        var insert = slice.call(arguments, 2);
        var add = insert.length;
        if (pos === length) {
          if (add) {
            this.push.apply(this, insert);
          }
        } else {
          var remove = Math.min(removeCount, length - pos);
          var tailOldPos = pos + remove;
          var tailNewPos = tailOldPos + add - remove;
          var tailCount = length - tailOldPos;
          var lengthAfterRemove = length - remove;

          if (tailNewPos < tailOldPos) { // case A
            for (var i = 0; i < tailCount; ++i) {
              this[tailNewPos+i] = this[tailOldPos+i];
            }
          } else if (tailNewPos > tailOldPos) { // case B
            for (i = tailCount; i--; ) {
              this[tailNewPos+i] = this[tailOldPos+i];
            }
          } // else, add == remove (nothing to do)

          if (add && pos === lengthAfterRemove) {
            this.length = lengthAfterRemove; // truncate array
            this.push.apply(this, insert);
          } else {
            this.length = lengthAfterRemove + add; // reserves space
            for (i = 0; i < add; ++i) {
              this[pos+i] = insert[i];
            }
          }
        }
        return removed;
      };
    }
  }
  if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
      return _toString(obj) == "[object Array]";
    };
  }
  var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
      var object = toObject(this),
        self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          object,
        thisp = arguments[1],
        i = -1,
        length = self.length >>> 0;
      if (_toString(fun) != "[object Function]") {
        throw new TypeError(); // TODO message
      }

      while (++i < length) {
        if (i in self) {
          fun.call(thisp, self[i], i, object);
        }
      }
    };
  }
  if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
      var object = toObject(this),
        self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          object,
        length = self.length >>> 0,
        result = Array(length),
        thisp = arguments[1];
      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      for (var i = 0; i < length; i++) {
        if (i in self)
          result[i] = fun.call(thisp, self[i], i, object);
      }
      return result;
    };
  }
  if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
      var object = toObject(this),
        self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          object,
        length = self.length >>> 0,
        result = [],
        value,
        thisp = arguments[1];
      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      for (var i = 0; i < length; i++) {
        if (i in self) {
          value = self[i];
          if (fun.call(thisp, value, i, object)) {
            result.push(value);
          }
        }
      }
      return result;
    };
  }
  if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
      var object = toObject(this),
        self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          object,
        length = self.length >>> 0,
        thisp = arguments[1];
      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      for (var i = 0; i < length; i++) {
        if (i in self && !fun.call(thisp, self[i], i, object)) {
          return false;
        }
      }
      return true;
    };
  }
  if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
      var object = toObject(this),
        self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          object,
        length = self.length >>> 0,
        thisp = arguments[1];
      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      for (var i = 0; i < length; i++) {
        if (i in self && fun.call(thisp, self[i], i, object)) {
          return true;
        }
      }
      return false;
    };
  }
  if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
      var object = toObject(this),
        self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          object,
        length = self.length >>> 0;
      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }
      if (!length && arguments.length == 1) {
        throw new TypeError("reduce of empty array with no initial value");
      }

      var i = 0;
      var result;
      if (arguments.length >= 2) {
        result = arguments[1];
      } else {
        do {
          if (i in self) {
            result = self[i++];
            break;
          }
          if (++i >= length) {
            throw new TypeError("reduce of empty array with no initial value");
          }
        } while (true);
      }

      for (; i < length; i++) {
        if (i in self) {
          result = fun.call(void 0, result, self[i], i, object);
        }
      }

      return result;
    };
  }
  if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
      var object = toObject(this),
        self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          object,
        length = self.length >>> 0;
      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }
      if (!length && arguments.length == 1) {
        throw new TypeError("reduceRight of empty array with no initial value");
      }

      var result, i = length - 1;
      if (arguments.length >= 2) {
        result = arguments[1];
      } else {
        do {
          if (i in self) {
            result = self[i--];
            break;
          }
          if (--i < 0) {
            throw new TypeError("reduceRight of empty array with no initial value");
          }
        } while (true);
      }

      do {
        if (i in this) {
          result = fun.call(void 0, result, self[i], i, object);
        }
      } while (i--);

      return result;
    };
  }
  if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
      var self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          toObject(this),
        length = self.length >>> 0;

      if (!length) {
        return -1;
      }

      var i = 0;
      if (arguments.length > 1) {
        i = toInteger(arguments[1]);
      }
      i = i >= 0 ? i : Math.max(0, length + i);
      for (; i < length; i++) {
        if (i in self && self[i] === sought) {
          return i;
        }
      }
      return -1;
    };
  }
  if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
      var self = splitString && _toString(this) == "[object String]" ?
          this.split("") :
          toObject(this),
        length = self.length >>> 0;

      if (!length) {
        return -1;
      }
      var i = length - 1;
      if (arguments.length > 1) {
        i = Math.min(i, toInteger(arguments[1]));
      }
      i = i >= 0 ? i : length - Math.abs(i);
      for (; i >= 0; i--) {
        if (i in self && sought === self[i]) {
          return i;
        }
      }
      return -1;
    };
  }
  if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
      return object.__proto__ || (
          object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
  }
  if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
      "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
      if ((typeof object != "object" && typeof object != "function") || object === null)
        throw new TypeError(ERR_NON_OBJECT + object);
      if (!owns(object, property))
        return;

      var descriptor, getter, setter;
      descriptor =  { enumerable: true, configurable: true };
      if (supportsAccessors) {
        var prototype = object.__proto__;
        object.__proto__ = prototypeOfObject;

        var getter = lookupGetter(object, property);
        var setter = lookupSetter(object, property);
        object.__proto__ = prototype;

        if (getter || setter) {
          if (getter) descriptor.get = getter;
          if (setter) descriptor.set = setter;
          return descriptor;
        }
      }
      descriptor.value = object[property];
      return descriptor;
    };
  }
  if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
      return Object.keys(object);
    };
  }
  if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
      createEmpty = function () {
        return { "__proto__": null };
      };
    } else {
      createEmpty = function () {
        var empty = {};
        for (var i in empty)
          empty[i] = null;
        empty.constructor =
          empty.hasOwnProperty =
            empty.propertyIsEnumerable =
              empty.isPrototypeOf =
                empty.toLocaleString =
                  empty.toString =
                    empty.valueOf =
                      empty.__proto__ = null;
        return empty;
      }
    }

    Object.create = function create(prototype, properties) {
      var object;
      if (prototype === null) {
        object = createEmpty();
      } else {
        if (typeof prototype != "object")
          throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
      }
      if (properties !== void 0)
        Object.defineProperties(object, properties);
      return object;
    };
  }

  function doesDefinePropertyWork(object) {
    try {
      Object.defineProperty(object, "sentinel", {});
      return "sentinel" in object;
    } catch (exception) {
    }
  }
  if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
      doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
      var definePropertyFallback = Object.defineProperty;
    }
  }

  if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
      if ((typeof object != "object" && typeof object != "function") || object === null)
        throw new TypeError(ERR_NON_OBJECT_TARGET + object);
      if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
        throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
      if (definePropertyFallback) {
        try {
          return definePropertyFallback.call(Object, object, property, descriptor);
        } catch (exception) {
        }
      }
      if (owns(descriptor, "value")) {

        if (supportsAccessors && (lookupGetter(object, property) ||
          lookupSetter(object, property)))
        {
          var prototype = object.__proto__;
          object.__proto__ = prototypeOfObject;
          delete object[property];
          object[property] = descriptor.value;
          object.__proto__ = prototype;
        } else {
          object[property] = descriptor.value;
        }
      } else {
        if (!supportsAccessors)
          throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
        if (owns(descriptor, "get"))
          defineGetter(object, property, descriptor.get);
        if (owns(descriptor, "set"))
          defineSetter(object, property, descriptor.set);
      }

      return object;
    };
  }
  if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
      for (var property in properties) {
        if (owns(properties, property))
          Object.defineProperty(object, property, properties[property]);
      }
      return object;
    };
  }
  if (!Object.seal) {
    Object.seal = function seal(object) {
      return object;
    };
  }
  if (!Object.freeze) {
    Object.freeze = function freeze(object) {
      return object;
    };
  }
  try {
    Object.freeze(function () {});
  } catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
      return function freeze(object) {
        if (typeof object == "function") {
          return object;
        } else {
          return freezeObject(object);
        }
      };
    })(Object.freeze);
  }
  if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
      return object;
    };
  }
  if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
      return false;
    };
  }
  if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
      return false;
    };
  }
  if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
      if (Object(object) === object) {
        throw new TypeError(); // TODO message
      }
      var name = '';
      while (owns(object, name)) {
        name += '?';
      }
      object[name] = true;
      var returnValue = owns(object, name);
      delete object[name];
      return returnValue;
    };
  }
  if (!Object.keys) {
    var hasDontEnumBug = true,
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ],
      dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
      hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

      if (
        (typeof object != "object" && typeof object != "function") ||
        object === null
      ) {
        throw new TypeError("Object.keys called on a non-object");
      }

      var keys = [];
      for (var name in object) {
        if (owns(object, name)) {
          keys.push(name);
        }
      }

      if (hasDontEnumBug) {
        for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
          var dontEnum = dontEnums[i];
          if (owns(object, dontEnum)) {
            keys.push(dontEnum);
          }
        }
      }
      return keys;
    };

  }
  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime();
    };
  }
  var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
  if (!String.prototype.trim || ws.trim()) {
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
      trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
      return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
  }

  function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
      n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
      n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
  }

  function isPrimitive(input) {
    var type = typeof input;
    return (
      input === null ||
      type === "undefined" ||
      type === "boolean" ||
      type === "number" ||
      type === "string"
    );
  }

  function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
      return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
      val = valueOf.call(input);
      if (isPrimitive(val)) {
        return val;
      }
    }
    toString = input.toString;
    if (typeof toString === "function") {
      val = toString.call(input);
      if (isPrimitive(val)) {
        return val;
      }
    }
    throw new TypeError();
  }
  var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
      throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
  };

});

ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(require, exports, module) {
  "use strict";

  require("./regexp");
  require("./es5-shim");

});

ace.define("ace/lib/dom",["require","exports","module"], function(require, exports, module) {
  "use strict";

  var XHTML_NS = "http://www.w3.org/1999/xhtml";

  exports.getDocumentHead = function(doc) {
    if (!doc)
      doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
  }

  exports.createElement = function(tag, ns) {
    return document.createElementNS ?
      document.createElementNS(ns || XHTML_NS, tag) :
      document.createElement(tag);
  };

  exports.hasCssClass = function(el, name) {
    var classes = (el.className + "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
  };
  exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
      el.className += " " + name;
    }
  };
  exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
      var index = classes.indexOf(name);
      if (index == -1) {
        break;
      }
      classes.splice(index, 1);
    }
    el.className = classes.join(" ");
  };

  exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
      var index = classes.indexOf(name);
      if (index == -1) {
        break;
      }
      add = false;
      classes.splice(index, 1);
    }
    if (add)
      classes.push(name);

    el.className = classes.join(" ");
    return add;
  };
  exports.setCssClass = function(node, className, include) {
    if (include) {
      exports.addCssClass(node, className);
    } else {
      exports.removeCssClass(node, className);
    }
  };

  exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;

    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
      while (index < sheets.length)
        if (sheets[index++].owningElement.id === id) return true;
    } else if ((sheets = doc.getElementsByTagName("style"))) {
      while (index < sheets.length)
        if (sheets[index++].id === id) return true;
    }

    return false;
  };

  exports.importCssString = function importCssString(cssText, id, doc) {
    doc = doc || document;
    if (id && exports.hasCssString(id, doc))
      return null;

    var style;

    if (id)
      cssText += "\n/*# sourceURL=ace/css/" + id + " */";

    if (doc.createStyleSheet) {
      style = doc.createStyleSheet();
      style.cssText = cssText;
      if (id)
        style.owningElement.id = id;
    } else {
      style = exports.createElement("style");
      style.appendChild(doc.createTextNode(cssText));
      if (id)
        style.id = id;

      exports.getDocumentHead(doc).appendChild(style);
    }
  };

  exports.importCssStylsheet = function(uri, doc) {
    if (doc.createStyleSheet) {
      doc.createStyleSheet(uri);
    } else {
      var link = exports.createElement('link');
      link.rel = 'stylesheet';
      link.href = uri;

      exports.getDocumentHead(doc).appendChild(link);
    }
  };

  exports.getInnerWidth = function(element) {
    return (
      parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
      parseInt(exports.computedStyle(element, "paddingRight"), 10) +
      element.clientWidth
    );
  };

  exports.getInnerHeight = function(element) {
    return (
      parseInt(exports.computedStyle(element, "paddingTop"), 10) +
      parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
      element.clientHeight
    );
  };

  exports.scrollbarWidth = function(document) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = document.documentElement;
    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar == withScrollbar) {
      withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar-withScrollbar;
  };

  if (typeof document == "undefined") {
    exports.importCssString = function() {};
    return;
  }

  if (window.pageYOffset !== undefined) {
    exports.getPageScrollTop = function() {
      return window.pageYOffset;
    };

    exports.getPageScrollLeft = function() {
      return window.pageXOffset;
    };
  }
  else {
    exports.getPageScrollTop = function() {
      return document.body.scrollTop;
    };

    exports.getPageScrollLeft = function() {
      return document.body.scrollLeft;
    };
  }

  if (window.getComputedStyle)
    exports.computedStyle = function(element, style) {
      if (style)
        return (window.getComputedStyle(element, "") || {})[style] || "";
      return window.getComputedStyle(element, "") || {};
    };
  else
    exports.computedStyle = function(element, style) {
      if (style)
        return element.currentStyle[style];
      return element.currentStyle;
    };
  exports.setInnerHtml = function(el, innerHtml) {
    var element = el.cloneNode(false);//document.createElement("div");
    element.innerHTML = innerHtml;
    el.parentNode.replaceChild(element, el);
    return element;
  };

  if ("textContent" in document.documentElement) {
    exports.setInnerText = function(el, innerText) {
      el.textContent = innerText;
    };

    exports.getInnerText = function(el) {
      return el.textContent;
    };
  }
  else {
    exports.setInnerText = function(el, innerText) {
      el.innerText = innerText;
    };

    exports.getInnerText = function(el) {
      return el.innerText;
    };
  }

  exports.getParentWindow = function(document) {
    return document.defaultView || document.parentWindow;
  };

});

ace.define("ace/lib/oop",["require","exports","module"], function(require, exports, module) {
  "use strict";

  exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };

  exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
      obj[key] = mixin[key];
    }
    return obj;
  };

  exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
  };

});

ace.define("ace/lib/keys",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop"], function(require, exports, module) {
  "use strict";

  require("./fixoldbrowsers");

  var oop = require("./oop");
  var Keys = (function() {
    var ret = {
      MODIFIER_KEYS: {
        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
      },

      KEY_MODS: {
        "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
        "super": 8, "meta": 8, "command": 8, "cmd": 8
      },

      FUNCTION_KEYS : {
        8  : "Backspace",
        9  : "Tab",
        13 : "Return",
        19 : "Pause",
        27 : "Esc",
        32 : "Space",
        33 : "PageUp",
        34 : "PageDown",
        35 : "End",
        36 : "Home",
        37 : "Left",
        38 : "Up",
        39 : "Right",
        40 : "Down",
        44 : "Print",
        45 : "Insert",
        46 : "Delete",
        96 : "Numpad0",
        97 : "Numpad1",
        98 : "Numpad2",
        99 : "Numpad3",
        100: "Numpad4",
        101: "Numpad5",
        102: "Numpad6",
        103: "Numpad7",
        104: "Numpad8",
        105: "Numpad9",
        '-13': "NumpadEnter",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "Numlock",
        145: "Scrolllock"
      },

      PRINTABLE_KEYS: {
        32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
        54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
        66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
        73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
        80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
        87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
        219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
      }
    };
    var name, i;
    for (i in ret.FUNCTION_KEYS) {
      name = ret.FUNCTION_KEYS[i].toLowerCase();
      ret[name] = parseInt(i, 10);
    }
    for (i in ret.PRINTABLE_KEYS) {
      name = ret.PRINTABLE_KEYS[i].toLowerCase();
      ret[name] = parseInt(i, 10);
    }
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);
    ret.enter = ret["return"];
    ret.escape = ret.esc;
    ret.del = ret["delete"];
    ret[173] = '-';

    (function() {
      var mods = ["cmd", "ctrl", "alt", "shift"];
      for (var i = Math.pow(2, mods.length); i--;) {
        ret.KEY_MODS[i] = mods.filter(function(x) {
            return i & ret.KEY_MODS[x];
          }).join("-") + "-";
      }
    })();

    ret.KEY_MODS[0] = "";
    ret.KEY_MODS[-1] = "input-";

    return ret;
  })();
  oop.mixin(exports, Keys);

  exports.keyCodeToString = function(keyCode) {
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
      keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
  };

});

ace.define("ace/lib/useragent",["require","exports","module"], function(require, exports, module) {
  "use strict";
  exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
  };
  exports.getOS = function() {
    if (exports.isMac) {
      return exports.OS.MAC;
    } else if (exports.isLinux) {
      return exports.OS.LINUX;
    } else {
      return exports.OS.WINDOWS;
    }
  };
  if (typeof navigator != "object")
    return;

  var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
  var ua = navigator.userAgent;
  exports.isWin = (os == "win");
  exports.isMac = (os == "mac");
  exports.isLinux = (os == "linux");
  exports.isIE =
    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
      ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
      : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie

  exports.isOldIE = exports.isIE && exports.isIE < 9;
  exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
  exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv:(\d+)/)||[])[1], 10) < 4;
  exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
  exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

  exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

  exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

  exports.isIPad = ua.indexOf("iPad") >= 0;

  exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

  exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

});

ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {
  "use strict";

  var keys = require("./keys");
  var useragent = require("./useragent");

  var pressedKeys = null;
  var ts = 0;

  exports.addListener = function(elem, type, callback) {
    if (elem.addEventListener) {
      return elem.addEventListener(type, callback, false);
    }
    if (elem.attachEvent) {
      var wrapper = function() {
        callback.call(elem, window.event);
      };
      callback._wrapper = wrapper;
      elem.attachEvent("on" + type, wrapper);
    }
  };

  exports.removeListener = function(elem, type, callback) {
    if (elem.removeEventListener) {
      return elem.removeEventListener(type, callback, false);
    }
    if (elem.detachEvent) {
      elem.detachEvent("on" + type, callback._wrapper || callback);
    }
  };
  exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
  };

  exports.stopPropagation = function(e) {
    if (e.stopPropagation)
      e.stopPropagation();
    else
      e.cancelBubble = true;
  };

  exports.preventDefault = function(e) {
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
  };
  exports.getButton = function(e) {
    if (e.type == "dblclick")
      return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
      return 2;
    if (e.preventDefault) {
      return e.button;
    }
    else {
      return {1:0, 2:2, 4:1}[e.button];
    }
  };

  exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    function onMouseUp(e) {
      eventHandler && eventHandler(e);
      releaseCaptureHandler && releaseCaptureHandler(e);

      exports.removeListener(document, "mousemove", eventHandler, true);
      exports.removeListener(document, "mouseup", onMouseUp, true);
      exports.removeListener(document, "dragstart", onMouseUp, true);
    }

    exports.addListener(document, "mousemove", eventHandler, true);
    exports.addListener(document, "mouseup", onMouseUp, true);
    exports.addListener(document, "dragstart", onMouseUp, true);

    return onMouseUp;
  };

  exports.addTouchMoveListener = function (el, callback) {
    if ("ontouchmove" in el) {
      var startx, starty;
      exports.addListener(el, "touchstart", function (e) {
        var touchObj = e.changedTouches[0];
        startx = touchObj.clientX;
        starty = touchObj.clientY;
      });
      exports.addListener(el, "touchmove", function (e) {
        var factor = 1,
          touchObj = e.changedTouches[0];

        e.wheelX = -(touchObj.clientX - startx) / factor;
        e.wheelY = -(touchObj.clientY - starty) / factor;

        startx = touchObj.clientX;
        starty = touchObj.clientY;

        callback(e);
      });
    }
  };

  exports.addMouseWheelListener = function(el, callback) {
    if ("onmousewheel" in el) {
      exports.addListener(el, "mousewheel", function(e) {
        var factor = 8;
        if (e.wheelDeltaX !== undefined) {
          e.wheelX = -e.wheelDeltaX / factor;
          e.wheelY = -e.wheelDeltaY / factor;
        } else {
          e.wheelX = 0;
          e.wheelY = -e.wheelDelta / factor;
        }
        callback(e);
      });
    } else if ("onwheel" in el) {
      exports.addListener(el, "wheel",  function(e) {
        var factor = 0.35;
        switch (e.deltaMode) {
          case e.DOM_DELTA_PIXEL:
            e.wheelX = e.deltaX * factor || 0;
            e.wheelY = e.deltaY * factor || 0;
            break;
          case e.DOM_DELTA_LINE:
          case e.DOM_DELTA_PAGE:
            e.wheelX = (e.deltaX || 0) * 5;
            e.wheelY = (e.deltaY || 0) * 5;
            break;
        }

        callback(e);
      });
    } else {
      exports.addListener(el, "DOMMouseScroll", function(e) {
        if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
          e.wheelX = (e.detail || 0) * 5;
          e.wheelY = 0;
        } else {
          e.wheelX = 0;
          e.wheelY = (e.detail || 0) * 5;
        }
        callback(e);
      });
    }
  };

  exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
    var clicks = 0;
    var startX, startY, timer;
    var eventNames = {
      2: "dblclick",
      3: "tripleclick",
      4: "quadclick"
    };

    function onMousedown(e) {
      if (exports.getButton(e) !== 0) {
        clicks = 0;
      } else if (e.detail > 1) {
        clicks++;
        if (clicks > 4)
          clicks = 1;
      } else {
        clicks = 1;
      }
      if (useragent.isIE) {
        var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
        if (!timer || isNewClick)
          clicks = 1;
        if (timer)
          clearTimeout(timer);
        timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);

        if (clicks == 1) {
          startX = e.clientX;
          startY = e.clientY;
        }
      }

      e._clicks = clicks;

      eventHandler[callbackName]("mousedown", e);

      if (clicks > 4)
        clicks = 0;
      else if (clicks > 1)
        return eventHandler[callbackName](eventNames[clicks], e);
    }
    function onDblclick(e) {
      clicks = 2;
      if (timer)
        clearTimeout(timer);
      timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
      eventHandler[callbackName]("mousedown", e);
      eventHandler[callbackName](eventNames[clicks], e);
    }
    if (!Array.isArray(elements))
      elements = [elements];
    elements.forEach(function(el) {
      exports.addListener(el, "mousedown", onMousedown);
      if (useragent.isOldIE)
        exports.addListener(el, "dblclick", onDblclick);
    });
  };

  var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
    ? function(e) {
      return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    }
    : function(e) {
      return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };

  exports.getModifierString = function(e) {
    return keys.KEY_MODS[getModifierHash(e)];
  };

  function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);

    if (!useragent.isMac && pressedKeys) {
      if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
        hashId |= 8;
      if (pressedKeys.altGr) {
        if ((3 & hashId) != 3)
          pressedKeys.altGr = 0;
        else
          return;
      }
      if (keyCode === 18 || keyCode === 17) {
        var location = "location" in e ? e.location : e.keyLocation;
        if (keyCode === 17 && location === 1) {
          if (pressedKeys[keyCode] == 1)
            ts = e.timeStamp;
        } else if (keyCode === 18 && hashId === 3 && location === 2) {
          var dt = e.timeStamp - ts;
          if (dt < 50)
            pressedKeys.altGr = true;
        }
      }
    }

    if (keyCode in keys.MODIFIER_KEYS) {
      keyCode = -1;
    }
    if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
      keyCode = -1;
    }

    if (!hashId && keyCode === 13) {
      var location = "location" in e ? e.location : e.keyLocation;
      if (location === 3) {
        callback(e, hashId, -keyCode);
        if (e.defaultPrevented)
          return;
      }
    }

    if (useragent.isChromeOS && hashId & 8) {
      callback(e, hashId, keyCode);
      if (e.defaultPrevented)
        return;
      else
        hashId &= ~8;
    }
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
      return false;
    }

    return callback(e, hashId, keyCode);
  }


  exports.addCommandKeyListener = function(el, callback) {
    var addListener = exports.addListener;
    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
      var lastKeyDownKeyCode = null;
      addListener(el, "keydown", function(e) {
        lastKeyDownKeyCode = e.keyCode;
      });
      addListener(el, "keypress", function(e) {
        return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
      });
    } else {
      var lastDefaultPrevented = null;

      addListener(el, "keydown", function(e) {
        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
        var result = normalizeCommandKeys(callback, e, e.keyCode);
        lastDefaultPrevented = e.defaultPrevented;
        return result;
      });

      addListener(el, "keypress", function(e) {
        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
          exports.stopEvent(e);
          lastDefaultPrevented = null;
        }
      });

      addListener(el, "keyup", function(e) {
        pressedKeys[e.keyCode] = null;
      });

      if (!pressedKeys) {
        resetPressedKeys();
        addListener(window, "focus", resetPressedKeys);
      }
    }
  };
  function resetPressedKeys() {
    pressedKeys = Object.create(null);
  }

  if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
      win = win || window;
      var messageName = "zero-timeout-message-" + postMessageId;
      exports.addListener(win, "message", function listener(e) {
        if (e.data == messageName) {
          exports.stopPropagation(e);
          exports.removeListener(win, "message", listener);
          callback();
        }
      });
      win.postMessage(messageName, "*");
    };
  }


  exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.msRequestAnimationFrame
    || window.oRequestAnimationFrame);

  if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
  else
    exports.nextFrame = function(callback) {
      setTimeout(callback, 17);
    };
});

ace.define("ace/lib/lang",["require","exports","module"], function(require, exports, module) {
  "use strict";

  exports.last = function(a) {
    return a[a.length - 1];
  };

  exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
  };

  exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
      if (count & 1)
        result += string;

      if (count >>= 1)
        string += string;
    }
    return result;
  };

  var trimBeginRegexp = /^\s\s*/;
  var trimEndRegexp = /\s\s*$/;

  exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
  };

  exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
  };

  exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
      copy[key] = obj[key];
    }
    return copy;
  };

  exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
      if (array[i] && typeof array[i] == "object")
        copy[i] = this.copyObject(array[i]);
      else
        copy[i] = array[i];
    }
    return copy;
  };

  exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
      return obj;
    var copy;
    if (Array.isArray(obj)) {
      copy = [];
      for (var key = 0; key < obj.length; key++) {
        copy[key] = deepCopy(obj[key]);
      }
      return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
      return obj;

    copy = {};
    for (var key in obj)
      copy[key] = deepCopy(obj[key]);
    return copy;
  };

  exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
      map[arr[i]] = 1;
    }
    return map;

  };

  exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
      map[i] = props[i];
    }
    return map;
  };
  exports.arrayRemove = function(array, value) {
    for (var i = 0; i <= array.length; i++) {
      if (value === array[i]) {
        array.splice(i, 1);
      }
    }
  };

  exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
  };

  exports.escapeHTML = function(str) {
    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
  };

  exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
      matches.push({
        offset: arguments[arguments.length-2],
        length: str.length
      });
    });

    return matches;
  };
  exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
      timer = null;
      fcn();
    };

    var deferred = function(timeout) {
      deferred.cancel();
      timer = setTimeout(callback, timeout || 0);
      return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
      this.cancel();
      fcn();
      return deferred;
    };

    deferred.cancel = function() {
      clearTimeout(timer);
      timer = null;
      return deferred;
    };

    deferred.isPending = function() {
      return timer;
    };

    return deferred;
  };


  exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
      timer = null;
      fcn();
    };

    var _self = function(timeout) {
      if (timer == null)
        timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
      timer && clearTimeout(timer);
      timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
      this.cancel();
      fcn();
    };

    _self.cancel = function() {
      timer && clearTimeout(timer);
      timer = null;
    };

    _self.isPending = function() {
      return timer;
    };

    return _self;
  };
});

ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang"], function(require, exports, module) {
  "use strict";

  var event = require("../lib/event");
  var useragent = require("../lib/useragent");
  var dom = require("../lib/dom");
  var lang = require("../lib/lang");
  var BROKEN_SETDATA = useragent.isChrome < 18;
  var USE_IE_MIME_TYPE =  useragent.isIE;

  var TextInput = function(parentNode, host) {
    var text = dom.createElement("textarea");
    text.className = "ace_text-input";

    if (useragent.isTouchPad)
      text.setAttribute("x-palm-disable-auto-cap", true);

    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", false);

    text.style.opacity = "0";
    if (useragent.isOldIE) text.style.top = "-1000px";
    parentNode.insertBefore(text, parentNode.firstChild);

    var PLACEHOLDER = "\x01\x01";

    var copied = false;
    var pasted = false;
    var inComposition = false;
    var tempStyle = '';
    var isSelectionEmpty = true;
    try { var isFocused = document.activeElement === text; } catch(e) {}

    event.addListener(text, "blur", function(e) {
      host.onBlur(e);
      isFocused = false;
    });
    event.addListener(text, "focus", function(e) {
      isFocused = true;
      host.onFocus(e);
      resetSelection();
    });
    this.focus = function() {
      if (tempStyle) return text.focus();
      var top = text.style.top;
      text.style.position = "fixed";
      text.style.top = "0px";
      text.focus();
      setTimeout(function() {
        text.style.position = "";
        if (text.style.top == "0px")
          text.style.top = top;
      }, 0);
    };
    this.blur = function() {
      text.blur();
    };
    this.isFocused = function() {
      return isFocused;
    };
    var syncSelection = lang.delayedCall(function() {
      isFocused && resetSelection(isSelectionEmpty);
    });
    var syncValue = lang.delayedCall(function() {
      if (!inComposition) {
        text.value = PLACEHOLDER;
        isFocused && resetSelection();
      }
    });

    function resetSelection(isEmpty) {
      if (inComposition)
        return;
      inComposition = true;

      if (inputHandler) {
        selectionStart = 0;
        selectionEnd = isEmpty ? 0 : text.value.length - 1;
      } else {
        var selectionStart = isEmpty ? 2 : 1;
        var selectionEnd = 2;
      }
      try {
        text.setSelectionRange(selectionStart, selectionEnd);
      } catch(e){}

      inComposition = false;
    }

    function resetValue() {
      if (inComposition)
        return;
      text.value = PLACEHOLDER;
      if (useragent.isWebKit)
        syncValue.schedule();
    }

    useragent.isWebKit || host.addEventListener('changeSelection', function() {
      if (host.selection.isEmpty() != isSelectionEmpty) {
        isSelectionEmpty = !isSelectionEmpty;
        syncSelection.schedule();
      }
    });

    resetValue();
    if (isFocused)
      host.onFocus();


    var isAllSelected = function(text) {
      return text.selectionStart === 0 && text.selectionEnd === text.value.length;
    };
    if (!text.setSelectionRange && text.createTextRange) {
      text.setSelectionRange = function(selectionStart, selectionEnd) {
        var range = this.createTextRange();
        range.collapse(true);
        range.moveStart('character', selectionStart);
        range.moveEnd('character', selectionEnd);
        range.select();
      };
      isAllSelected = function(text) {
        try {
          var range = text.ownerDocument.selection.createRange();
        }catch(e) {}
        if (!range || range.parentElement() != text) return false;
        return range.text == text.value;
      }
    }
    if (useragent.isOldIE) {
      var inPropertyChange = false;
      var onPropertyChange = function(e){
        if (inPropertyChange)
          return;
        var data = text.value;
        if (inComposition || !data || data == PLACEHOLDER)
          return;
        if (e && data == PLACEHOLDER[0])
          return syncProperty.schedule();

        sendText(data);
        inPropertyChange = true;
        resetValue();
        inPropertyChange = false;
      };
      var syncProperty = lang.delayedCall(onPropertyChange);
      event.addListener(text, "propertychange", onPropertyChange);

      var keytable = { 13:1, 27:1 };
      event.addListener(text, "keyup", function (e) {
        if (inComposition && (!text.value || keytable[e.keyCode]))
          setTimeout(onCompositionEnd, 0);
        if ((text.value.charCodeAt(0)||0) < 129) {
          return syncProperty.call();
        }
        inComposition ? onCompositionUpdate() : onCompositionStart();
      });
      event.addListener(text, "keydown", function (e) {
        syncProperty.schedule(50);
      });
    }

    var onSelect = function(e) {
      if (copied) {
        copied = false;
      } else if (isAllSelected(text)) {
        host.selectAll();
        resetSelection();
      } else if (inputHandler) {
        resetSelection(host.selection.isEmpty());
      }
    };

    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb};
    this.getInputHandler = function() {return inputHandler};
    var afterContextMenu = false;

    var sendText = function(data) {
      if (inputHandler) {
        data = inputHandler(data);
        inputHandler = null;
      }
      if (pasted) {
        resetSelection();
        if (data)
          host.onPaste(data);
        pasted = false;
      } else if (data == PLACEHOLDER.charAt(0)) {
        if (afterContextMenu)
          host.execCommand("del", {source: "ace"});
        else // some versions of android do not fire keydown when pressing backspace
          host.execCommand("backspace", {source: "ace"});
      } else {
        if (data.substring(0, 2) == PLACEHOLDER)
          data = data.substr(2);
        else if (data.charAt(0) == PLACEHOLDER.charAt(0))
          data = data.substr(1);
        else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
          data = data.slice(0, -1);
        if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
          data = data.slice(0, -1);

        if (data)
          host.onTextInput(data);
      }
      if (afterContextMenu)
        afterContextMenu = false;
    };
    var onInput = function(e) {
      if (inComposition)
        return;
      var data = text.value;
      sendText(data);
      resetValue();
    };

    var handleClipboardData = function(e, data, forceIEMime) {
      var clipboardData = e.clipboardData || window.clipboardData;
      if (!clipboardData || BROKEN_SETDATA)
        return;
      var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
      try {
        if (data) {
          return clipboardData.setData(mime, data) !== false;
        } else {
          return clipboardData.getData(mime);
        }
      } catch(e) {
        if (!forceIEMime)
          return handleClipboardData(e, data, true);
      }
    };

    var doCopy = function(e, isCut) {
      var data = host.getCopyText();
      if (!data)
        return event.preventDefault(e);

      if (handleClipboardData(e, data)) {
        isCut ? host.onCut() : host.onCopy();
        event.preventDefault(e);
      } else {
        copied = true;
        text.value = data;
        text.select();
        setTimeout(function(){
          copied = false;
          resetValue();
          resetSelection();
          isCut ? host.onCut() : host.onCopy();
        });
      }
    };

    var onCut = function(e) {
      doCopy(e, true);
    };

    var onCopy = function(e) {
      doCopy(e, false);
    };

    var onPaste = function(e) {
      var data = handleClipboardData(e);
      if (typeof data == "string") {
        if (data)
          host.onPaste(data, e);
        if (useragent.isIE)
          setTimeout(resetSelection);
        event.preventDefault(e);
      }
      else {
        text.value = "";
        pasted = true;
      }
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

    event.addListener(text, "select", onSelect);

    event.addListener(text, "input", onInput);

    event.addListener(text, "cut", onCut);
    event.addListener(text, "copy", onCopy);
    event.addListener(text, "paste", onPaste);
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){
      event.addListener(parentNode, "keydown", function(e) {
        if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
          return;

        switch (e.keyCode) {
          case 67:
            onCopy(e);
            break;
          case 86:
            onPaste(e);
            break;
          case 88:
            onCut(e);
            break;
        }
      });
    }
    var onCompositionStart = function(e) {
      if (inComposition || !host.onCompositionStart || host.$readOnly)
        return;
      inComposition = {};
      inComposition.canUndo = host.session.$undoManager;
      host.onCompositionStart();
      setTimeout(onCompositionUpdate, 0);
      host.on("mousedown", onCompositionEnd);
      if (inComposition.canUndo && !host.selection.isEmpty()) {
        host.insert("");
        host.session.markUndoGroup();
        host.selection.clearSelection();
      }
      host.session.markUndoGroup();
    };

    var onCompositionUpdate = function() {
      if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
        return;
      var val = text.value.replace(/\x01/g, "");
      if (inComposition.lastValue === val) return;

      host.onCompositionUpdate(val);
      if (inComposition.lastValue)
        host.undo();
      if (inComposition.canUndo)
        inComposition.lastValue = val;
      if (inComposition.lastValue) {
        var r = host.selection.getRange();
        host.insert(inComposition.lastValue);
        host.session.markUndoGroup();
        inComposition.range = host.selection.getRange();
        host.selection.setRange(r);
        host.selection.clearSelection();
      }
    };

    var onCompositionEnd = function(e) {
      if (!host.onCompositionEnd || host.$readOnly) return;
      var c = inComposition;
      inComposition = false;
      var timer = setTimeout(function() {
        timer = null;
        var str = text.value.replace(/\x01/g, "");
        if (inComposition)
          return;
        else if (str == c.lastValue)
          resetValue();
        else if (!c.lastValue && str) {
          resetValue();
          sendText(str);
        }
      });
      inputHandler = function compositionInputHandler(str) {
        if (timer)
          clearTimeout(timer);
        str = str.replace(/\x01/g, "");
        if (str == c.lastValue)
          return "";
        if (c.lastValue && timer)
          host.undo();
        return str;
      };
      host.onCompositionEnd();
      host.removeListener("mousedown", onCompositionEnd);
      if (e.type == "compositionend" && c.range) {
        host.selection.setRange(c.range);
      }
      if (useragent.isChrome && useragent.isChrome >= 53) {
        onInput();
      }
    };



    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

    event.addListener(text, "compositionstart", onCompositionStart);
    if (useragent.isGecko) {
      event.addListener(text, "text", function(){syncComposition.schedule()});
    } else {
      event.addListener(text, "keyup", function(){syncComposition.schedule()});
      event.addListener(text, "keydown", function(){syncComposition.schedule()});
    }
    event.addListener(text, "compositionend", onCompositionEnd);

    this.getElement = function() {
      return text;
    };

    this.setReadOnly = function(readOnly) {
      text.readOnly = readOnly;
    };

    this.onContextMenu = function(e) {
      afterContextMenu = true;
      resetSelection(host.selection.isEmpty());
      host._emit("nativecontextmenu", {target: host, domEvent: e});
      this.moveToMouse(e, true);
    };

    this.moveToMouse = function(e, bringToFront) {
      if (!bringToFront && useragent.isOldIE)
        return;
      if (!tempStyle)
        tempStyle = text.style.cssText;
      text.style.cssText = (bringToFront ? "z-index:100000;" : "")
        + "height:" + text.style.height + ";"
        + (useragent.isIE ? "opacity:0.1;" : "");

      var rect = host.container.getBoundingClientRect();
      var style = dom.computedStyle(host.container);
      var top = rect.top + (parseInt(style.borderTopWidth) || 0);
      var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
      var maxTop = rect.bottom - top - text.clientHeight -2;
      var move = function(e) {
        text.style.left = e.clientX - left - 2 + "px";
        text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
      };
      move(e);

      if (e.type != "mousedown")
        return;

      if (host.renderer.$keepTextAreaAtCursor)
        host.renderer.$keepTextAreaAtCursor = null;

      clearTimeout(closeTimeout);
      if (useragent.isWin && !useragent.isOldIE)
        event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
      clearTimeout(closeTimeout);
      closeTimeout = setTimeout(function () {
        if (tempStyle) {
          text.style.cssText = tempStyle;
          tempStyle = '';
        }
        if (host.renderer.$keepTextAreaAtCursor == null) {
          host.renderer.$keepTextAreaAtCursor = true;
          host.renderer.$moveTextAreaToCursor();
        }
      }, useragent.isOldIE ? 200 : 0);
    }

    var onContextMenu = function(e) {
      host.textInput.onContextMenu(e);
      onContextMenuClose();
    };
    event.addListener(text, "mouseup", onContextMenu);
    event.addListener(text, "mousedown", function(e) {
      e.preventDefault();
      onContextMenuClose();
    });
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
    event.addListener(text, "contextmenu", onContextMenu);
  };

  exports.TextInput = TextInput;
});

ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {
  "use strict";

  var dom = require("../lib/dom");
  var event = require("../lib/event");
  var useragent = require("../lib/useragent");

  var DRAG_OFFSET = 0; // pixels

  function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;

    var editor = mouseHandler.editor;
    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
    editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
      "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

    exports.forEach(function(x) {
      mouseHandler[x] = this[x];
    }, this);

    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
  }

  (function() {

    this.onMouseDown = function(ev) {
      var inSelection = ev.inSelection();
      var pos = ev.getDocumentPosition();
      this.mousedownEvent = ev;
      var editor = this.editor;

      var button = ev.getButton();
      if (button !== 0) {
        var selectionRange = editor.getSelectionRange();
        var selectionEmpty = selectionRange.isEmpty();
        editor.$blockScrolling++;
        if (selectionEmpty || button == 1)
          editor.selection.moveToPosition(pos);
        editor.$blockScrolling--;
        if (button == 2)
          editor.textInput.onContextMenu(ev.domEvent);
        return; // stopping event here breaks contextmenu on ff mac
      }

      this.mousedownEvent.time = Date.now();
      if (inSelection && !editor.isFocused()) {
        editor.focus();
        if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
          this.setState("focusWait");
          this.captureMouse(ev);
          return;
        }
      }

      this.captureMouse(ev);
      this.startSelect(pos, ev.domEvent._clicks > 1);
      return ev.preventDefault();
    };

    this.startSelect = function(pos, waitForClickSelection) {
      pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
      var editor = this.editor;
      editor.$blockScrolling++;
      if (this.mousedownEvent.getShiftKey())
        editor.selection.selectToPosition(pos);
      else if (!waitForClickSelection)
        editor.selection.moveToPosition(pos);
      if (!waitForClickSelection)
        this.select();
      if (editor.renderer.scroller.setCapture) {
        editor.renderer.scroller.setCapture();
      }
      editor.setStyle("ace_selecting");
      this.setState("select");
      editor.$blockScrolling--;
    };

    this.select = function() {
      var anchor, editor = this.editor;
      var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
      editor.$blockScrolling++;
      if (this.$clickSelection) {
        var cmp = this.$clickSelection.comparePoint(cursor);

        if (cmp == -1) {
          anchor = this.$clickSelection.end;
        } else if (cmp == 1) {
          anchor = this.$clickSelection.start;
        } else {
          var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
          cursor = orientedRange.cursor;
          anchor = orientedRange.anchor;
        }
        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
      }
      editor.selection.selectToPosition(cursor);
      editor.$blockScrolling--;
      editor.renderer.scrollCursorIntoView();
    };

    this.extendSelectionBy = function(unitName) {
      var anchor, editor = this.editor;
      var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
      var range = editor.selection[unitName](cursor.row, cursor.column);
      editor.$blockScrolling++;
      if (this.$clickSelection) {
        var cmpStart = this.$clickSelection.comparePoint(range.start);
        var cmpEnd = this.$clickSelection.comparePoint(range.end);

        if (cmpStart == -1 && cmpEnd <= 0) {
          anchor = this.$clickSelection.end;
          if (range.end.row != cursor.row || range.end.column != cursor.column)
            cursor = range.start;
        } else if (cmpEnd == 1 && cmpStart >= 0) {
          anchor = this.$clickSelection.start;
          if (range.start.row != cursor.row || range.start.column != cursor.column)
            cursor = range.end;
        } else if (cmpStart == -1 && cmpEnd == 1) {
          cursor = range.end;
          anchor = range.start;
        } else {
          var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
          cursor = orientedRange.cursor;
          anchor = orientedRange.anchor;
        }
        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
      }
      editor.selection.selectToPosition(cursor);
      editor.$blockScrolling--;
      editor.renderer.scrollCursorIntoView();
    };

    this.selectEnd =
      this.selectAllEnd =
        this.selectByWordsEnd =
          this.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
            if (this.editor.renderer.scroller.releaseCapture) {
              this.editor.renderer.scroller.releaseCapture();
            }
          };

    this.focusWait = function() {
      var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
      var time = Date.now();

      if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
        this.startSelect(this.mousedownEvent.getDocumentPosition());
    };

    this.onDoubleClick = function(ev) {
      var pos = ev.getDocumentPosition();
      var editor = this.editor;
      var session = editor.session;

      var range = session.getBracketRange(pos);
      if (range) {
        if (range.isEmpty()) {
          range.start.column--;
          range.end.column++;
        }
        this.setState("select");
      } else {
        range = editor.selection.getWordRange(pos.row, pos.column);
        this.setState("selectByWords");
      }
      this.$clickSelection = range;
      this.select();
    };

    this.onTripleClick = function(ev) {
      var pos = ev.getDocumentPosition();
      var editor = this.editor;

      this.setState("selectByLines");
      var range = editor.getSelectionRange();
      if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
        this.$clickSelection = editor.selection.getLineRange(range.start.row);
        this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
      } else {
        this.$clickSelection = editor.selection.getLineRange(pos.row);
      }
      this.select();
    };

    this.onQuadClick = function(ev) {
      var editor = this.editor;

      editor.selectAll();
      this.$clickSelection = editor.getSelectionRange();
      this.setState("selectAll");
    };

    this.onMouseWheel = function(ev) {
      if (ev.getAccelKey())
        return;
      if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
        ev.wheelX = ev.wheelY;
        ev.wheelY = 0;
      }

      var t = ev.domEvent.timeStamp;
      var dt = t - (this.$lastScrollTime||0);

      var editor = this.editor;
      var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
      if (isScrolable || dt < 200) {
        this.$lastScrollTime = t;
        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        return ev.stop();
      }
    };

    this.onTouchMove = function (ev) {
      var t = ev.domEvent.timeStamp;
      var dt = t - (this.$lastScrollTime || 0);

      var editor = this.editor;
      var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
      if (isScrolable || dt < 200) {
        this.$lastScrollTime = t;
        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        return ev.stop();
      }
    };

  }).call(DefaultHandlers.prototype);

  exports.DefaultHandlers = DefaultHandlers;

  function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
  }

  function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
      var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
      var cmp = cursor.column - 4;
    else
      var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
      return {cursor: range.start, anchor: range.end};
    else
      return {cursor: range.end, anchor: range.start};
  }

});

ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var dom = require("./lib/dom");
  function Tooltip (parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
  }

  (function() {
    this.$init = function() {
      this.$element = dom.createElement("div");
      this.$element.className = "ace_tooltip";
      this.$element.style.display = "none";
      this.$parentNode.appendChild(this.$element);
      return this.$element;
    };
    this.getElement = function() {
      return this.$element || this.$init();
    };
    this.setText = function(text) {
      dom.setInnerText(this.getElement(), text);
    };
    this.setHtml = function(html) {
      this.getElement().innerHTML = html;
    };
    this.setPosition = function(x, y) {
      this.getElement().style.left = x + "px";
      this.getElement().style.top = y + "px";
    };
    this.setClassName = function(className) {
      dom.addCssClass(this.getElement(), className);
    };
    this.show = function(text, x, y) {
      if (text != null)
        this.setText(text);
      if (x != null && y != null)
        this.setPosition(x, y);
      if (!this.isOpen) {
        this.getElement().style.display = "block";
        this.isOpen = true;
      }
    };

    this.hide = function() {
      if (this.isOpen) {
        this.getElement().style.display = "none";
        this.isOpen = false;
      }
    };
    this.getHeight = function() {
      return this.getElement().offsetHeight;
    };
    this.getWidth = function() {
      return this.getElement().offsetWidth;
    };

  }).call(Tooltip.prototype);

  exports.Tooltip = Tooltip;
});

ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(require, exports, module) {
  "use strict";
  var dom = require("../lib/dom");
  var oop = require("../lib/oop");
  var event = require("../lib/event");
  var Tooltip = require("../tooltip").Tooltip;

  function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
      if (!editor.isFocused() || e.getButton() != 0)
        return;
      var gutterRegion = gutter.getRegion(e);

      if (gutterRegion == "foldWidgets")
        return;

      var row = e.getDocumentPosition().row;
      var selection = editor.session.selection;

      if (e.getShiftKey())
        selection.selectTo(row, 0);
      else {
        if (e.domEvent.detail == 2) {
          editor.selectAll();
          return e.preventDefault();
        }
        mouseHandler.$clickSelection = editor.selection.getLineRange(row);
      }
      mouseHandler.setState("selectByLines");
      mouseHandler.captureMouse(e);
      return e.preventDefault();
    });


    var tooltipTimeout, mouseEvent, tooltipAnnotation;

    function showTooltip() {
      var row = mouseEvent.getDocumentPosition().row;
      var annotation = gutter.$annotations[row];
      if (!annotation)
        return hideTooltip();

      var maxRow = editor.session.getLength();
      if (row == maxRow) {
        var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
        var pos = mouseEvent.$pos;
        if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
          return hideTooltip();
      }

      if (tooltipAnnotation == annotation)
        return;
      tooltipAnnotation = annotation.text.join("<br/>");

      tooltip.setHtml(tooltipAnnotation);
      tooltip.show();
      editor._signal("showGutterTooltip", tooltip);
      editor.on("mousewheel", hideTooltip);

      if (mouseHandler.$tooltipFollowsMouse) {
        moveTooltip(mouseEvent);
      } else {
        var gutterElement = mouseEvent.domEvent.target;
        var rect = gutterElement.getBoundingClientRect();
        var style = tooltip.getElement().style;
        style.left = rect.right + "px";
        style.top = rect.bottom + "px";
      }
    }

    function hideTooltip() {
      if (tooltipTimeout)
        tooltipTimeout = clearTimeout(tooltipTimeout);
      if (tooltipAnnotation) {
        tooltip.hide();
        tooltipAnnotation = null;
        editor._signal("hideGutterTooltip", tooltip);
        editor.removeEventListener("mousewheel", hideTooltip);
      }
    }

    function moveTooltip(e) {
      tooltip.setPosition(e.x, e.y);
    }

    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
      var target = e.domEvent.target || e.domEvent.srcElement;
      if (dom.hasCssClass(target, "ace_fold-widget"))
        return hideTooltip();

      if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
        moveTooltip(e);

      mouseEvent = e;
      if (tooltipTimeout)
        return;
      tooltipTimeout = setTimeout(function() {
        tooltipTimeout = null;
        if (mouseEvent && !mouseHandler.isMousePressed)
          showTooltip();
        else
          hideTooltip();
      }, 50);
    });

    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
      mouseEvent = null;
      if (!tooltipAnnotation || tooltipTimeout)
        return;

      tooltipTimeout = setTimeout(function() {
        tooltipTimeout = null;
        hideTooltip();
      }, 50);
    });

    editor.on("changeSession", hideTooltip);
  }

  function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
  }

  oop.inherits(GutterTooltip, Tooltip);

  (function(){
    this.setPosition = function(x, y) {
      var windowWidth = window.innerWidth || document.documentElement.clientWidth;
      var windowHeight = window.innerHeight || document.documentElement.clientHeight;
      var width = this.getWidth();
      var height = this.getHeight();
      x += 15;
      y += 15;
      if (x + width > windowWidth) {
        x -= (x + width) - windowWidth;
      }
      if (y + height > windowHeight) {
        y -= 20 + height;
      }
      Tooltip.prototype.setPosition.call(this, x, y);
    };

  }).call(GutterTooltip.prototype);



  exports.GutterHandler = GutterHandler;

});

ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {
  "use strict";

  var event = require("../lib/event");
  var useragent = require("../lib/useragent");
  var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;

    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;

    this.$pos = null;
    this.$inSelection = null;

    this.propagationStopped = false;
    this.defaultPrevented = false;
  };

  (function() {

    this.stopPropagation = function() {
      event.stopPropagation(this.domEvent);
      this.propagationStopped = true;
    };

    this.preventDefault = function() {
      event.preventDefault(this.domEvent);
      this.defaultPrevented = true;
    };

    this.stop = function() {
      this.stopPropagation();
      this.preventDefault();
    };
    this.getDocumentPosition = function() {
      if (this.$pos)
        return this.$pos;

      this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
      return this.$pos;
    };
    this.inSelection = function() {
      if (this.$inSelection !== null)
        return this.$inSelection;

      var editor = this.editor;


      var selectionRange = editor.getSelectionRange();
      if (selectionRange.isEmpty())
        this.$inSelection = false;
      else {
        var pos = this.getDocumentPosition();
        this.$inSelection = selectionRange.contains(pos.row, pos.column);
      }

      return this.$inSelection;
    };
    this.getButton = function() {
      return event.getButton(this.domEvent);
    };
    this.getShiftKey = function() {
      return this.domEvent.shiftKey;
    };

    this.getAccelKey = useragent.isMac
      ? function() { return this.domEvent.metaKey; }
      : function() { return this.domEvent.ctrlKey; };

  }).call(MouseEvent.prototype);

});

ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {
  "use strict";

  var dom = require("../lib/dom");
  var event = require("../lib/event");
  var useragent = require("../lib/useragent");

  var AUTOSCROLL_DELAY = 200;
  var SCROLL_CURSOR_DELAY = 200;
  var SCROLL_CURSOR_HYSTERESIS = 5;

  function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var blankImage = dom.createElement("img");
    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (useragent.isOpera)
      blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

    exports.forEach(function(x) {
      mouseHandler[x] = this[x];
    }, this);
    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;

    this.onDragStart = function(e) {
      if (this.cancelDrag || !mouseTarget.draggable) {
        var self = this;
        setTimeout(function(){
          self.startSelect();
          self.captureMouse(e);
        }, 0);
        return e.preventDefault();
      }
      range = editor.getSelectionRange();

      var dataTransfer = e.dataTransfer;
      dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
      if (useragent.isOpera) {
        editor.container.appendChild(blankImage);
        blankImage.scrollTop = 0;
      }
      dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
      if (useragent.isOpera) {
        editor.container.removeChild(blankImage);
      }
      dataTransfer.clearData();
      dataTransfer.setData("Text", editor.session.getTextRange());

      isInternal = true;
      this.setState("drag");
    };

    this.onDragEnd = function(e) {
      mouseTarget.draggable = false;
      isInternal = false;
      this.setState(null);
      if (!editor.getReadOnly()) {
        var dropEffect = e.dataTransfer.dropEffect;
        if (!dragOperation && dropEffect == "move")
          editor.session.remove(editor.getSelectionRange());
        editor.renderer.$cursorLayer.setBlinking(true);
      }
      this.editor.unsetStyle("ace_dragging");
      this.editor.renderer.setCursorStyle("");
    };

    this.onDragEnter = function(e) {
      if (editor.getReadOnly() || !canAccept(e.dataTransfer))
        return;
      x = e.clientX;
      y = e.clientY;
      if (!dragSelectionMarker)
        addDragMarker();
      counter++;
      e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
      return event.preventDefault(e);
    };

    this.onDragOver = function(e) {
      if (editor.getReadOnly() || !canAccept(e.dataTransfer))
        return;
      x = e.clientX;
      y = e.clientY;
      if (!dragSelectionMarker) {
        addDragMarker();
        counter++;
      }
      if (onMouseMoveTimer !== null)
        onMouseMoveTimer = null;

      e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
      return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
      counter--;
      if (counter <= 0 && dragSelectionMarker) {
        clearDragMarker();
        dragOperation = null;
        return event.preventDefault(e);
      }
    };

    this.onDrop = function(e) {
      if (!dragCursor)
        return;
      var dataTransfer = e.dataTransfer;
      if (isInternal) {
        switch (dragOperation) {
          case "move":
            if (range.contains(dragCursor.row, dragCursor.column)) {
              range = {
                start: dragCursor,
                end: dragCursor
              };
            } else {
              range = editor.moveText(range, dragCursor);
            }
            break;
          case "copy":
            range = editor.moveText(range, dragCursor, true);
            break;
        }
      } else {
        var dropData = dataTransfer.getData('Text');
        range = {
          start: dragCursor,
          end: editor.session.insert(dragCursor, dropData)
        };
        editor.focus();
        dragOperation = null;
      }
      clearDragMarker();
      return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

    function scrollCursorIntoView(cursor, prevCursor) {
      var now = Date.now();
      var vMovement = !prevCursor || cursor.row != prevCursor.row;
      var hMovement = !prevCursor || cursor.column != prevCursor.column;
      if (!cursorMovedTime || vMovement || hMovement) {
        editor.$blockScrolling += 1;
        editor.moveCursorToPosition(cursor);
        editor.$blockScrolling -= 1;
        cursorMovedTime = now;
        cursorPointOnCaretMoved = {x: x, y: y};
      } else {
        var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
        if (distance > SCROLL_CURSOR_HYSTERESIS) {
          cursorMovedTime = null;
        } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
          editor.renderer.scrollCursorIntoView();
          cursorMovedTime = null;
        }
      }
    }

    function autoScroll(cursor, prevCursor) {
      var now = Date.now();
      var lineHeight = editor.renderer.layerConfig.lineHeight;
      var characterWidth = editor.renderer.layerConfig.characterWidth;
      var editorRect = editor.renderer.scroller.getBoundingClientRect();
      var offsets = {
        x: {
          left: x - editorRect.left,
          right: editorRect.right - x
        },
        y: {
          top: y - editorRect.top,
          bottom: editorRect.bottom - y
        }
      };
      var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
      var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
      var scrollCursor = {row: cursor.row, column: cursor.column};
      if (nearestXOffset / characterWidth <= 2) {
        scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
      }
      if (nearestYOffset / lineHeight <= 1) {
        scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
      }
      var vScroll = cursor.row != scrollCursor.row;
      var hScroll = cursor.column != scrollCursor.column;
      var vMovement = !prevCursor || cursor.row != prevCursor.row;
      if (vScroll || (hScroll && !vMovement)) {
        if (!autoScrollStartTime)
          autoScrollStartTime = now;
        else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
          editor.renderer.scrollCursorIntoView(scrollCursor);
      } else {
        autoScrollStartTime = null;
      }
    }

    function onDragInterval() {
      var prevCursor = dragCursor;
      dragCursor = editor.renderer.screenToTextCoordinates(x, y);
      scrollCursorIntoView(dragCursor, prevCursor);
      autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
      range = editor.selection.toOrientedRange();
      dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
      editor.clearSelection();
      if (editor.isFocused())
        editor.renderer.$cursorLayer.setBlinking(false);
      clearInterval(timerId);
      onDragInterval();
      timerId = setInterval(onDragInterval, 20);
      counter = 0;
      event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
      clearInterval(timerId);
      editor.session.removeMarker(dragSelectionMarker);
      dragSelectionMarker = null;
      editor.$blockScrolling += 1;
      editor.selection.fromOrientedRange(range);
      editor.$blockScrolling -= 1;
      if (editor.isFocused() && !isInternal)
        editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
      range = null;
      dragCursor = null;
      counter = 0;
      autoScrollStartTime = null;
      cursorMovedTime = null;
      event.removeListener(document, "mousemove", onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
      if (onMouseMoveTimer == null) {
        onMouseMoveTimer = setTimeout(function() {
          if (onMouseMoveTimer != null && dragSelectionMarker)
            clearDragMarker();
        }, 20);
      }
    }

    function canAccept(dataTransfer) {
      var types = dataTransfer.types;
      return !types || Array.prototype.some.call(types, function(type) {
          return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
      var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
      var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

      var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
      var effectAllowed = "uninitialized";
      try {
        effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
      } catch (e) {}
      var dropEffect = "none";

      if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
        dropEffect = "copy";
      else if (moveAllowed.indexOf(effectAllowed) >= 0)
        dropEffect = "move";
      else if (copyAllowed.indexOf(effectAllowed) >= 0)
        dropEffect = "copy";

      return dropEffect;
    }
  }

  (function() {

    this.dragWait = function() {
      var interval = Date.now() - this.mousedownEvent.time;
      if (interval > this.editor.getDragDelay())
        this.startDrag();
    };

    this.dragWaitEnd = function() {
      var target = this.editor.container;
      target.draggable = false;
      this.startSelect(this.mousedownEvent.getDocumentPosition());
      this.selectEnd();
    };

    this.dragReadyEnd = function(e) {
      this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
      this.editor.unsetStyle("ace_dragging");
      this.editor.renderer.setCursorStyle("");
      this.dragWaitEnd();
    };

    this.startDrag = function(){
      this.cancelDrag = false;
      var editor = this.editor;
      var target = editor.container;
      target.draggable = true;
      editor.renderer.$cursorLayer.setBlinking(false);
      editor.setStyle("ace_dragging");
      var cursorStyle = useragent.isWin ? "default" : "move";
      editor.renderer.setCursorStyle(cursorStyle);
      this.setState("dragReady");
    };

    this.onMouseDrag = function(e) {
      var target = this.editor.container;
      if (useragent.isIE && this.state == "dragReady") {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        if (distance > 3)
          target.dragDrop();
      }
      if (this.state === "dragWait") {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        if (distance > 0) {
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
        }
      }
    };

    this.onMouseDown = function(e) {
      if (!this.$dragEnabled)
        return;
      this.mousedownEvent = e;
      var editor = this.editor;

      var inSelection = e.inSelection();
      var button = e.getButton();
      var clickCount = e.domEvent.detail || 1;
      if (clickCount === 1 && button === 0 && inSelection) {
        if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
          return;
        this.mousedownEvent.time = Date.now();
        var eventTarget = e.domEvent.target || e.domEvent.srcElement;
        if ("unselectable" in eventTarget)
          eventTarget.unselectable = "on";
        if (editor.getDragDelay()) {
          if (useragent.isWebKit) {
            this.cancelDrag = true;
            var mouseTarget = editor.container;
            mouseTarget.draggable = true;
          }
          this.setState("dragWait");
        } else {
          this.startDrag();
        }
        this.captureMouse(e, this.onMouseDrag.bind(this));
        e.defaultPrevented = true;
      }
    };

  }).call(DragdropHandler.prototype);


  function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
  }

  exports.DragdropHandler = DragdropHandler;

});

ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
  "use strict";
  var dom = require("./dom");

  exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        callback(xhr.responseText);
      }
    };
    xhr.send(null);
  };

  exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
      if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
        s = s.onload = s.onreadystatechange = null;
        if (!isAbort)
          callback();
      }
    };
  };
  exports.qualifyURL = function(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
  }

});

ace.define("ace/lib/event_emitter",["require","exports","module"], function(require, exports, module) {
  "use strict";

  var EventEmitter = {};
  var stopPropagation = function() { this.propagationStopped = true; };
  var preventDefault = function() { this.defaultPrevented = true; };

  EventEmitter._emit =
    EventEmitter._dispatchEvent = function(eventName, e) {
      this._eventRegistry || (this._eventRegistry = {});
      this._defaultHandlers || (this._defaultHandlers = {});

      var listeners = this._eventRegistry[eventName] || [];
      var defaultHandler = this._defaultHandlers[eventName];
      if (!listeners.length && !defaultHandler)
        return;

      if (typeof e != "object" || !e)
        e = {};

      if (!e.type)
        e.type = eventName;
      if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
      if (!e.preventDefault)
        e.preventDefault = preventDefault;

      listeners = listeners.slice();
      for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
          break;
      }

      if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
    };


  EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
      return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
      listeners[i](e, this);
  };

  EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
      _self.removeEventListener(eventName, newCallback);
      callback.apply(null, arguments);
    });
  };


  EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
      handlers = this._defaultHandlers = {_disabled_: {}};

    if (handlers[eventName]) {
      var old = handlers[eventName];
      var disabled = handlers._disabled_[eventName];
      if (!disabled)
        handlers._disabled_[eventName] = disabled = [];
      disabled.push(old);
      var i = disabled.indexOf(callback);
      if (i != -1)
        disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
  };
  EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
      return;
    var disabled = handlers._disabled_[eventName];

    if (handlers[eventName] == callback) {
      var old = handlers[eventName];
      if (disabled)
        this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
      var i = disabled.indexOf(callback);
      if (i != -1)
        disabled.splice(i, 1);
    }
  };

  EventEmitter.on =
    EventEmitter.addEventListener = function(eventName, callback, capturing) {
      this._eventRegistry = this._eventRegistry || {};

      var listeners = this._eventRegistry[eventName];
      if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

      if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
      return callback;
    };

  EventEmitter.off =
    EventEmitter.removeListener =
      EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};

        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return;

        var index = listeners.indexOf(callback);
        if (index !== -1)
          listeners.splice(index, 1);
      };

  EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
  };

  exports.EventEmitter = EventEmitter;

});

ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
  "no use strict";

  var oop = require("./oop");
  var EventEmitter = require("./event_emitter").EventEmitter;

  var optionsProvider = {
    setOptions: function(optList) {
      Object.keys(optList).forEach(function(key) {
        this.setOption(key, optList[key]);
      }, this);
    },
    getOptions: function(optionNames) {
      var result = {};
      if (!optionNames) {
        optionNames = Object.keys(this.$options);
      } else if (!Array.isArray(optionNames)) {
        result = optionNames;
        optionNames = Object.keys(result);
      }
      optionNames.forEach(function(key) {
        result[key] = this.getOption(key);
      }, this);
      return result;
    },
    setOption: function(name, value) {
      if (this["$" + name] === value)
        return;
      var opt = this.$options[name];
      if (!opt) {
        return warn('misspelled option "' + name + '"');
      }
      if (opt.forwardTo)
        return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

      if (!opt.handlesSet)
        this["$" + name] = value;
      if (opt && opt.set)
        opt.set.call(this, value);
    },
    getOption: function(name) {
      var opt = this.$options[name];
      if (!opt) {
        return warn('misspelled option "' + name + '"');
      }
      if (opt.forwardTo)
        return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
      return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
  };

  function warn(message) {
    if (typeof console != "undefined" && console.warn)
      console.warn.apply(console, arguments);
  }

  function reportError(msg, data) {
    var e = new Error(msg);
    e.data = data;
    if (typeof console == "object" && console.error)
      console.error(e);
    setTimeout(function() { throw e; });
  }

  var AppConfig = function() {
    this.$defaultOptions = {};
  };

  (function() {
    oop.implement(this, EventEmitter);
    this.defineOptions = function(obj, path, options) {
      if (!obj.$options)
        this.$defaultOptions[path] = obj.$options = {};

      Object.keys(options).forEach(function(key) {
        var opt = options[key];
        if (typeof opt == "string")
          opt = {forwardTo: opt};

        opt.name || (opt.name = key);
        obj.$options[opt.name] = opt;
        if ("initialValue" in opt)
          obj["$" + opt.name] = opt.initialValue;
      });
      oop.implement(obj, optionsProvider);

      return this;
    };

    this.resetOptions = function(obj) {
      Object.keys(obj.$options).forEach(function(key) {
        var opt = obj.$options[key];
        if ("value" in opt)
          obj.setOption(key, opt.value);
      });
    };

    this.setDefaultValue = function(path, name, value) {
      var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
      if (opts[name]) {
        if (opts.forwardTo)
          this.setDefaultValue(opts.forwardTo, name, value);
        else
          opts[name].value = value;
      }
    };

    this.setDefaultValues = function(path, optionHash) {
      Object.keys(optionHash).forEach(function(key) {
        this.setDefaultValue(path, key, optionHash[key]);
      }, this);
    };

    this.warn = warn;
    this.reportError = reportError;

  }).call(AppConfig.prototype);

  exports.AppConfig = AppConfig;

});

ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(require, exports, module) {
  "no use strict";

  var lang = require("./lib/lang");
  var oop = require("./lib/oop");
  var net = require("./lib/net");
  var AppConfig = require("./lib/app_config").AppConfig;

  module.exports = exports = new AppConfig();

  var global = (function() {
    return this || typeof window != "undefined" && window;
  })();

  var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {}
  };

  exports.get = function(key) {
    if (!options.hasOwnProperty(key))
      throw new Error("Unknown config key: " + key);

    return options[key];
  };

  exports.set = function(key, value) {
    if (!options.hasOwnProperty(key))
      throw new Error("Unknown config key: " + key);

    options[key] = value;
  };

  exports.all = function() {
    return lang.copyObject(options);
  };
  exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
      return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
      var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
      base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
      base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
      path = options.basePath;
    } else if (sep == "/") {
      component = sep = "";
    }
    if (path && path.slice(-1) != "/")
      path += "/";
    return path + component + sep + base + this.get("suffix");
  };

  exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
  };

  exports.$loading = {};
  exports.loadModule = function(moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
      moduleType = moduleName[0];
      moduleName = moduleName[1];
    }

    try {
      module = require(moduleName);
    } catch (e) {}
    if (module && !exports.$loading[moduleName])
      return onLoad && onLoad(module);

    if (!exports.$loading[moduleName])
      exports.$loading[moduleName] = [];

    exports.$loading[moduleName].push(onLoad);

    if (exports.$loading[moduleName].length > 1)
      return;

    var afterLoad = function() {
      require([moduleName], function(module) {
        exports._emit("load.module", {name: moduleName, module: module});
        var listeners = exports.$loading[moduleName];
        exports.$loading[moduleName] = null;
        listeners.forEach(function(onLoad) {
          onLoad && onLoad(module);
        });
      });
    };

    if (!exports.get("packaged"))
      return afterLoad();
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
  };
  init(true);function init(packaged) {

    if (!global || !global.document)
      return;

    options.packaged = packaged || require.packaged || module.packaged || (global.define && define.packaged);

    var scriptOptions = {};
    var scriptUrl = "";
    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
    var currentDocument = currentScript && currentScript.ownerDocument || document;

    var scripts = currentDocument.getElementsByTagName("script");
    for (var i=0; i<scripts.length; i++) {
      var script = scripts[i];

      var src = script.src || script.getAttribute("src");
      if (!src)
        continue;

      var attributes = script.attributes;
      for (var j=0, l=attributes.length; j < l; j++) {
        var attr = attributes[j];
        if (attr.name.indexOf("data-ace-") === 0) {
          scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
        }
      }

      var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
      if (m)
        scriptUrl = m[1];
    }

    if (scriptUrl) {
      scriptOptions.base = scriptOptions.base || scriptUrl;
      scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
      if (typeof scriptOptions[key] !== "undefined")
        exports.set(key, scriptOptions[key]);
  }

  exports.init = init;

  function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
  }

});

ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/config"], function(require, exports, module) {
  "use strict";

  var event = require("../lib/event");
  var useragent = require("../lib/useragent");
  var DefaultHandlers = require("./default_handlers").DefaultHandlers;
  var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
  var MouseEvent = require("./mouse_event").MouseEvent;
  var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
  var config = require("../config");

  var MouseHandler = function(editor) {
    var _self = this;
    this.editor = editor;

    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);

    var focusEditor = function(e) {
      var windowBlurred = !document.hasFocus || !document.hasFocus()
        || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement())
      if (windowBlurred)
        window.focus();
      editor.focus();
    };

    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
    event.addMultiMouseDownListener([
      mouseTarget,
      editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
      editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
      editor.textInput && editor.textInput.getElement()
    ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

    event.addListener(mouseTarget, "mousedown", focusEditor);
    event.addListener(gutterEl, "mousedown", focusEditor);
    if (useragent.isIE && editor.renderer.scrollBarV) {
      event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
      event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
    }

    editor.on("mousemove", function(e){
      if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
        return;

      var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
      var range = editor.session.selection.getRange();
      var renderer = editor.renderer;

      if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
        renderer.setCursorStyle("default");
      } else {
        renderer.setCursorStyle("");
      }
    });
  };

  (function() {
    this.onMouseEvent = function(name, e) {
      this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseMove = function(name, e) {
      var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
      if (!listeners || !listeners.length)
        return;

      this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseWheel = function(name, e) {
      var mouseEvent = new MouseEvent(e, this.editor);
      mouseEvent.speed = this.$scrollSpeed * 2;
      mouseEvent.wheelX = e.wheelX;
      mouseEvent.wheelY = e.wheelY;

      this.editor._emit(name, mouseEvent);
    };

    this.onTouchMove = function (name, e) {
      var mouseEvent = new MouseEvent(e, this.editor);
      mouseEvent.speed = 1;//this.$scrollSpeed * 2;
      mouseEvent.wheelX = e.wheelX;
      mouseEvent.wheelY = e.wheelY;
      this.editor._emit(name, mouseEvent);
    };

    this.setState = function(state) {
      this.state = state;
    };

    this.captureMouse = function(ev, mouseMoveHandler) {
      this.x = ev.x;
      this.y = ev.y;

      this.isMousePressed = true;
      var renderer = this.editor.renderer;
      if (renderer.$keepTextAreaAtCursor)
        renderer.$keepTextAreaAtCursor = null;

      var self = this;
      var onMouseMove = function(e) {
        if (!e) return;
        if (useragent.isWebKit && !e.which && self.releaseMouse)
          return self.releaseMouse();

        self.x = e.clientX;
        self.y = e.clientY;
        mouseMoveHandler && mouseMoveHandler(e);
        self.mouseEvent = new MouseEvent(e, self.editor);
        self.$mouseMoved = true;
      };

      var onCaptureEnd = function(e) {
        clearInterval(timerId);
        onCaptureInterval();
        self[self.state + "End"] && self[self.state + "End"](e);
        self.state = "";
        if (renderer.$keepTextAreaAtCursor == null) {
          renderer.$keepTextAreaAtCursor = true;
          renderer.$moveTextAreaToCursor();
        }
        self.isMousePressed = false;
        self.$onCaptureMouseMove = self.releaseMouse = null;
        e && self.onMouseEvent("mouseup", e);
      };

      var onCaptureInterval = function() {
        self[self.state] && self[self.state]();
        self.$mouseMoved = false;
      };

      if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
        return setTimeout(function() {onCaptureEnd(ev);});
      }

      self.$onCaptureMouseMove = onMouseMove;
      self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
      var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
    this.cancelContextMenu = function() {
      var stop = function(e) {
        if (e && e.domEvent && e.domEvent.type != "contextmenu")
          return;
        this.editor.off("nativecontextmenu", stop);
        if (e && e.domEvent)
          event.stopEvent(e.domEvent);
      }.bind(this);
      setTimeout(stop, 10);
      this.editor.on("nativecontextmenu", stop);
    };
  }).call(MouseHandler.prototype);

  config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
    dragEnabled: {initialValue: true},
    focusTimout: {initialValue: 0},
    tooltipFollowsMouse: {initialValue: true}
  });


  exports.MouseHandler = MouseHandler;
});

ace.define("ace/mouse/fold_handler",["require","exports","module"], function(require, exports, module) {
  "use strict";

  function FoldHandler(editor) {

    editor.on("click", function(e) {
      var position = e.getDocumentPosition();
      var session = editor.session;
      var fold = session.getFoldAt(position.row, position.column, 1);
      if (fold) {
        if (e.getAccelKey())
          session.removeFold(fold);
        else
          session.expandFold(fold);

        e.stop();
      }
    });

    editor.on("gutterclick", function(e) {
      var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

      if (gutterRegion == "foldWidgets") {
        var row = e.getDocumentPosition().row;
        var session = editor.session;
        if (session.foldWidgets && session.foldWidgets[row])
          editor.session.onFoldWidgetClick(row, e);
        if (!editor.isFocused())
          editor.focus();
        e.stop();
      }
    });

    editor.on("gutterdblclick", function(e) {
      var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

      if (gutterRegion == "foldWidgets") {
        var row = e.getDocumentPosition().row;
        var session = editor.session;
        var data = session.getParentFoldRangeData(row, true);
        var range = data.range || data.firstRange;

        if (range) {
          row = range.start.row;
          var fold = session.getFoldAt(row, session.getLine(row).length, 1);

          if (fold) {
            session.removeFold(fold);
          } else {
            session.addFold("...", range);
            editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
          }
        }
        e.stop();
      }
    });
  }

  exports.FoldHandler = FoldHandler;

});

ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(require, exports, module) {
  "use strict";

  var keyUtil  = require("../lib/keys");
  var event = require("../lib/event");

  var KeyBinding = function(editor) {
    this.$editor = editor;
    this.$data = {editor: editor};
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
  };

  (function() {
    this.setDefaultHandler = function(kb) {
      this.removeKeyboardHandler(this.$defaultHandler);
      this.$defaultHandler = kb;
      this.addKeyboardHandler(kb, 0);
    };

    this.setKeyboardHandler = function(kb) {
      var h = this.$handlers;
      if (h[h.length - 1] == kb)
        return;

      while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
        this.removeKeyboardHandler(h[h.length - 1]);

      this.addKeyboardHandler(kb, 1);
    };

    this.addKeyboardHandler = function(kb, pos) {
      if (!kb)
        return;
      if (typeof kb == "function" && !kb.handleKeyboard)
        kb.handleKeyboard = kb;
      var i = this.$handlers.indexOf(kb);
      if (i != -1)
        this.$handlers.splice(i, 1);

      if (pos == undefined)
        this.$handlers.push(kb);
      else
        this.$handlers.splice(pos, 0, kb);

      if (i == -1 && kb.attach)
        kb.attach(this.$editor);
    };

    this.removeKeyboardHandler = function(kb) {
      var i = this.$handlers.indexOf(kb);
      if (i == -1)
        return false;
      this.$handlers.splice(i, 1);
      kb.detach && kb.detach(this.$editor);
      return true;
    };

    this.getKeyboardHandler = function() {
      return this.$handlers[this.$handlers.length - 1];
    };

    this.getStatusText = function() {
      var data = this.$data;
      var editor = data.editor;
      return this.$handlers.map(function(h) {
        return h.getStatusText && h.getStatusText(editor, data) || "";
      }).filter(Boolean).join(" ");
    };

    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
      var toExecute;
      var success = false;
      var commands = this.$editor.commands;

      for (var i = this.$handlers.length; i--;) {
        toExecute = this.$handlers[i].handleKeyboard(
          this.$data, hashId, keyString, keyCode, e
        );
        if (!toExecute || !toExecute.command)
          continue;
        if (toExecute.command == "null") {
          success = true;
        } else {
          success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
        }
        if (success && e && hashId != -1 &&
          toExecute.passEvent != true && toExecute.command.passEvent != true
        ) {
          event.stopEvent(e);
        }
        if (success)
          break;
      }

      if (!success && hashId == -1) {
        toExecute = {command: "insertstring"};
        success = commands.exec("insertstring", this.$editor, keyString);
      }

      if (success && this.$editor._signal)
        this.$editor._signal("keyboardActivity", toExecute);

      return success;
    };

    this.onCommandKey = function(e, hashId, keyCode) {
      var keyString = keyUtil.keyCodeToString(keyCode);
      this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };

    this.onTextInput = function(text) {
      this.$callKeyboardHandlers(-1, text);
    };

  }).call(KeyBinding.prototype);

  exports.KeyBinding = KeyBinding;
});

ace.define("ace/range",["require","exports","module"], function(require, exports, module) {
  "use strict";
  var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
  };
  var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
      row: startRow,
      column: startColumn
    };

    this.end = {
      row: endRow,
      column: endColumn
    };
  };

  (function() {
    this.isEqual = function(range) {
      return this.start.row === range.start.row &&
        this.end.row === range.end.row &&
        this.start.column === range.start.column &&
        this.end.column === range.end.column;
    };
    this.toString = function() {
      return ("Range: [" + this.start.row + "/" + this.start.column +
      "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
      return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
      var cmp,
        end = range.end,
        start = range.start;

      cmp = this.compare(end.row, end.column);
      if (cmp == 1) {
        cmp = this.compare(start.row, start.column);
        if (cmp == 1) {
          return 2;
        } else if (cmp == 0) {
          return 1;
        } else {
          return 0;
        }
      } else if (cmp == -1) {
        return -2;
      } else {
        cmp = this.compare(start.row, start.column);
        if (cmp == -1) {
          return -1;
        } else if (cmp == 1) {
          return 42;
        } else {
          return 0;
        }
      }
    };
    this.comparePoint = function(p) {
      return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
      var cmp = this.compareRange(range);
      return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
      return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
      return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
      if (typeof row == "object") {
        this.start.column = row.column;
        this.start.row = row.row;
      } else {
        this.start.row = row;
        this.start.column = column;
      }
    };
    this.setEnd = function(row, column) {
      if (typeof row == "object") {
        this.end.column = row.column;
        this.end.row = row.row;
      } else {
        this.end.row = row;
        this.end.column = column;
      }
    };
    this.inside = function(row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isEnd(row, column) || this.isStart(row, column)) {
          return false;
        } else {
          return true;
        }
      }
      return false;
    };
    this.insideStart = function(row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isEnd(row, column)) {
          return false;
        } else {
          return true;
        }
      }
      return false;
    };
    this.insideEnd = function(row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isStart(row, column)) {
          return false;
        } else {
          return true;
        }
      }
      return false;
    };
    this.compare = function(row, column) {
      if (!this.isMultiLine()) {
        if (row === this.start.row) {
          return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
        }
      }

      if (row < this.start.row)
        return -1;

      if (row > this.end.row)
        return 1;

      if (this.start.row === row)
        return column >= this.start.column ? 0 : -1;

      if (this.end.row === row)
        return column <= this.end.column ? 0 : 1;

      return 0;
    };
    this.compareStart = function(row, column) {
      if (this.start.row == row && this.start.column == column) {
        return -1;
      } else {
        return this.compare(row, column);
      }
    };
    this.compareEnd = function(row, column) {
      if (this.end.row == row && this.end.column == column) {
        return 1;
      } else {
        return this.compare(row, column);
      }
    };
    this.compareInside = function(row, column) {
      if (this.end.row == row && this.end.column == column) {
        return 1;
      } else if (this.start.row == row && this.start.column == column) {
        return -1;
      } else {
        return this.compare(row, column);
      }
    };
    this.clipRows = function(firstRow, lastRow) {
      if (this.end.row > lastRow)
        var end = {row: lastRow + 1, column: 0};
      else if (this.end.row < firstRow)
        var end = {row: firstRow, column: 0};

      if (this.start.row > lastRow)
        var start = {row: lastRow + 1, column: 0};
      else if (this.start.row < firstRow)
        var start = {row: firstRow, column: 0};

      return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
      var cmp = this.compare(row, column);

      if (cmp == 0)
        return this;
      else if (cmp == -1)
        var start = {row: row, column: column};
      else
        var end = {row: row, column: column};

      return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
      return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
      return (this.start.row !== this.end.row);
    };
    this.clone = function() {
      return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
      if (this.end.column == 0)
        return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
      else
        return new Range(this.start.row, 0, this.end.row, 0)
    };
    this.toScreenRange = function(session) {
      var screenPosStart = session.documentToScreenPosition(this.start);
      var screenPosEnd = session.documentToScreenPosition(this.end);

      return new Range(
        screenPosStart.row, screenPosStart.column,
        screenPosEnd.row, screenPosEnd.column
      );
    };
    this.moveBy = function(row, column) {
      this.start.row += row;
      this.start.column += column;
      this.end.row += row;
      this.end.column += column;
    };

  }).call(Range.prototype);
  Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
  };
  Range.comparePoints = comparePoints;

  Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
  };


  exports.Range = Range;
});

ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var lang = require("./lib/lang");
  var EventEmitter = require("./lib/event_emitter").EventEmitter;
  var Range = require("./range").Range;
  var Selection = function(session) {
    this.session = session;
    this.doc = session.getDocument();

    this.clearSelection();
    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

    var self = this;
    this.lead.on("change", function(e) {
      self._emit("changeCursor");
      if (!self.$isEmpty)
        self._emit("changeSelection");
      if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
        self.$desiredColumn = null;
    });

    this.selectionAnchor.on("change", function() {
      if (!self.$isEmpty)
        self._emit("changeSelection");
    });
  };

  (function() {

    oop.implement(this, EventEmitter);
    this.isEmpty = function() {
      return (this.$isEmpty || (
        this.anchor.row == this.lead.row &&
        this.anchor.column == this.lead.column
      ));
    };
    this.isMultiLine = function() {
      if (this.isEmpty()) {
        return false;
      }

      return this.getRange().isMultiLine();
    };
    this.getCursor = function() {
      return this.lead.getPosition();
    };
    this.setSelectionAnchor = function(row, column) {
      this.anchor.setPosition(row, column);

      if (this.$isEmpty) {
        this.$isEmpty = false;
        this._emit("changeSelection");
      }
    };
    this.getSelectionAnchor = function() {
      if (this.$isEmpty)
        return this.getSelectionLead();
      else
        return this.anchor.getPosition();
    };
    this.getSelectionLead = function() {
      return this.lead.getPosition();
    };
    this.shiftSelection = function(columns) {
      if (this.$isEmpty) {
        this.moveCursorTo(this.lead.row, this.lead.column + columns);
        return;
      }

      var anchor = this.getSelectionAnchor();
      var lead = this.getSelectionLead();

      var isBackwards = this.isBackwards();

      if (!isBackwards || anchor.column !== 0)
        this.setSelectionAnchor(anchor.row, anchor.column + columns);

      if (isBackwards || lead.column !== 0) {
        this.$moveSelection(function() {
          this.moveCursorTo(lead.row, lead.column + columns);
        });
      }
    };
    this.isBackwards = function() {
      var anchor = this.anchor;
      var lead = this.lead;
      return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };
    this.getRange = function() {
      var anchor = this.anchor;
      var lead = this.lead;

      if (this.isEmpty())
        return Range.fromPoints(lead, lead);

      if (this.isBackwards()) {
        return Range.fromPoints(lead, anchor);
      }
      else {
        return Range.fromPoints(anchor, lead);
      }
    };
    this.clearSelection = function() {
      if (!this.$isEmpty) {
        this.$isEmpty = true;
        this._emit("changeSelection");
      }
    };
    this.selectAll = function() {
      var lastRow = this.doc.getLength() - 1;
      this.setSelectionAnchor(0, 0);
      this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
    };
    this.setRange =
      this.setSelectionRange = function(range, reverse) {
        if (reverse) {
          this.setSelectionAnchor(range.end.row, range.end.column);
          this.selectTo(range.start.row, range.start.column);
        } else {
          this.setSelectionAnchor(range.start.row, range.start.column);
          this.selectTo(range.end.row, range.end.column);
        }
        if (this.getRange().isEmpty())
          this.$isEmpty = true;
        this.$desiredColumn = null;
      };

    this.$moveSelection = function(mover) {
      var lead = this.lead;
      if (this.$isEmpty)
        this.setSelectionAnchor(lead.row, lead.column);

      mover.call(this);
    };
    this.selectTo = function(row, column) {
      this.$moveSelection(function() {
        this.moveCursorTo(row, column);
      });
    };
    this.selectToPosition = function(pos) {
      this.$moveSelection(function() {
        this.moveCursorToPosition(pos);
      });
    };
    this.moveTo = function(row, column) {
      this.clearSelection();
      this.moveCursorTo(row, column);
    };
    this.moveToPosition = function(pos) {
      this.clearSelection();
      this.moveCursorToPosition(pos);
    };
    this.selectUp = function() {
      this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function() {
      this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function() {
      this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function() {
      this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function() {
      this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function() {
      this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function() {
      this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function() {
      this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function() {
      this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function() {
      this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function(row, column) {
      if (typeof column == "undefined") {
        var cursor = row || this.lead;
        row = cursor.row;
        column = cursor.column;
      }
      return this.session.getWordRange(row, column);
    };
    this.selectWord = function() {
      this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function() {
      var cursor = this.getCursor();
      var range = this.session.getAWordRange(cursor.row, cursor.column);
      this.setSelectionRange(range);
    };

    this.getLineRange = function(row, excludeLastChar) {
      var rowStart = typeof row == "number" ? row : this.lead.row;
      var rowEnd;

      var foldLine = this.session.getFoldLine(rowStart);
      if (foldLine) {
        rowStart = foldLine.start.row;
        rowEnd = foldLine.end.row;
      } else {
        rowEnd = rowStart;
      }
      if (excludeLastChar === true)
        return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
      else
        return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function() {
      this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function() {
      this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function() {
      this.moveCursorBy(1, 0);
    };
    this.moveCursorLeft = function() {
      var cursor = this.lead.getPosition(),
        fold;

      if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
        this.moveCursorTo(fold.start.row, fold.start.column);
      } else if (cursor.column === 0) {
        if (cursor.row > 0) {
          this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
        }
      }
      else {
        var tabSize = this.session.getTabSize();
        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
          this.moveCursorBy(0, -tabSize);
        else
          this.moveCursorBy(0, -1);
      }
    };
    this.moveCursorRight = function() {
      var cursor = this.lead.getPosition(),
        fold;
      if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
        this.moveCursorTo(fold.end.row, fold.end.column);
      }
      else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
        if (this.lead.row < this.doc.getLength() - 1) {
          this.moveCursorTo(this.lead.row + 1, 0);
        }
      }
      else {
        var tabSize = this.session.getTabSize();
        var cursor = this.lead;
        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
          this.moveCursorBy(0, tabSize);
        else
          this.moveCursorBy(0, 1);
      }
    };
    this.moveCursorLineStart = function() {
      var row = this.lead.row;
      var column = this.lead.column;
      var screenRow = this.session.documentToScreenRow(row, column);
      var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
      var beforeCursor = this.session.getDisplayLine(
        row, null, firstColumnPosition.row,
        firstColumnPosition.column
      );

      var leadingSpace = beforeCursor.match(/^\s*/);
      if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
        firstColumnPosition.column += leadingSpace[0].length;
      this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function() {
      var lead = this.lead;
      var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
      if (this.lead.column == lineEnd.column) {
        var line = this.session.getLine(lineEnd.row);
        if (lineEnd.column == line.length) {
          var textEnd = line.search(/\s+$/);
          if (textEnd > 0)
            lineEnd.column = textEnd;
        }
      }

      this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function() {
      var row = this.doc.getLength() - 1;
      var column = this.doc.getLine(row).length;
      this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function() {
      this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function() {
      var row = this.lead.row;
      var column = this.lead.column;
      var line = this.doc.getLine(row);
      var rightOfCursor = line.substring(column);

      var match;
      this.session.nonTokenRe.lastIndex = 0;
      this.session.tokenRe.lastIndex = 0;
      var fold = this.session.getFoldAt(row, column, 1);
      if (fold) {
        this.moveCursorTo(fold.end.row, fold.end.column);
        return;
      }
      if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
        column += this.session.nonTokenRe.lastIndex;
        this.session.nonTokenRe.lastIndex = 0;
        rightOfCursor = line.substring(column);
      }
      if (column >= line.length) {
        this.moveCursorTo(row, line.length);
        this.moveCursorRight();
        if (row < this.doc.getLength() - 1)
          this.moveCursorWordRight();
        return;
      }
      if (match = this.session.tokenRe.exec(rightOfCursor)) {
        column += this.session.tokenRe.lastIndex;
        this.session.tokenRe.lastIndex = 0;
      }

      this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function() {
      var row = this.lead.row;
      var column = this.lead.column;
      var fold;
      if (fold = this.session.getFoldAt(row, column, -1)) {
        this.moveCursorTo(fold.start.row, fold.start.column);
        return;
      }

      var str = this.session.getFoldStringAt(row, column, -1);
      if (str == null) {
        str = this.doc.getLine(row).substring(0, column);
      }

      var leftOfCursor = lang.stringReverse(str);
      var match;
      this.session.nonTokenRe.lastIndex = 0;
      this.session.tokenRe.lastIndex = 0;
      if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
        column -= this.session.nonTokenRe.lastIndex;
        leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
        this.session.nonTokenRe.lastIndex = 0;
      }
      if (column <= 0) {
        this.moveCursorTo(row, 0);
        this.moveCursorLeft();
        if (row > 0)
          this.moveCursorWordLeft();
        return;
      }
      if (match = this.session.tokenRe.exec(leftOfCursor)) {
        column -= this.session.tokenRe.lastIndex;
        this.session.tokenRe.lastIndex = 0;
      }

      this.moveCursorTo(row, column);
    };

    this.$shortWordEndIndex = function(rightOfCursor) {
      var match, index = 0, ch;
      var whitespaceRe = /\s/;
      var tokenRe = this.session.tokenRe;

      tokenRe.lastIndex = 0;
      if (match = this.session.tokenRe.exec(rightOfCursor)) {
        index = this.session.tokenRe.lastIndex;
      } else {
        while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
          index ++;

        if (index < 1) {
          tokenRe.lastIndex = 0;
          while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
            tokenRe.lastIndex = 0;
            index ++;
            if (whitespaceRe.test(ch)) {
              if (index > 2) {
                index--;
                break;
              } else {
                while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                  index ++;
                if (index > 2)
                  break;
              }
            }
          }
        }
      }
      tokenRe.lastIndex = 0;

      return index;
    };

    this.moveCursorShortWordRight = function() {
      var row = this.lead.row;
      var column = this.lead.column;
      var line = this.doc.getLine(row);
      var rightOfCursor = line.substring(column);

      var fold = this.session.getFoldAt(row, column, 1);
      if (fold)
        return this.moveCursorTo(fold.end.row, fold.end.column);

      if (column == line.length) {
        var l = this.doc.getLength();
        do {
          row++;
          rightOfCursor = this.doc.getLine(row);
        } while (row < l && /^\s*$/.test(rightOfCursor));

        if (!/^\s+/.test(rightOfCursor))
          rightOfCursor = "";
        column = 0;
      }

      var index = this.$shortWordEndIndex(rightOfCursor);

      this.moveCursorTo(row, column + index);
    };

    this.moveCursorShortWordLeft = function() {
      var row = this.lead.row;
      var column = this.lead.column;

      var fold;
      if (fold = this.session.getFoldAt(row, column, -1))
        return this.moveCursorTo(fold.start.row, fold.start.column);

      var line = this.session.getLine(row).substring(0, column);
      if (column === 0) {
        do {
          row--;
          line = this.doc.getLine(row);
        } while (row > 0 && /^\s*$/.test(line));

        column = line.length;
        if (!/\s+$/.test(line))
          line = "";
      }

      var leftOfCursor = lang.stringReverse(line);
      var index = this.$shortWordEndIndex(leftOfCursor);

      return this.moveCursorTo(row, column - index);
    };

    this.moveCursorWordRight = function() {
      if (this.session.$selectLongWords)
        this.moveCursorLongWordRight();
      else
        this.moveCursorShortWordRight();
    };

    this.moveCursorWordLeft = function() {
      if (this.session.$selectLongWords)
        this.moveCursorLongWordLeft();
      else
        this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function(rows, chars) {
      var screenPos = this.session.documentToScreenPosition(
        this.lead.row,
        this.lead.column
      );

      if (chars === 0) {
        if (this.$desiredColumn)
          screenPos.column = this.$desiredColumn;
        else
          this.$desiredColumn = screenPos.column;
      }

      var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);

      if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
        if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
          if (docPos.row > 0 || rows > 0)
            docPos.row++;
        }
      }
      this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function(position) {
      this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function(row, column, keepDesiredColumn) {
      var fold = this.session.getFoldAt(row, column, 1);
      if (fold) {
        row = fold.start.row;
        column = fold.start.column;
      }

      this.$keepDesiredColumnOnChange = true;
      this.lead.setPosition(row, column);
      this.$keepDesiredColumnOnChange = false;

      if (!keepDesiredColumn)
        this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
      var pos = this.session.screenToDocumentPosition(row, column);
      this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function() {
      this.lead.detach();
      this.anchor.detach();
      this.session = this.doc = null;
    };

    this.fromOrientedRange = function(range) {
      this.setSelectionRange(range, range.cursor == range.start);
      this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };

    this.toOrientedRange = function(range) {
      var r = this.getRange();
      if (range) {
        range.start.column = r.start.column;
        range.start.row = r.start.row;
        range.end.column = r.end.column;
        range.end.row = r.end.row;
      } else {
        range = r;
      }

      range.cursor = this.isBackwards() ? range.start : range.end;
      range.desiredColumn = this.$desiredColumn;
      return range;
    };
    this.getRangeOfMovements = function(func) {
      var start = this.getCursor();
      try {
        func(this);
        var end = this.getCursor();
        return Range.fromPoints(start,end);
      } catch(e) {
        return Range.fromPoints(start,start);
      } finally {
        this.moveCursorToPosition(start);
      }
    };

    this.toJSON = function() {
      if (this.rangeCount) {
        var data = this.ranges.map(function(r) {
          var r1 = r.clone();
          r1.isBackwards = r.cursor == r.start;
          return r1;
        });
      } else {
        var data = this.getRange();
        data.isBackwards = this.isBackwards();
      }
      return data;
    };

    this.fromJSON = function(data) {
      if (data.start == undefined) {
        if (this.rangeList) {
          this.toSingleRange(data[0]);
          for (var i = data.length; i--; ) {
            var r = Range.fromPoints(data[i].start, data[i].end);
            if (data[i].isBackwards)
              r.cursor = r.start;
            this.addRange(r, true);
          }
          return;
        } else
          data = data[0];
      }
      if (this.rangeList)
        this.toSingleRange(data);
      this.setSelectionRange(data, data.isBackwards);
    };

    this.isEqual = function(data) {
      if ((data.length || this.rangeCount) && data.length != this.rangeCount)
        return false;
      if (!data.length || !this.ranges)
        return this.getRange().isEqual(data);

      for (var i = this.ranges.length; i--; ) {
        if (!this.ranges[i].isEqual(data[i]))
          return false;
      }
      return true;
    };

  }).call(Selection.prototype);

  exports.Selection = Selection;
});

ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(require, exports, module) {
  "use strict";

  var config = require("./config");
  var MAX_TOKEN_COUNT = 2000;
  var Tokenizer = function(rules) {
    this.states = rules;

    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
      var state = this.states[key];
      var ruleRegExps = [];
      var matchTotal = 0;
      var mapping = this.matchMappings[key] = {defaultToken: "text"};
      var flag = "g";

      var splitterRurles = [];
      for (var i = 0; i < state.length; i++) {
        var rule = state[i];
        if (rule.defaultToken)
          mapping.defaultToken = rule.defaultToken;
        if (rule.caseInsensitive)
          flag = "gi";
        if (rule.regex == null)
          continue;

        if (rule.regex instanceof RegExp)
          rule.regex = rule.regex.toString().slice(1, -1);
        var adjustedregex = rule.regex;
        var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
        if (Array.isArray(rule.token)) {
          if (rule.token.length == 1 || matchcount == 1) {
            rule.token = rule.token[0];
          } else if (matchcount - 1 != rule.token.length) {
            this.reportError("number of classes and regexp groups doesn't match", {
              rule: rule,
              groupCount: matchcount - 1
            });
            rule.token = rule.token[0];
          } else {
            rule.tokenArray = rule.token;
            rule.token = null;
            rule.onMatch = this.$arrayTokens;
          }
        } else if (typeof rule.token == "function" && !rule.onMatch) {
          if (matchcount > 1)
            rule.onMatch = this.$applyToken;
          else
            rule.onMatch = rule.token;
        }

        if (matchcount > 1) {
          if (/\\\d/.test(rule.regex)) {
            adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
              return "\\" + (parseInt(digit, 10) + matchTotal + 1);
            });
          } else {
            matchcount = 1;
            adjustedregex = this.removeCapturingGroups(rule.regex);
          }
          if (!rule.splitRegex && typeof rule.token != "string")
            splitterRurles.push(rule); // flag will be known only at the very end
        }

        mapping[matchTotal] = i;
        matchTotal += matchcount;

        ruleRegExps.push(adjustedregex);
        if (!rule.onMatch)
          rule.onMatch = null;
      }

      if (!ruleRegExps.length) {
        mapping[0] = 0;
        ruleRegExps.push("$");
      }

      splitterRurles.forEach(function(rule) {
        rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
      }, this);

      this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
    }
  };

  (function() {
    this.$setMaxTokenCount = function(m) {
      MAX_TOKEN_COUNT = m | 0;
    };

    this.$applyToken = function(str) {
      var values = this.splitRegex.exec(str).slice(1);
      var types = this.token.apply(this, values);
      if (typeof types === "string")
        return [{type: types, value: str}];

      var tokens = [];
      for (var i = 0, l = types.length; i < l; i++) {
        if (values[i])
          tokens[tokens.length] = {
            type: types[i],
            value: values[i]
          };
      }
      return tokens;
    };

    this.$arrayTokens = function(str) {
      if (!str)
        return [];
      var values = this.splitRegex.exec(str);
      if (!values)
        return "text";
      var tokens = [];
      var types = this.tokenArray;
      for (var i = 0, l = types.length; i < l; i++) {
        if (values[i + 1])
          tokens[tokens.length] = {
            type: types[i],
            value: values[i + 1]
          };
      }
      return tokens;
    };

    this.removeCapturingGroups = function(src) {
      var r = src.replace(
        /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
        function(x, y) {return y ? "(?:" : x;}
      );
      return r;
    };

    this.createSplitterRegexp = function(src, flag) {
      if (src.indexOf("(?=") != -1) {
        var stack = 0;
        var inChClass = false;
        var lastCapture = {};
        src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
          m, esc, parenOpen, parenClose, square, index
        ) {
          if (inChClass) {
            inChClass = square != "]";
          } else if (square) {
            inChClass = true;
          } else if (parenClose) {
            if (stack == lastCapture.stack) {
              lastCapture.end = index+1;
              lastCapture.stack = -1;
            }
            stack--;
          } else if (parenOpen) {
            stack++;
            if (parenOpen.length != 1) {
              lastCapture.stack = stack
              lastCapture.start = index;
            }
          }
          return m;
        });

        if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
          src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
      }
      if (src.charAt(0) != "^") src = "^" + src;
      if (src.charAt(src.length - 1) != "$") src += "$";

      return new RegExp(src, (flag||"").replace("g", ""));
    };
    this.getLineTokens = function(line, startState) {
      if (startState && typeof startState != "string") {
        var stack = startState.slice(0);
        startState = stack[0];
        if (startState === "#tmp") {
          stack.shift()
          startState = stack.shift()
        }
      } else
        var stack = [];

      var currentState = startState || "start";
      var state = this.states[currentState];
      if (!state) {
        currentState = "start";
        state = this.states[currentState];
      }
      var mapping = this.matchMappings[currentState];
      var re = this.regExps[currentState];
      re.lastIndex = 0;

      var match, tokens = [];
      var lastIndex = 0;
      var matchAttempts = 0;

      var token = {type: null, value: ""};

      while (match = re.exec(line)) {
        var type = mapping.defaultToken;
        var rule = null;
        var value = match[0];
        var index = re.lastIndex;

        if (index - value.length > lastIndex) {
          var skipped = line.substring(lastIndex, index - value.length);
          if (token.type == type) {
            token.value += skipped;
          } else {
            if (token.type)
              tokens.push(token);
            token = {type: type, value: skipped};
          }
        }

        for (var i = 0; i < match.length-2; i++) {
          if (match[i + 1] === undefined)
            continue;

          rule = state[mapping[i]];

          if (rule.onMatch)
            type = rule.onMatch(value, currentState, stack);
          else
            type = rule.token;

          if (rule.next) {
            if (typeof rule.next == "string") {
              currentState = rule.next;
            } else {
              currentState = rule.next(currentState, stack);
            }

            state = this.states[currentState];
            if (!state) {
              this.reportError("state doesn't exist", currentState);
              currentState = "start";
              state = this.states[currentState];
            }
            mapping = this.matchMappings[currentState];
            lastIndex = index;
            re = this.regExps[currentState];
            re.lastIndex = index;
          }
          break;
        }

        if (value) {
          if (typeof type === "string") {
            if ((!rule || rule.merge !== false) && token.type === type) {
              token.value += value;
            } else {
              if (token.type)
                tokens.push(token);
              token = {type: type, value: value};
            }
          } else if (type) {
            if (token.type)
              tokens.push(token);
            token = {type: null, value: ""};
            for (var i = 0; i < type.length; i++)
              tokens.push(type[i]);
          }
        }

        if (lastIndex == line.length)
          break;

        lastIndex = index;

        if (matchAttempts++ > MAX_TOKEN_COUNT) {
          if (matchAttempts > 2 * line.length) {
            this.reportError("infinite loop with in ace tokenizer", {
              startState: startState,
              line: line
            });
          }
          while (lastIndex < line.length) {
            if (token.type)
              tokens.push(token);
            token = {
              value: line.substring(lastIndex, lastIndex += 2000),
              type: "overflow"
            };
          }
          currentState = "start";
          stack = [];
          break;
        }
      }

      if (token.type)
        tokens.push(token);

      if (stack.length > 1) {
        if (stack[0] !== currentState)
          stack.unshift("#tmp", currentState);
      }
      return {
        tokens : tokens,
        state : stack.length ? stack : currentState
      };
    };

    this.reportError = config.reportError;

  }).call(Tokenizer.prototype);

  exports.Tokenizer = Tokenizer;
});

ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(require, exports, module) {
  "use strict";

  var lang = require("../lib/lang");

  var TextHighlightRules = function() {

    this.$rules = {
      "start" : [{
        token : "empty_line",
        regex : '^$'
      }, {
        defaultToken : "text"
      }]
    };
  };

  (function() {

    this.addRules = function(rules, prefix) {
      if (!prefix) {
        for (var key in rules)
          this.$rules[key] = rules[key];
        return;
      }
      for (var key in rules) {
        var state = rules[key];
        for (var i = 0; i < state.length; i++) {
          var rule = state[i];
          if (rule.next || rule.onMatch) {
            if (typeof rule.next == "string") {
              if (rule.next.indexOf(prefix) !== 0)
                rule.next = prefix + rule.next;
            }
            if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
              rule.nextState = prefix + rule.nextState;
          }
        }
        this.$rules[prefix + key] = state;
      }
    };

    this.getRules = function() {
      return this.$rules;
    };

    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
      var embedRules = typeof HighlightRules == "function"
        ? new HighlightRules().getRules()
        : HighlightRules;
      if (states) {
        for (var i = 0; i < states.length; i++)
          states[i] = prefix + states[i];
      } else {
        states = [];
        for (var key in embedRules)
          states.push(prefix + key);
      }

      this.addRules(embedRules, prefix);

      if (escapeRules) {
        var addRules = Array.prototype[append ? "push" : "unshift"];
        for (var i = 0; i < states.length; i++)
          addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
      }

      if (!this.$embeds)
        this.$embeds = [];
      this.$embeds.push(prefix);
    };

    this.getEmbeds = function() {
      return this.$embeds;
    };

    var pushState = function(currentState, stack) {
      if (currentState != "start" || stack.length)
        stack.unshift(this.nextState, currentState);
      return this.nextState;
    };
    var popState = function(currentState, stack) {
      stack.shift();
      return stack.shift() || "start";
    };

    this.normalizeRules = function() {
      var id = 0;
      var rules = this.$rules;
      function processState(key) {
        var state = rules[key];
        state.processed = true;
        for (var i = 0; i < state.length; i++) {
          var rule = state[i];
          var toInsert = null;
          if (Array.isArray(rule)) {
            toInsert = rule;
            rule = {};
          }
          if (!rule.regex && rule.start) {
            rule.regex = rule.start;
            if (!rule.next)
              rule.next = [];
            rule.next.push({
              defaultToken: rule.token
            }, {
              token: rule.token + ".end",
              regex: rule.end || rule.start,
              next: "pop"
            });
            rule.token = rule.token + ".start";
            rule.push = true;
          }
          var next = rule.next || rule.push;
          if (next && Array.isArray(next)) {
            var stateName = rule.stateName;
            if (!stateName)  {
              stateName = rule.token;
              if (typeof stateName != "string")
                stateName = stateName[0] || "";
              if (rules[stateName])
                stateName += id++;
            }
            rules[stateName] = next;
            rule.next = stateName;
            processState(stateName);
          } else if (next == "pop") {
            rule.next = popState;
          }

          if (rule.push) {
            rule.nextState = rule.next || rule.push;
            rule.next = pushState;
            delete rule.push;
          }

          if (rule.rules) {
            for (var r in rule.rules) {
              if (rules[r]) {
                if (rules[r].push)
                  rules[r].push.apply(rules[r], rule.rules[r]);
              } else {
                rules[r] = rule.rules[r];
              }
            }
          }
          var includeName = typeof rule == "string"
            ? rule
            : typeof rule.include == "string"
              ? rule.include
              : "";
          if (includeName) {
            toInsert = rules[includeName];
          }

          if (toInsert) {
            var args = [i, 1].concat(toInsert);
            if (rule.noEscape)
              args = args.filter(function(x) {return !x.next;});
            state.splice.apply(state, args);
            i--;
          }

          if (rule.keywordMap) {
            rule.token = this.createKeywordMapper(
              rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
            );
            delete rule.defaultToken;
          }
        }
      }
      Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
      var keywords = Object.create(null);
      Object.keys(map).forEach(function(className) {
        var a = map[className];
        if (ignoreCase)
          a = a.toLowerCase();
        var list = a.split(splitChar || "|");
        for (var i = list.length; i--; )
          keywords[list[i]] = className;
      });
      if (Object.getPrototypeOf(keywords)) {
        keywords.__proto__ = null;
      }
      this.$keywordList = Object.keys(keywords);
      map = null;
      return ignoreCase
        ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
        : function(value) {return keywords[value] || defaultToken };
    };

    this.getKeywords = function() {
      return this.$keywords;
    };

  }).call(TextHighlightRules.prototype);

  exports.TextHighlightRules = TextHighlightRules;
});

ace.define("ace/mode/behaviour",["require","exports","module"], function(require, exports, module) {
  "use strict";

  var Behaviour = function() {
    this.$behaviours = {};
  };

  (function () {

    this.add = function (name, action, callback) {
      switch (undefined) {
        case this.$behaviours:
          this.$behaviours = {};
        case this.$behaviours[name]:
          this.$behaviours[name] = {};
      }
      this.$behaviours[name][action] = callback;
    }

    this.addBehaviours = function (behaviours) {
      for (var key in behaviours) {
        for (var action in behaviours[key]) {
          this.add(key, action, behaviours[key][action]);
        }
      }
    }

    this.remove = function (name) {
      if (this.$behaviours && this.$behaviours[name]) {
        delete this.$behaviours[name];
      }
    }

    this.inherit = function (mode, filter) {
      if (typeof mode === "function") {
        var behaviours = new mode().getBehaviours(filter);
      } else {
        var behaviours = mode.getBehaviours(filter);
      }
      this.addBehaviours(behaviours);
    }

    this.getBehaviours = function (filter) {
      if (!filter) {
        return this.$behaviours;
      } else {
        var ret = {}
        for (var i = 0; i < filter.length; i++) {
          if (this.$behaviours[filter[i]]) {
            ret[filter[i]] = this.$behaviours[filter[i]];
          }
        }
        return ret;
      }
    }

  }).call(Behaviour.prototype);

  exports.Behaviour = Behaviour;
});

ace.define("ace/token_iterator",["require","exports","module"], function(require, exports, module) {
  "use strict";
  var TokenIterator = function(session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);

    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
  };

  (function() {
    this.stepBackward = function() {
      this.$tokenIndex -= 1;

      while (this.$tokenIndex < 0) {
        this.$row -= 1;
        if (this.$row < 0) {
          this.$row = 0;
          return null;
        }

        this.$rowTokens = this.$session.getTokens(this.$row);
        this.$tokenIndex = this.$rowTokens.length - 1;
      }

      return this.$rowTokens[this.$tokenIndex];
    };
    this.stepForward = function() {
      this.$tokenIndex += 1;
      var rowCount;
      while (this.$tokenIndex >= this.$rowTokens.length) {
        this.$row += 1;
        if (!rowCount)
          rowCount = this.$session.getLength();
        if (this.$row >= rowCount) {
          this.$row = rowCount - 1;
          return null;
        }

        this.$rowTokens = this.$session.getTokens(this.$row);
        this.$tokenIndex = 0;
      }

      return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentToken = function () {
      return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentTokenRow = function () {
      return this.$row;
    };
    this.getCurrentTokenColumn = function() {
      var rowTokens = this.$rowTokens;
      var tokenIndex = this.$tokenIndex;
      var column = rowTokens[tokenIndex].start;
      if (column !== undefined)
        return column;

      column = 0;
      while (tokenIndex > 0) {
        tokenIndex -= 1;
        column += rowTokens[tokenIndex].value.length;
      }

      return column;
    };
    this.getCurrentTokenPosition = function() {
      return {row: this.$row, column: this.getCurrentTokenColumn()};
    };

  }).call(TokenIterator.prototype);

  exports.TokenIterator = TokenIterator;
});

ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module) {
  "use strict";

  var oop = require("../../lib/oop");
  var Behaviour = require("../behaviour").Behaviour;
  var TokenIterator = require("../../token_iterator").TokenIterator;
  var lang = require("../../lib/lang");

  var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "punctuation.operator"];
  var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "punctuation.operator", "comment"];

  var context;
  var contextCache = {};
  var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
      id = editor.selection.index;
      if (contextCache.rangeCount != editor.multiSelect.rangeCount)
        contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
      return context = contextCache[id];
    context = contextCache[id] = {
      autoInsertedBrackets: 0,
      autoInsertedRow: -1,
      autoInsertedLineEnd: "",
      maybeInsertedBrackets: 0,
      maybeInsertedRow: -1,
      maybeInsertedLineStart: "",
      maybeInsertedLineEnd: ""
    };
  };

  var getWrapped = function(selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
      text: opening + selected + closing,
      selection: [
        0,
        selection.start.column + 1,
        rowDiff,
        selection.end.column + (rowDiff ? 0 : 1)
      ]
    };
  };

  var CstyleBehaviour = function() {
    this.add("braces", "insertion", function(state, action, editor, session, text) {
      var cursor = editor.getCursorPosition();
      var line = session.doc.getLine(cursor.row);
      if (text == '{') {
        initContext(editor);
        var selection = editor.getSelectionRange();
        var selected = session.doc.getTextRange(selection);
        if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
          return getWrapped(selection, selected, '{', '}');
        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
          if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
            CstyleBehaviour.recordAutoInsert(editor, session, "}");
            return {
              text: '{}',
              selection: [1, 1]
            };
          } else {
            CstyleBehaviour.recordMaybeInsert(editor, session, "{");
            return {
              text: '{',
              selection: [1, 1]
            };
          }
        }
      } else if (text == '}') {
        initContext(editor);
        var rightChar = line.substring(cursor.column, cursor.column + 1);
        if (rightChar == '}') {
          var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
          if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
            CstyleBehaviour.popAutoInsertedClosing();
            return {
              text: '',
              selection: [1, 1]
            };
          }
        }
      } else if (text == "\n" || text == "\r\n") {
        initContext(editor);
        var closing = "";
        if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
          closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
          CstyleBehaviour.clearMaybeInsertedClosing();
        }
        var rightChar = line.substring(cursor.column, cursor.column + 1);
        if (rightChar === '}') {
          var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
          if (!openBracePos)
            return null;
          var next_indent = this.$getIndent(session.getLine(openBracePos.row));
        } else if (closing) {
          var next_indent = this.$getIndent(line);
        } else {
          CstyleBehaviour.clearMaybeInsertedClosing();
          return;
        }
        var indent = next_indent + session.getTabString();

        return {
          text: '\n' + indent + '\n' + next_indent + closing,
          selection: [1, indent.length, 1, indent.length]
        };
      } else {
        CstyleBehaviour.clearMaybeInsertedClosing();
      }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
      var selected = session.doc.getTextRange(range);
      if (!range.isMultiLine() && selected == '{') {
        initContext(editor);
        var line = session.doc.getLine(range.start.row);
        var rightChar = line.substring(range.end.column, range.end.column + 1);
        if (rightChar == '}') {
          range.end.column++;
          return range;
        } else {
          context.maybeInsertedBrackets--;
        }
      }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
      if (text == '(') {
        initContext(editor);
        var selection = editor.getSelectionRange();
        var selected = session.doc.getTextRange(selection);
        if (selected !== "" && editor.getWrapBehavioursEnabled()) {
          return getWrapped(selection, selected, '(', ')');
        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
          CstyleBehaviour.recordAutoInsert(editor, session, ")");
          return {
            text: '()',
            selection: [1, 1]
          };
        }
      } else if (text == ')') {
        initContext(editor);
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        var rightChar = line.substring(cursor.column, cursor.column + 1);
        if (rightChar == ')') {
          var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
          if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
            CstyleBehaviour.popAutoInsertedClosing();
            return {
              text: '',
              selection: [1, 1]
            };
          }
        }
      }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
      var selected = session.doc.getTextRange(range);
      if (!range.isMultiLine() && selected == '(') {
        initContext(editor);
        var line = session.doc.getLine(range.start.row);
        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
        if (rightChar == ')') {
          range.end.column++;
          return range;
        }
      }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
      if (text == '[') {
        initContext(editor);
        var selection = editor.getSelectionRange();
        var selected = session.doc.getTextRange(selection);
        if (selected !== "" && editor.getWrapBehavioursEnabled()) {
          return getWrapped(selection, selected, '[', ']');
        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
          CstyleBehaviour.recordAutoInsert(editor, session, "]");
          return {
            text: '[]',
            selection: [1, 1]
          };
        }
      } else if (text == ']') {
        initContext(editor);
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        var rightChar = line.substring(cursor.column, cursor.column + 1);
        if (rightChar == ']') {
          var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
          if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
            CstyleBehaviour.popAutoInsertedClosing();
            return {
              text: '',
              selection: [1, 1]
            };
          }
        }
      }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
      var selected = session.doc.getTextRange(range);
      if (!range.isMultiLine() && selected == '[') {
        initContext(editor);
        var line = session.doc.getLine(range.start.row);
        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
        if (rightChar == ']') {
          range.end.column++;
          return range;
        }
      }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
      if (text == '"' || text == "'") {
        if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
          return;
        initContext(editor);
        var quote = text;
        var selection = editor.getSelectionRange();
        var selected = session.doc.getTextRange(selection);
        if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
          return getWrapped(selection, selected, quote, quote);
        } else if (!selected) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var leftChar = line.substring(cursor.column-1, cursor.column);
          var rightChar = line.substring(cursor.column, cursor.column + 1);

          var token = session.getTokenAt(cursor.row, cursor.column);
          var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
          if (leftChar == "\\" && token && /escape/.test(token.type))
            return null;

          var stringBefore = token && /string|escape/.test(token.type);
          var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

          var pair;
          if (rightChar == quote) {
            pair = stringBefore !== stringAfter;
            if (pair && /string\.end/.test(rightToken.type))
              pair = false;
          } else {
            if (stringBefore && !stringAfter)
              return null; // wrap string with different quote
            if (stringBefore && stringAfter)
              return null; // do not pair quotes inside strings
            var wordRe = session.$mode.tokenRe;
            wordRe.lastIndex = 0;
            var isWordBefore = wordRe.test(leftChar);
            wordRe.lastIndex = 0;
            var isWordAfter = wordRe.test(leftChar);
            if (isWordBefore || isWordAfter)
              return null; // before or after alphanumeric
            if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
              return null; // there is rightChar and it isn't closing
            pair = true;
          }
          return {
            text: pair ? quote + quote : "",
            selection: [1,1]
          };
        }
      }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
      var selected = session.doc.getTextRange(range);
      if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
        initContext(editor);
        var line = session.doc.getLine(range.start.row);
        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
        if (rightChar == selected) {
          range.end.column++;
          return range;
        }
      }
    });

  };


  CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
      var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
      if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
        return false;
    }
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
      this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
  };

  CstyleBehaviour.$matchTokenType = function(token, types) {
    return types.indexOf(token.type || token) > -1;
  };

  CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
      context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
  };

  CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
      context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
  };

  CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
      cursor.row === context.autoInsertedRow &&
      bracket === context.autoInsertedLineEnd[0] &&
      line.substr(cursor.column) === context.autoInsertedLineEnd;
  };

  CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
      cursor.row === context.maybeInsertedRow &&
      line.substr(cursor.column) === context.maybeInsertedLineEnd &&
      line.substr(0, cursor.column) == context.maybeInsertedLineStart;
  };

  CstyleBehaviour.popAutoInsertedClosing = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
  };

  CstyleBehaviour.clearMaybeInsertedClosing = function() {
    if (context) {
      context.maybeInsertedBrackets = 0;
      context.maybeInsertedRow = -1;
    }
  };



  oop.inherits(CstyleBehaviour, Behaviour);

  exports.CstyleBehaviour = CstyleBehaviour;
});

ace.define("ace/unicode",["require","exports","module"], function(require, exports, module) {
  "use strict";
  exports.packages = {};

  addUnicodePackage({
    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
    Z:  "002000A01680180E2000-200A20282029202F205F3000",
    Zs: "002000A01680180E2000-200A202F205F3000",
    Zl: "2028",
    Zp: "2029",
    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
    Cc: "0000-001F007F-009F",
    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
    Co: "E000-F8FF",
    Cs: "D800-DFFF",
    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
  });

  function addUnicodePackage (pack) {
    var codePoint = /\w{4}/g;
    for (var name in pack)
      exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
  }

});

ace.define("ace/mode/text",["require","exports","module","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(require, exports, module) {
  "use strict";

  var Tokenizer = require("../tokenizer").Tokenizer;
  var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
  var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
  var unicode = require("../unicode");
  var lang = require("../lib/lang");
  var TokenIterator = require("../token_iterator").TokenIterator;
  var Range = require("../range").Range;

  var Mode = function() {
    this.HighlightRules = TextHighlightRules;
  };

  (function() {
    this.$defaultBehaviour = new CstyleBehaviour();

    this.tokenRe = new RegExp("^["
      + unicode.packages.L
      + unicode.packages.Mn + unicode.packages.Mc
      + unicode.packages.Nd
      + unicode.packages.Pc + "\\$_]+", "g"
    );

    this.nonTokenRe = new RegExp("^(?:[^"
      + unicode.packages.L
      + unicode.packages.Mn + unicode.packages.Mc
      + unicode.packages.Nd
      + unicode.packages.Pc + "\\$_]|\\s])+", "g"
    );

    this.getTokenizer = function() {
      if (!this.$tokenizer) {
        this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
        this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
      }
      return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    this.toggleCommentLines = function(state, session, startRow, endRow) {
      var doc = session.doc;

      var ignoreBlankLines = true;
      var shouldRemove = true;
      var minIndent = Infinity;
      var tabSize = session.getTabSize();
      var insertAtTabStop = false;

      if (!this.lineCommentStart) {
        if (!this.blockComment)
          return false;
        var lineCommentStart = this.blockComment.start;
        var lineCommentEnd = this.blockComment.end;
        var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
        var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

        var comment = function(line, i) {
          if (testRemove(line, i))
            return;
          if (!ignoreBlankLines || /\S/.test(line)) {
            doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
            doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
          }
        };

        var uncomment = function(line, i) {
          var m;
          if (m = line.match(regexpEnd))
            doc.removeInLine(i, line.length - m[0].length, line.length);
          if (m = line.match(regexpStart))
            doc.removeInLine(i, m[1].length, m[0].length);
        };

        var testRemove = function(line, row) {
          if (regexpStart.test(line))
            return true;
          var tokens = session.getTokens(row);
          for (var i = 0; i < tokens.length; i++) {
            if (tokens[i].type === "comment")
              return true;
          }
        };
      } else {
        if (Array.isArray(this.lineCommentStart)) {
          var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
          var lineCommentStart = this.lineCommentStart[0];
        } else {
          var regexpStart = lang.escapeRegExp(this.lineCommentStart);
          var lineCommentStart = this.lineCommentStart;
        }
        regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");

        insertAtTabStop = session.getUseSoftTabs();

        var uncomment = function(line, i) {
          var m = line.match(regexpStart);
          if (!m) return;
          var start = m[1].length, end = m[0].length;
          if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
            end--;
          doc.removeInLine(i, start, end);
        };
        var commentWithSpace = lineCommentStart + " ";
        var comment = function(line, i) {
          if (!ignoreBlankLines || /\S/.test(line)) {
            if (shouldInsertSpace(line, minIndent, minIndent))
              doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
            else
              doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
          }
        };
        var testRemove = function(line, i) {
          return regexpStart.test(line);
        };

        var shouldInsertSpace = function(line, before, after) {
          var spaces = 0;
          while (before-- && line.charAt(before) == " ")
            spaces++;
          if (spaces % tabSize != 0)
            return false;
          var spaces = 0;
          while (line.charAt(after++) == " ")
            spaces++;
          if (tabSize > 2)
            return spaces % tabSize != tabSize - 1;
          else
            return spaces % tabSize == 0;
          return true;
        };
      }

      function iter(fun) {
        for (var i = startRow; i <= endRow; i++)
          fun(doc.getLine(i), i);
      }


      var minEmptyLength = Infinity;
      iter(function(line, i) {
        var indent = line.search(/\S/);
        if (indent !== -1) {
          if (indent < minIndent)
            minIndent = indent;
          if (shouldRemove && !testRemove(line, i))
            shouldRemove = false;
        } else if (minEmptyLength > line.length) {
          minEmptyLength = line.length;
        }
      });

      if (minIndent == Infinity) {
        minIndent = minEmptyLength;
        ignoreBlankLines = false;
        shouldRemove = false;
      }

      if (insertAtTabStop && minIndent % tabSize != 0)
        minIndent = Math.floor(minIndent / tabSize) * tabSize;

      iter(shouldRemove ? uncomment : comment);
    };

    this.toggleBlockComment = function(state, session, range, cursor) {
      var comment = this.blockComment;
      if (!comment)
        return;
      if (!comment.start && comment[0])
        comment = comment[0];

      var iterator = new TokenIterator(session, cursor.row, cursor.column);
      var token = iterator.getCurrentToken();

      var sel = session.selection;
      var initialRange = session.selection.toOrientedRange();
      var startRow, colDiff;

      if (token && /comment/.test(token.type)) {
        var startRange, endRange;
        while (token && /comment/.test(token.type)) {
          var i = token.value.indexOf(comment.start);
          if (i != -1) {
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn() + i;
            startRange = new Range(row, column, row, column + comment.start.length);
            break;
          }
          token = iterator.stepBackward();
        }

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();
        while (token && /comment/.test(token.type)) {
          var i = token.value.indexOf(comment.end);
          if (i != -1) {
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn() + i;
            endRange = new Range(row, column, row, column + comment.end.length);
            break;
          }
          token = iterator.stepForward();
        }
        if (endRange)
          session.remove(endRange);
        if (startRange) {
          session.remove(startRange);
          startRow = startRange.start.row;
          colDiff = -comment.start.length;
        }
      } else {
        colDiff = comment.start.length;
        startRow = range.start.row;
        session.insert(range.end, comment.end);
        session.insert(range.start, comment.start);
      }
      if (initialRange.start.row == startRow)
        initialRange.start.column += colDiff;
      if (initialRange.end.row == startRow)
        initialRange.end.column += colDiff;
      session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
      return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
      return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
      return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
      return null;
    };

    this.createModeDelegates = function (mapping) {
      this.$embeds = [];
      this.$modes = {};
      for (var i in mapping) {
        if (mapping[i]) {
          this.$embeds.push(i);
          this.$modes[i] = new mapping[i]();
        }
      }

      var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent",
        "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

      for (var i = 0; i < delegations.length; i++) {
        (function(scope) {
          var functionName = delegations[i];
          var defaultHandler = scope[functionName];
          scope[delegations[i]] = function() {
            return this.$delegator(functionName, arguments, defaultHandler);
          };
        }(this));
      }
    };

    this.$delegator = function(method, args, defaultHandler) {
      var state = args[0];
      if (typeof state != "string")
        state = state[0];
      for (var i = 0; i < this.$embeds.length; i++) {
        if (!this.$modes[this.$embeds[i]]) continue;

        var split = state.split(this.$embeds[i]);
        if (!split[0] && split[1]) {
          args[0] = split[1];
          var mode = this.$modes[this.$embeds[i]];
          return mode[method].apply(mode, args);
        }
      }
      var ret = defaultHandler.apply(this, args);
      return defaultHandler ? ret : undefined;
    };

    this.transformAction = function(state, action, editor, session, param) {
      if (this.$behaviour) {
        var behaviours = this.$behaviour.getBehaviours();
        for (var key in behaviours) {
          if (behaviours[key][action]) {
            var ret = behaviours[key][action].apply(this, arguments);
            if (ret) {
              return ret;
            }
          }
        }
      }
    };

    this.getKeywords = function(append) {
      if (!this.completionKeywords) {
        var rules = this.$tokenizer.rules;
        var completionKeywords = [];
        for (var rule in rules) {
          var ruleItr = rules[rule];
          for (var r = 0, l = ruleItr.length; r < l; r++) {
            if (typeof ruleItr[r].token === "string") {
              if (/keyword|support|storage/.test(ruleItr[r].token))
                completionKeywords.push(ruleItr[r].regex);
            }
            else if (typeof ruleItr[r].token === "object") {
              for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                  var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                  completionKeywords.push(rule.substr(1, rule.length - 2));
                }
              }
            }
          }
        }
        this.completionKeywords = completionKeywords;
      }
      if (!append)
        return this.$keywordList;
      return completionKeywords.concat(this.$keywordList || []);
    };

    this.$createKeywordList = function() {
      if (!this.$highlightRules)
        this.getTokenizer();
      return this.$keywordList = this.$highlightRules.$keywordList || [];
    };

    this.getCompletions = function(state, session, pos, prefix) {
      var keywords = this.$keywordList || this.$createKeywordList();
      return keywords.map(function(word) {
        return {
          name: word,
          value: word,
          score: 0,
          meta: "keyword"
        };
      });
    };

    this.$id = "ace/mode/text";
  }).call(Mode.prototype);

  exports.Mode = Mode;
});

ace.define("ace/apply_delta",["require","exports","module"], function(require, exports, module) {
  "use strict";

  function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
  }

  function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
      position.column >= 0 && position.column <= docLines[position.row].length;
  }

  function validateDelta(docLines, delta) {
    if (delta.action != "insert" && delta.action != "remove")
      throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    if (!(delta.lines instanceof Array))
      throwDeltaError(delta, "delta.lines must be an Array");
    if (!delta.start || !delta.end)
      throwDeltaError(delta, "delta.start/end must be an present");
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
      throwDeltaError(delta, "delta.start must be contained in document");
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
      throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
      throwDeltaError(delta, "delta.range must match delta lines");
  }

  exports.applyDelta = function(docLines, delta, doNotValidate) {

    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
      case "insert":
        var lines = delta.lines;
        if (lines.length === 1) {
          docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
        } else {
          var args = [row, 1].concat(delta.lines);
          docLines.splice.apply(docLines, args);
          docLines[row] = line.substring(0, startColumn) + docLines[row];
          docLines[row + delta.lines.length - 1] += line.substring(startColumn);
        }
        break;
      case "remove":
        var endColumn = delta.end.column;
        var endRow = delta.end.row;
        if (row === endRow) {
          docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
        } else {
          docLines.splice(
            row, endRow - row + 1,
            line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
          );
        }
        break;
    }
  }
});

ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var EventEmitter = require("./lib/event_emitter").EventEmitter;

  var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);

    if (typeof column == "undefined")
      this.setPosition(row.row, row.column);
    else
      this.setPosition(row, column);
  };

  (function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
      return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
      return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(delta) {
      if (delta.start.row == delta.end.row && delta.start.row != this.row)
        return;

      if (delta.start.row > this.row)
        return;

      var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
      this.setPosition(point.row, point.column, true);
    };

    function $pointsInOrder(point1, point2, equalPointsInOrder) {
      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
      return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }

    function $getTransformedPoint(delta, point, moveIfEqual) {
      var deltaIsInsert = delta.action == "insert";
      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
      var deltaStart = delta.start;
      var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
      if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
        return {
          row: point.row,
          column: point.column
        };
      }
      if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
        return {
          row: point.row + deltaRowShift,
          column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
        };
      }

      return {
        row: deltaStart.row,
        column: deltaStart.column
      };
    }
    this.setPosition = function(row, column, noClip) {
      var pos;
      if (noClip) {
        pos = {
          row: row,
          column: column
        };
      } else {
        pos = this.$clipPositionToDocument(row, column);
      }

      if (this.row == pos.row && this.column == pos.column)
        return;

      var old = {
        row: this.row,
        column: this.column
      };

      this.row = pos.row;
      this.column = pos.column;
      this._signal("change", {
        old: old,
        value: pos
      });
    };
    this.detach = function() {
      this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
      this.document = doc || this.document;
      this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
      var pos = {};

      if (row >= this.document.getLength()) {
        pos.row = Math.max(0, this.document.getLength() - 1);
        pos.column = this.document.getLine(pos.row).length;
      }
      else if (row < 0) {
        pos.row = 0;
        pos.column = 0;
      }
      else {
        pos.row = row;
        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
      }

      if (column < 0)
        pos.column = 0;

      return pos;
    };

  }).call(Anchor.prototype);

});

ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var applyDelta = require("./apply_delta").applyDelta;
  var EventEmitter = require("./lib/event_emitter").EventEmitter;
  var Range = require("./range").Range;
  var Anchor = require("./anchor").Anchor;

  var Document = function(textOrLines) {
    this.$lines = [""];
    if (textOrLines.length === 0) {
      this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
      this.insertMergedLines({row: 0, column: 0}, textOrLines);
    } else {
      this.insert({row: 0, column:0}, textOrLines);
    }
  };

  (function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
      var len = this.getLength() - 1;
      this.remove(new Range(0, 0, len, this.getLine(len).length));
      this.insert({row: 0, column: 0}, text);
    };
    this.getValue = function() {
      return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
      return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0) {
      this.$split = function(text) {
        return text.replace(/\r\n|\r/g, "\n").split("\n");
      };
    } else {
      this.$split = function(text) {
        return text.split(/\r\n|\r|\n/);
      };
    }


    this.$detectNewLine = function(text) {
      var match = text.match(/^.*?(\r\n|\r|\n)/m);
      this.$autoNewLine = match ? match[1] : "\n";
      this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function() {
      switch (this.$newLineMode) {
        case "windows":
          return "\r\n";
        case "unix":
          return "\n";
        default:
          return this.$autoNewLine || "\n";
      }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
      if (this.$newLineMode === newLineMode)
        return;

      this.$newLineMode = newLineMode;
      this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function() {
      return this.$newLineMode;
    };
    this.isNewLine = function(text) {
      return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
      return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
      return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
      return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
      return this.$lines.length;
    };
    this.getTextRange = function(range) {
      return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function(range) {
      var lines;
      if (range.start.row === range.end.row) {
        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
      } else {
        lines = this.getLines(range.start.row, range.end.row);
        lines[0] = (lines[0] || "").substring(range.start.column);
        var l = lines.length - 1;
        if (range.end.row - range.start.row == l)
          lines[l] = lines[l].substring(0, range.end.column);
      }
      return lines;
    };
    this.insertLines = function(row, lines) {
      console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
      return this.insertFullLines(row, lines);
    };
    this.removeLines = function(firstRow, lastRow) {
      console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
      return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function(position) {
      console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
      return this.insertMergedLines(position, ["", ""]);
    };
    this.insert = function(position, text) {
      if (this.getLength() <= 1)
        this.$detectNewLine(text);

      return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function(position, text) {
      var start = this.clippedPos(position.row, position.column);
      var end = this.pos(position.row, position.column + text.length);

      this.applyDelta({
        start: start,
        end: end,
        action: "insert",
        lines: [text]
      }, true);

      return this.clonePos(end);
    };

    this.clippedPos = function(row, column) {
      var length = this.getLength();
      if (row === undefined) {
        row = length;
      } else if (row < 0) {
        row = 0;
      } else if (row >= length) {
        row = length - 1;
        column = undefined;
      }
      var line = this.getLine(row);
      if (column == undefined)
        column = line.length;
      column = Math.min(Math.max(column, 0), line.length);
      return {row: row, column: column};
    };

    this.clonePos = function(pos) {
      return {row: pos.row, column: pos.column};
    };

    this.pos = function(row, column) {
      return {row: row, column: column};
    };

    this.$clipPosition = function(position) {
      var length = this.getLength();
      if (position.row >= length) {
        position.row = Math.max(0, length - 1);
        position.column = this.getLine(length - 1).length;
      } else {
        position.row = Math.max(0, position.row);
        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
      }
      return position;
    };
    this.insertFullLines = function(row, lines) {
      row = Math.min(Math.max(row, 0), this.getLength());
      var column = 0;
      if (row < this.getLength()) {
        lines = lines.concat([""]);
        column = 0;
      } else {
        lines = [""].concat(lines);
        row--;
        column = this.$lines[row].length;
      }
      this.insertMergedLines({row: row, column: column}, lines);
    };
    this.insertMergedLines = function(position, lines) {
      var start = this.clippedPos(position.row, position.column);
      var end = {
        row: start.row + lines.length - 1,
        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
      };

      this.applyDelta({
        start: start,
        end: end,
        action: "insert",
        lines: lines
      });

      return this.clonePos(end);
    };
    this.remove = function(range) {
      var start = this.clippedPos(range.start.row, range.start.column);
      var end = this.clippedPos(range.end.row, range.end.column);
      this.applyDelta({
        start: start,
        end: end,
        action: "remove",
        lines: this.getLinesForRange({start: start, end: end})
      });
      return this.clonePos(start);
    };
    this.removeInLine = function(row, startColumn, endColumn) {
      var start = this.clippedPos(row, startColumn);
      var end = this.clippedPos(row, endColumn);

      this.applyDelta({
        start: start,
        end: end,
        action: "remove",
        lines: this.getLinesForRange({start: start, end: end})
      }, true);

      return this.clonePos(start);
    };
    this.removeFullLines = function(firstRow, lastRow) {
      firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
      lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
      var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
      var deleteLastNewLine  = lastRow  < this.getLength() - 1;
      var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
      var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
      var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
      var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length );
      var range = new Range(startRow, startCol, endRow, endCol);
      var deletedLines = this.$lines.slice(firstRow, lastRow + 1);

      this.applyDelta({
        start: range.start,
        end: range.end,
        action: "remove",
        lines: this.getLinesForRange(range)
      });
      return deletedLines;
    };
    this.removeNewLine = function(row) {
      if (row < this.getLength() - 1 && row >= 0) {
        this.applyDelta({
          start: this.pos(row, this.getLine(row).length),
          end: this.pos(row + 1, 0),
          action: "remove",
          lines: ["", ""]
        });
      }
    };
    this.replace = function(range, text) {
      if (!(range instanceof Range))
        range = Range.fromPoints(range.start, range.end);
      if (text.length === 0 && range.isEmpty())
        return range.start;
      if (text == this.getTextRange(range))
        return range.end;

      this.remove(range);
      var end;
      if (text) {
        end = this.insert(range.start, text);
      }
      else {
        end = range.start;
      }

      return end;
    };
    this.applyDeltas = function(deltas) {
      for (var i=0; i<deltas.length; i++) {
        this.applyDelta(deltas[i]);
      }
    };
    this.revertDeltas = function(deltas) {
      for (var i=deltas.length-1; i>=0; i--) {
        this.revertDelta(deltas[i]);
      }
    };
    this.applyDelta = function(delta, doNotValidate) {
      var isInsert = delta.action == "insert";
      if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
          : !Range.comparePoints(delta.start, delta.end)) {
        return;
      }

      if (isInsert && delta.lines.length > 20000)
        this.$splitAndapplyLargeDelta(delta, 20000);
      applyDelta(this.$lines, delta, doNotValidate);
      this._signal("change", delta);
    };

    this.$splitAndapplyLargeDelta = function(delta, MAX) {
      var lines = delta.lines;
      var l = lines.length;
      var row = delta.start.row;
      var column = delta.start.column;
      var from = 0, to = 0;
      do {
        from = to;
        to += MAX - 1;
        var chunk = lines.slice(from, to);
        if (to > l) {
          delta.lines = chunk;
          delta.start.row = row + from;
          delta.start.column = column;
          break;
        }
        chunk.push("");
        this.applyDelta({
          start: this.pos(row + from, column),
          end: this.pos(row + to, column = 0),
          action: delta.action,
          lines: chunk
        }, true);
      } while(true);
    };
    this.revertDelta = function(delta) {
      this.applyDelta({
        start: this.clonePos(delta.start),
        end: this.clonePos(delta.end),
        action: (delta.action == "insert" ? "remove" : "insert"),
        lines: delta.lines.slice()
      });
    };
    this.indexToPosition = function(index, startRow) {
      var lines = this.$lines || this.getAllLines();
      var newlineLength = this.getNewLineCharacter().length;
      for (var i = startRow || 0, l = lines.length; i < l; i++) {
        index -= lines[i].length + newlineLength;
        if (index < 0)
          return {row: i, column: index + lines[i].length + newlineLength};
      }
      return {row: l-1, column: lines[l-1].length};
    };
    this.positionToIndex = function(pos, startRow) {
      var lines = this.$lines || this.getAllLines();
      var newlineLength = this.getNewLineCharacter().length;
      var index = 0;
      var row = Math.min(pos.row, lines.length);
      for (var i = startRow || 0; i < row; ++i)
        index += lines[i].length + newlineLength;

      return index + pos.column;
    };

  }).call(Document.prototype);

  exports.Document = Document;
});

ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var EventEmitter = require("./lib/event_emitter").EventEmitter;

  var BackgroundTokenizer = function(tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;

    var self = this;

    this.$worker = function() {
      if (!self.running) { return; }

      var workerStart = new Date();
      var currentLine = self.currentLine;
      var endLine = -1;
      var doc = self.doc;

      var startLine = currentLine;
      while (self.lines[currentLine])
        currentLine++;

      var len = doc.getLength();
      var processedLines = 0;
      self.running = false;
      while (currentLine < len) {
        self.$tokenizeRow(currentLine);
        endLine = currentLine;
        do {
          currentLine++;
        } while (self.lines[currentLine]);
        processedLines ++;
        if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
          self.running = setTimeout(self.$worker, 20);
          break;
        }
      }
      self.currentLine = currentLine;

      if (startLine <= endLine)
        self.fireUpdateEvent(startLine, endLine);
    };
  };

  (function(){

    oop.implement(this, EventEmitter);
    this.setTokenizer = function(tokenizer) {
      this.tokenizer = tokenizer;
      this.lines = [];
      this.states = [];

      this.start(0);
    };
    this.setDocument = function(doc) {
      this.doc = doc;
      this.lines = [];
      this.states = [];

      this.stop();
    };
    this.fireUpdateEvent = function(firstRow, lastRow) {
      var data = {
        first: firstRow,
        last: lastRow
      };
      this._signal("update", {data: data});
    };
    this.start = function(startRow) {
      this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
      this.lines.splice(this.currentLine, this.lines.length);
      this.states.splice(this.currentLine, this.states.length);

      this.stop();
      this.running = setTimeout(this.$worker, 700);
    };

    this.scheduleStart = function() {
      if (!this.running)
        this.running = setTimeout(this.$worker, 700);
    }

    this.$updateOnChange = function(delta) {
      var startRow = delta.start.row;
      var len = delta.end.row - startRow;

      if (len === 0) {
        this.lines[startRow] = null;
      } else if (delta.action == "remove") {
        this.lines.splice(startRow, len + 1, null);
        this.states.splice(startRow, len + 1, null);
      } else {
        var args = Array(len + 1);
        args.unshift(startRow, 1);
        this.lines.splice.apply(this.lines, args);
        this.states.splice.apply(this.states, args);
      }

      this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

      this.stop();
    };
    this.stop = function() {
      if (this.running)
        clearTimeout(this.running);
      this.running = false;
    };
    this.getTokens = function(row) {
      return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function(row) {
      if (this.currentLine == row)
        this.$tokenizeRow(row);
      return this.states[row] || "start";
    };

    this.$tokenizeRow = function(row) {
      var line = this.doc.getLine(row);
      var state = this.states[row - 1];

      var data = this.tokenizer.getLineTokens(line, state, row);

      if (this.states[row] + "" !== data.state + "") {
        this.states[row] = data.state;
        this.lines[row + 1] = null;
        if (this.currentLine > row + 1)
          this.currentLine = row + 1;
      } else if (this.currentLine == row) {
        this.currentLine = row + 1;
      }

      return this.lines[row] = data.tokens;
    };

  }).call(BackgroundTokenizer.prototype);

  exports.BackgroundTokenizer = BackgroundTokenizer;
});

ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {
  "use strict";

  var lang = require("./lib/lang");
  var oop = require("./lib/oop");
  var Range = require("./range").Range;

  var SearchHighlight = function(regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || "text";
  };

  (function() {
    this.MAX_RANGES = 500;

    this.setRegexp = function(regExp) {
      if (this.regExp+"" == regExp+"")
        return;
      this.regExp = regExp;
      this.cache = [];
    };

    this.update = function(html, markerLayer, session, config) {
      if (!this.regExp)
        return;
      var start = config.firstRow, end = config.lastRow;

      for (var i = start; i <= end; i++) {
        var ranges = this.cache[i];
        if (ranges == null) {
          ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
          if (ranges.length > this.MAX_RANGES)
            ranges = ranges.slice(0, this.MAX_RANGES);
          ranges = ranges.map(function(match) {
            return new Range(i, match.offset, i, match.offset + match.length);
          });
          this.cache[i] = ranges.length ? ranges : "";
        }

        for (var j = ranges.length; j --; ) {
          markerLayer.drawSingleLineMarker(
            html, ranges[j].toScreenRange(session), this.clazz, config);
        }
      }
    };

  }).call(SearchHighlight.prototype);

  exports.SearchHighlight = SearchHighlight;
});

ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(require, exports, module) {
  "use strict";

  var Range = require("../range").Range;
  function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
      this.folds = folds;
    } else {
      folds = this.folds = [ folds ];
    }

    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column,
      last.end.row, last.end.column);
    this.start = this.range.start;
    this.end   = this.range.end;

    this.folds.forEach(function(fold) {
      fold.setFoldLine(this);
    }, this);
  }

  (function() {
    this.shiftRow = function(shift) {
      this.start.row += shift;
      this.end.row += shift;
      this.folds.forEach(function(fold) {
        fold.start.row += shift;
        fold.end.row += shift;
      });
    };

    this.addFold = function(fold) {
      if (fold.sameRow) {
        if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
          throw new Error("Can't add a fold to this FoldLine as it has no connection");
        }
        this.folds.push(fold);
        this.folds.sort(function(a, b) {
          return -a.range.compareEnd(b.start.row, b.start.column);
        });
        if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
          this.end.row = fold.end.row;
          this.end.column =  fold.end.column;
        } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
          this.start.row = fold.start.row;
          this.start.column = fold.start.column;
        }
      } else if (fold.start.row == this.end.row) {
        this.folds.push(fold);
        this.end.row = fold.end.row;
        this.end.column = fold.end.column;
      } else if (fold.end.row == this.start.row) {
        this.folds.unshift(fold);
        this.start.row = fold.start.row;
        this.start.column = fold.start.column;
      } else {
        throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
      }
      fold.foldLine = this;
    };

    this.containsRow = function(row) {
      return row >= this.start.row && row <= this.end.row;
    };

    this.walk = function(callback, endRow, endColumn) {
      var lastEnd = 0,
        folds = this.folds,
        fold,
        cmp, stop, isNewRow = true;

      if (endRow == null) {
        endRow = this.end.row;
        endColumn = this.end.column;
      }

      for (var i = 0; i < folds.length; i++) {
        fold = folds[i];

        cmp = fold.range.compareStart(endRow, endColumn);
        if (cmp == -1) {
          callback(null, endRow, endColumn, lastEnd, isNewRow);
          return;
        }

        stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
        stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
        if (stop || cmp === 0) {
          return;
        }
        isNewRow = !fold.sameRow;
        lastEnd = fold.end.column;
      }
      callback(null, endRow, endColumn, lastEnd, isNewRow);
    };

    this.getNextFoldTo = function(row, column) {
      var fold, cmp;
      for (var i = 0; i < this.folds.length; i++) {
        fold = this.folds[i];
        cmp = fold.range.compareEnd(row, column);
        if (cmp == -1) {
          return {
            fold: fold,
            kind: "after"
          };
        } else if (cmp === 0) {
          return {
            fold: fold,
            kind: "inside"
          };
        }
      }
      return null;
    };

    this.addRemoveChars = function(row, column, len) {
      var ret = this.getNextFoldTo(row, column),
        fold, folds;
      if (ret) {
        fold = ret.fold;
        if (ret.kind == "inside"
          && fold.start.column != column
          && fold.start.row != row)
        {
          window.console && window.console.log(row, column, fold);
        } else if (fold.start.row == row) {
          folds = this.folds;
          var i = folds.indexOf(fold);
          if (i === 0) {
            this.start.column += len;
          }
          for (i; i < folds.length; i++) {
            fold = folds[i];
            fold.start.column += len;
            if (!fold.sameRow) {
              return;
            }
            fold.end.column += len;
          }
          this.end.column += len;
        }
      }
    };

    this.split = function(row, column) {
      var pos = this.getNextFoldTo(row, column);

      if (!pos || pos.kind == "inside")
        return null;

      var fold = pos.fold;
      var folds = this.folds;
      var foldData = this.foldData;

      var i = folds.indexOf(fold);
      var foldBefore = folds[i - 1];
      this.end.row = foldBefore.end.row;
      this.end.column = foldBefore.end.column;
      folds = folds.splice(i, folds.length - i);

      var newFoldLine = new FoldLine(foldData, folds);
      foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
      return newFoldLine;
    };

    this.merge = function(foldLineNext) {
      var folds = foldLineNext.folds;
      for (var i = 0; i < folds.length; i++) {
        this.addFold(folds[i]);
      }
      var foldData = this.foldData;
      foldData.splice(foldData.indexOf(foldLineNext), 1);
    };

    this.toString = function() {
      var ret = [this.range.toString() + ": [" ];

      this.folds.forEach(function(fold) {
        ret.push("  " + fold.toString());
      });
      ret.push("]");
      return ret.join("\n");
    };

    this.idxToPosition = function(idx) {
      var lastFoldEndColumn = 0;

      for (var i = 0; i < this.folds.length; i++) {
        var fold = this.folds[i];

        idx -= fold.start.column - lastFoldEndColumn;
        if (idx < 0) {
          return {
            row: fold.start.row,
            column: fold.start.column + idx
          };
        }

        idx -= fold.placeholder.length;
        if (idx < 0) {
          return fold.start;
        }

        lastFoldEndColumn = fold.end.column;
      }

      return {
        row: this.end.row,
        column: this.end.column + idx
      };
    };
  }).call(FoldLine.prototype);

  exports.FoldLine = FoldLine;
});

ace.define("ace/range_list",["require","exports","module","ace/range"], function(require, exports, module) {
  "use strict";
  var Range = require("./range").Range;
  var comparePoints = Range.comparePoints;

  var RangeList = function() {
    this.ranges = [];
  };

  (function() {
    this.comparePoints = comparePoints;

    this.pointIndex = function(pos, excludeEdges, startIndex) {
      var list = this.ranges;

      for (var i = startIndex || 0; i < list.length; i++) {
        var range = list[i];
        var cmpEnd = comparePoints(pos, range.end);
        if (cmpEnd > 0)
          continue;
        var cmpStart = comparePoints(pos, range.start);
        if (cmpEnd === 0)
          return excludeEdges && cmpStart !== 0 ? -i-2 : i;
        if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
          return i;

        return -i-1;
      }
      return -i - 1;
    };

    this.add = function(range) {
      var excludeEdges = !range.isEmpty();
      var startIndex = this.pointIndex(range.start, excludeEdges);
      if (startIndex < 0)
        startIndex = -startIndex - 1;

      var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

      if (endIndex < 0)
        endIndex = -endIndex - 1;
      else
        endIndex++;
      return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };

    this.addList = function(list) {
      var removed = [];
      for (var i = list.length; i--; ) {
        removed.push.apply(removed, this.add(list[i]));
      }
      return removed;
    };

    this.substractPoint = function(pos) {
      var i = this.pointIndex(pos);

      if (i >= 0)
        return this.ranges.splice(i, 1);
    };
    this.merge = function() {
      var removed = [];
      var list = this.ranges;

      list = list.sort(function(a, b) {
        return comparePoints(a.start, b.start);
      });

      var next = list[0], range;
      for (var i = 1; i < list.length; i++) {
        range = next;
        next = list[i];
        var cmp = comparePoints(range.end, next.start);
        if (cmp < 0)
          continue;

        if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
          continue;

        if (comparePoints(range.end, next.end) < 0) {
          range.end.row = next.end.row;
          range.end.column = next.end.column;
        }

        list.splice(i, 1);
        removed.push(next);
        next = range;
        i--;
      }

      this.ranges = list;

      return removed;
    };

    this.contains = function(row, column) {
      return this.pointIndex({row: row, column: column}) >= 0;
    };

    this.containsPoint = function(pos) {
      return this.pointIndex(pos) >= 0;
    };

    this.rangeAtPoint = function(pos) {
      var i = this.pointIndex(pos);
      if (i >= 0)
        return this.ranges[i];
    };


    this.clipRows = function(startRow, endRow) {
      var list = this.ranges;
      if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
        return [];

      var startIndex = this.pointIndex({row: startRow, column: 0});
      if (startIndex < 0)
        startIndex = -startIndex - 1;
      var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
      if (endIndex < 0)
        endIndex = -endIndex - 1;

      var clipped = [];
      for (var i = startIndex; i < endIndex; i++) {
        clipped.push(list[i]);
      }
      return clipped;
    };

    this.removeAll = function() {
      return this.ranges.splice(0, this.ranges.length);
    };

    this.attach = function(session) {
      if (this.session)
        this.detach();

      this.session = session;
      this.onChange = this.$onChange.bind(this);

      this.session.on('change', this.onChange);
    };

    this.detach = function() {
      if (!this.session)
        return;
      this.session.removeListener('change', this.onChange);
      this.session = null;
    };

    this.$onChange = function(delta) {
      if (delta.action == "insert"){
        var start = delta.start;
        var end = delta.end;
      } else {
        var end = delta.start;
        var start = delta.end;
      }
      var startRow = start.row;
      var endRow = end.row;
      var lineDif = endRow - startRow;

      var colDiff = -start.column + end.column;
      var ranges = this.ranges;

      for (var i = 0, n = ranges.length; i < n; i++) {
        var r = ranges[i];
        if (r.end.row < startRow)
          continue;
        if (r.start.row > startRow)
          break;

        if (r.start.row == startRow && r.start.column >= start.column ) {
          if (r.start.column == start.column && this.$insertRight) {
          } else {
            r.start.column += colDiff;
            r.start.row += lineDif;
          }
        }
        if (r.end.row == startRow && r.end.column >= start.column) {
          if (r.end.column == start.column && this.$insertRight) {
            continue;
          }
          if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
            if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
              r.end.column -= colDiff;
          }
          r.end.column += colDiff;
          r.end.row += lineDif;
        }
      }

      if (lineDif != 0 && i < n) {
        for (; i < n; i++) {
          var r = ranges[i];
          r.start.row += lineDif;
          r.end.row += lineDif;
        }
      }
    };

  }).call(RangeList.prototype);

  exports.RangeList = RangeList;
});

ace.define("ace/edit_session/fold",["require","exports","module","ace/range","ace/range_list","ace/lib/oop"], function(require, exports, module) {
  "use strict";

  var Range = require("../range").Range;
  var RangeList = require("../range_list").RangeList;
  var oop = require("../lib/oop")
  var Fold = exports.Fold = function(range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;

    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
  };

  oop.inherits(Fold, RangeList);

  (function() {

    this.toString = function() {
      return '"' + this.placeholder + '" ' + this.range.toString();
    };

    this.setFoldLine = function(foldLine) {
      this.foldLine = foldLine;
      this.subFolds.forEach(function(fold) {
        fold.setFoldLine(foldLine);
      });
    };

    this.clone = function() {
      var range = this.range.clone();
      var fold = new Fold(range, this.placeholder);
      this.subFolds.forEach(function(subFold) {
        fold.subFolds.push(subFold.clone());
      });
      fold.collapseChildren = this.collapseChildren;
      return fold;
    };

    this.addSubFold = function(fold) {
      if (this.range.isEqual(fold))
        return;

      if (!this.range.containsRange(fold))
        throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
      consumeRange(fold, this.start);

      var row = fold.start.row, column = fold.start.column;
      for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
        cmp = this.subFolds[i].range.compare(row, column);
        if (cmp != 1)
          break;
      }
      var afterStart = this.subFolds[i];

      if (cmp == 0)
        return afterStart.addSubFold(fold);
      var row = fold.range.end.row, column = fold.range.end.column;
      for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
        cmp = this.subFolds[j].range.compare(row, column);
        if (cmp != 1)
          break;
      }
      var afterEnd = this.subFolds[j];

      if (cmp == 0)
        throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

      var consumedFolds = this.subFolds.splice(i, j - i, fold);
      fold.setFoldLine(this.foldLine);

      return fold;
    };

    this.restoreRange = function(range) {
      return restoreRange(range, this.start);
    };

  }).call(Fold.prototype);

  function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
      point.column -= anchor.column;
  }
  function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
  }
  function restorePoint(point, anchor) {
    if (point.row == 0)
      point.column += anchor.column;
    point.row += anchor.row;
  }
  function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
  }

});

ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(require, exports, module) {
  "use strict";

  var Range = require("../range").Range;
  var FoldLine = require("./fold_line").FoldLine;
  var Fold = require("./fold").Fold;
  var TokenIterator = require("../token_iterator").TokenIterator;

  function Folding() {
    this.getFoldAt = function(row, column, side) {
      var foldLine = this.getFoldLine(row);
      if (!foldLine)
        return null;

      var folds = foldLine.folds;
      for (var i = 0; i < folds.length; i++) {
        var fold = folds[i];
        if (fold.range.contains(row, column)) {
          if (side == 1 && fold.range.isEnd(row, column)) {
            continue;
          } else if (side == -1 && fold.range.isStart(row, column)) {
            continue;
          }
          return fold;
        }
      }
    };
    this.getFoldsInRange = function(range) {
      var start = range.start;
      var end = range.end;
      var foldLines = this.$foldData;
      var foundFolds = [];

      start.column += 1;
      end.column -= 1;

      for (var i = 0; i < foldLines.length; i++) {
        var cmp = foldLines[i].range.compareRange(range);
        if (cmp == 2) {
          continue;
        }
        else if (cmp == -2) {
          break;
        }

        var folds = foldLines[i].folds;
        for (var j = 0; j < folds.length; j++) {
          var fold = folds[j];
          cmp = fold.range.compareRange(range);
          if (cmp == -2) {
            break;
          } else if (cmp == 2) {
            continue;
          } else
          if (cmp == 42) {
            break;
          }
          foundFolds.push(fold);
        }
      }
      start.column -= 1;
      end.column += 1;

      return foundFolds;
    };

    this.getFoldsInRangeList = function(ranges) {
      if (Array.isArray(ranges)) {
        var folds = [];
        ranges.forEach(function(range) {
          folds = folds.concat(this.getFoldsInRange(range));
        }, this);
      } else {
        var folds = this.getFoldsInRange(ranges);
      }
      return folds;
    };
    this.getAllFolds = function() {
      var folds = [];
      var foldLines = this.$foldData;

      for (var i = 0; i < foldLines.length; i++)
        for (var j = 0; j < foldLines[i].folds.length; j++)
          folds.push(foldLines[i].folds[j]);

      return folds;
    };
    this.getFoldStringAt = function(row, column, trim, foldLine) {
      foldLine = foldLine || this.getFoldLine(row);
      if (!foldLine)
        return null;

      var lastFold = {
        end: { column: 0 }
      };
      var str, fold;
      for (var i = 0; i < foldLine.folds.length; i++) {
        fold = foldLine.folds[i];
        var cmp = fold.range.compareEnd(row, column);
        if (cmp == -1) {
          str = this
            .getLine(fold.start.row)
            .substring(lastFold.end.column, fold.start.column);
          break;
        }
        else if (cmp === 0) {
          return null;
        }
        lastFold = fold;
      }
      if (!str)
        str = this.getLine(fold.start.row).substring(lastFold.end.column);

      if (trim == -1)
        return str.substring(0, column - lastFold.end.column);
      else if (trim == 1)
        return str.substring(column - lastFold.end.column);
      else
        return str;
    };

    this.getFoldLine = function(docRow, startFoldLine) {
      var foldData = this.$foldData;
      var i = 0;
      if (startFoldLine)
        i = foldData.indexOf(startFoldLine);
      if (i == -1)
        i = 0;
      for (i; i < foldData.length; i++) {
        var foldLine = foldData[i];
        if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
          return foldLine;
        } else if (foldLine.end.row > docRow) {
          return null;
        }
      }
      return null;
    };
    this.getNextFoldLine = function(docRow, startFoldLine) {
      var foldData = this.$foldData;
      var i = 0;
      if (startFoldLine)
        i = foldData.indexOf(startFoldLine);
      if (i == -1)
        i = 0;
      for (i; i < foldData.length; i++) {
        var foldLine = foldData[i];
        if (foldLine.end.row >= docRow) {
          return foldLine;
        }
      }
      return null;
    };

    this.getFoldedRowCount = function(first, last) {
      var foldData = this.$foldData, rowCount = last-first+1;
      for (var i = 0; i < foldData.length; i++) {
        var foldLine = foldData[i],
          end = foldLine.end.row,
          start = foldLine.start.row;
        if (end >= last) {
          if (start < last) {
            if (start >= first)
              rowCount -= last-start;
            else
              rowCount = 0; // in one fold
          }
          break;
        } else if (end >= first){
          if (start >= first) // fold inside range
            rowCount -=  end-start;
          else
            rowCount -=  end-first+1;
        }
      }
      return rowCount;
    };

    this.$addFoldLine = function(foldLine) {
      this.$foldData.push(foldLine);
      this.$foldData.sort(function(a, b) {
        return a.start.row - b.start.row;
      });
      return foldLine;
    };
    this.addFold = function(placeholder, range) {
      var foldData = this.$foldData;
      var added = false;
      var fold;

      if (placeholder instanceof Fold)
        fold = placeholder;
      else {
        fold = new Fold(range, placeholder);
        fold.collapseChildren = range.collapseChildren;
      }
      this.$clipRangeToDocument(fold.range);

      var startRow = fold.start.row;
      var startColumn = fold.start.column;
      var endRow = fold.end.row;
      var endColumn = fold.end.column;
      if (!(startRow < endRow ||
        startRow == endRow && startColumn <= endColumn - 2))
        throw new Error("The range has to be at least 2 characters width");

      var startFold = this.getFoldAt(startRow, startColumn, 1);
      var endFold = this.getFoldAt(endRow, endColumn, -1);
      if (startFold && endFold == startFold)
        return startFold.addSubFold(fold);

      if (startFold && !startFold.range.isStart(startRow, startColumn))
        this.removeFold(startFold);

      if (endFold && !endFold.range.isEnd(endRow, endColumn))
        this.removeFold(endFold);
      var folds = this.getFoldsInRange(fold.range);
      if (folds.length > 0) {
        this.removeFolds(folds);
        folds.forEach(function(subFold) {
          fold.addSubFold(subFold);
        });
      }

      for (var i = 0; i < foldData.length; i++) {
        var foldLine = foldData[i];
        if (endRow == foldLine.start.row) {
          foldLine.addFold(fold);
          added = true;
          break;
        } else if (startRow == foldLine.end.row) {
          foldLine.addFold(fold);
          added = true;
          if (!fold.sameRow) {
            var foldLineNext = foldData[i + 1];
            if (foldLineNext && foldLineNext.start.row == endRow) {
              foldLine.merge(foldLineNext);
              break;
            }
          }
          break;
        } else if (endRow <= foldLine.start.row) {
          break;
        }
      }

      if (!added)
        foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

      if (this.$useWrapMode)
        this.$updateWrapData(foldLine.start.row, foldLine.start.row);
      else
        this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
      this.$modified = true;
      this._signal("changeFold", { data: fold, action: "add" });

      return fold;
    };

    this.addFolds = function(folds) {
      folds.forEach(function(fold) {
        this.addFold(fold);
      }, this);
    };

    this.removeFold = function(fold) {
      var foldLine = fold.foldLine;
      var startRow = foldLine.start.row;
      var endRow = foldLine.end.row;

      var foldLines = this.$foldData;
      var folds = foldLine.folds;
      if (folds.length == 1) {
        foldLines.splice(foldLines.indexOf(foldLine), 1);
      } else
      if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
        folds.pop();
        foldLine.end.row = folds[folds.length - 1].end.row;
        foldLine.end.column = folds[folds.length - 1].end.column;
      } else
      if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
        folds.shift();
        foldLine.start.row = folds[0].start.row;
        foldLine.start.column = folds[0].start.column;
      } else
      if (fold.sameRow) {
        folds.splice(folds.indexOf(fold), 1);
      } else
      {
        var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
        folds = newFoldLine.folds;
        folds.shift();
        newFoldLine.start.row = folds[0].start.row;
        newFoldLine.start.column = folds[0].start.column;
      }

      if (!this.$updating) {
        if (this.$useWrapMode)
          this.$updateWrapData(startRow, endRow);
        else
          this.$updateRowLengthCache(startRow, endRow);
      }
      this.$modified = true;
      this._signal("changeFold", { data: fold, action: "remove" });
    };

    this.removeFolds = function(folds) {
      var cloneFolds = [];
      for (var i = 0; i < folds.length; i++) {
        cloneFolds.push(folds[i]);
      }

      cloneFolds.forEach(function(fold) {
        this.removeFold(fold);
      }, this);
      this.$modified = true;
    };

    this.expandFold = function(fold) {
      this.removeFold(fold);
      fold.subFolds.forEach(function(subFold) {
        fold.restoreRange(subFold);
        this.addFold(subFold);
      }, this);
      if (fold.collapseChildren > 0) {
        this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
      }
      fold.subFolds = [];
    };

    this.expandFolds = function(folds) {
      folds.forEach(function(fold) {
        this.expandFold(fold);
      }, this);
    };

    this.unfold = function(location, expandInner) {
      var range, folds;
      if (location == null) {
        range = new Range(0, 0, this.getLength(), 0);
        expandInner = true;
      } else if (typeof location == "number")
        range = new Range(location, 0, location, this.getLine(location).length);
      else if ("row" in location)
        range = Range.fromPoints(location, location);
      else
        range = location;

      folds = this.getFoldsInRangeList(range);
      if (expandInner) {
        this.removeFolds(folds);
      } else {
        var subFolds = folds;
        while (subFolds.length) {
          this.expandFolds(subFolds);
          subFolds = this.getFoldsInRangeList(range);
        }
      }
      if (folds.length)
        return folds;
    };
    this.isRowFolded = function(docRow, startFoldRow) {
      return !!this.getFoldLine(docRow, startFoldRow);
    };

    this.getRowFoldEnd = function(docRow, startFoldRow) {
      var foldLine = this.getFoldLine(docRow, startFoldRow);
      return foldLine ? foldLine.end.row : docRow;
    };

    this.getRowFoldStart = function(docRow, startFoldRow) {
      var foldLine = this.getFoldLine(docRow, startFoldRow);
      return foldLine ? foldLine.start.row : docRow;
    };

    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
      if (startRow == null)
        startRow = foldLine.start.row;
      if (startColumn == null)
        startColumn = 0;
      if (endRow == null)
        endRow = foldLine.end.row;
      if (endColumn == null)
        endColumn = this.getLine(endRow).length;
      var doc = this.doc;
      var textLine = "";

      foldLine.walk(function(placeholder, row, column, lastColumn) {
        if (row < startRow)
          return;
        if (row == startRow) {
          if (column < startColumn)
            return;
          lastColumn = Math.max(startColumn, lastColumn);
        }

        if (placeholder != null) {
          textLine += placeholder;
        } else {
          textLine += doc.getLine(row).substring(lastColumn, column);
        }
      }, endRow, endColumn);
      return textLine;
    };

    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
      var foldLine = this.getFoldLine(row);

      if (!foldLine) {
        var line;
        line = this.doc.getLine(row);
        return line.substring(startColumn || 0, endColumn || line.length);
      } else {
        return this.getFoldDisplayLine(
          foldLine, row, endColumn, startRow, startColumn);
      }
    };

    this.$cloneFoldData = function() {
      var fd = [];
      fd = this.$foldData.map(function(foldLine) {
        var folds = foldLine.folds.map(function(fold) {
          return fold.clone();
        });
        return new FoldLine(fd, folds);
      });

      return fd;
    };

    this.toggleFold = function(tryToUnfold) {
      var selection = this.selection;
      var range = selection.getRange();
      var fold;
      var bracketPos;

      if (range.isEmpty()) {
        var cursor = range.start;
        fold = this.getFoldAt(cursor.row, cursor.column);

        if (fold) {
          this.expandFold(fold);
          return;
        } else if (bracketPos = this.findMatchingBracket(cursor)) {
          if (range.comparePoint(bracketPos) == 1) {
            range.end = bracketPos;
          } else {
            range.start = bracketPos;
            range.start.column++;
            range.end.column--;
          }
        } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
          if (range.comparePoint(bracketPos) == 1)
            range.end = bracketPos;
          else
            range.start = bracketPos;

          range.start.column++;
        } else {
          range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
        }
      } else {
        var folds = this.getFoldsInRange(range);
        if (tryToUnfold && folds.length) {
          this.expandFolds(folds);
          return;
        } else if (folds.length == 1 ) {
          fold = folds[0];
        }
      }

      if (!fold)
        fold = this.getFoldAt(range.start.row, range.start.column);

      if (fold && fold.range.toString() == range.toString()) {
        this.expandFold(fold);
        return;
      }

      var placeholder = "...";
      if (!range.isMultiLine()) {
        placeholder = this.getTextRange(range);
        if (placeholder.length < 4)
          return;
        placeholder = placeholder.trim().substring(0, 2) + "..";
      }

      this.addFold(placeholder, range);
    };

    this.getCommentFoldRange = function(row, column, dir) {
      var iterator = new TokenIterator(this, row, column);
      var token = iterator.getCurrentToken();
      if (token && /^comment|string/.test(token.type)) {
        var range = new Range();
        var re = new RegExp(token.type.replace(/\..*/, "\\."));
        if (dir != 1) {
          do {
            token = iterator.stepBackward();
          } while (token && re.test(token.type));
          iterator.stepForward();
        }

        range.start.row = iterator.getCurrentTokenRow();
        range.start.column = iterator.getCurrentTokenColumn() + 2;

        iterator = new TokenIterator(this, row, column);

        if (dir != -1) {
          do {
            token = iterator.stepForward();
          } while (token && re.test(token.type));
          token = iterator.stepBackward();
        } else
          token = iterator.getCurrentToken();

        range.end.row = iterator.getCurrentTokenRow();
        range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
        return range;
      }
    };

    this.foldAll = function(startRow, endRow, depth) {
      if (depth == undefined)
        depth = 100000; // JSON.stringify doesn't hanle Infinity
      var foldWidgets = this.foldWidgets;
      if (!foldWidgets)
        return; // mode doesn't support folding
      endRow = endRow || this.getLength();
      startRow = startRow || 0;
      for (var row = startRow; row < endRow; row++) {
        if (foldWidgets[row] == null)
          foldWidgets[row] = this.getFoldWidget(row);
        if (foldWidgets[row] != "start")
          continue;

        var range = this.getFoldWidgetRange(row);
        if (range && range.isMultiLine()
          && range.end.row <= endRow
          && range.start.row >= startRow
        ) {
          row = range.end.row;
          try {
            var fold = this.addFold("...", range);
            if (fold)
              fold.collapseChildren = depth;
          } catch(e) {}
        }
      }
    };
    this.$foldStyles = {
      "manual": 1,
      "markbegin": 1,
      "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function(style) {
      if (!this.$foldStyles[style])
        throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");

      if (this.$foldStyle == style)
        return;

      this.$foldStyle = style;

      if (style == "manual")
        this.unfold();
      var mode = this.$foldMode;
      this.$setFolding(null);
      this.$setFolding(mode);
    };

    this.$setFolding = function(foldMode) {
      if (this.$foldMode == foldMode)
        return;

      this.$foldMode = foldMode;

      this.off('change', this.$updateFoldWidgets);
      this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
      this._signal("changeAnnotation");

      if (!foldMode || this.$foldStyle == "manual") {
        this.foldWidgets = null;
        return;
      }

      this.foldWidgets = [];
      this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
      this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);

      this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
      this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
      this.on('change', this.$updateFoldWidgets);
      this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };

    this.getParentFoldRangeData = function (row, ignoreCurrent) {
      var fw = this.foldWidgets;
      if (!fw || (ignoreCurrent && fw[row]))
        return {};

      var i = row - 1, firstRange;
      while (i >= 0) {
        var c = fw[i];
        if (c == null)
          c = fw[i] = this.getFoldWidget(i);

        if (c == "start") {
          var range = this.getFoldWidgetRange(i);
          if (!firstRange)
            firstRange = range;
          if (range && range.end.row >= row)
            break;
        }
        i--;
      }

      return {
        range: i !== -1 && range,
        firstRange: firstRange
      };
    };

    this.onFoldWidgetClick = function(row, e) {
      e = e.domEvent;
      var options = {
        children: e.shiftKey,
        all: e.ctrlKey || e.metaKey,
        siblings: e.altKey
      };

      var range = this.$toggleFoldWidget(row, options);
      if (!range) {
        var el = (e.target || e.srcElement);
        if (el && /ace_fold-widget/.test(el.className))
          el.className += " ace_invalid";
      }
    };

    this.$toggleFoldWidget = function(row, options) {
      if (!this.getFoldWidget)
        return;
      var type = this.getFoldWidget(row);
      var line = this.getLine(row);

      var dir = type === "end" ? -1 : 1;
      var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

      if (fold) {
        if (options.children || options.all)
          this.removeFold(fold);
        else
          this.expandFold(fold);
        return fold;
      }

      var range = this.getFoldWidgetRange(row, true);
      if (range && !range.isMultiLine()) {
        fold = this.getFoldAt(range.start.row, range.start.column, 1);
        if (fold && range.isEqual(fold.range)) {
          this.removeFold(fold);
          return fold;
        }
      }

      if (options.siblings) {
        var data = this.getParentFoldRangeData(row);
        if (data.range) {
          var startRow = data.range.start.row + 1;
          var endRow = data.range.end.row;
        }
        this.foldAll(startRow, endRow, options.all ? 10000 : 0);
      } else if (options.children) {
        endRow = range ? range.end.row : this.getLength();
        this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
      } else if (range) {
        if (options.all)
          range.collapseChildren = 10000;
        this.addFold("...", range);
      }

      return range;
    };



    this.toggleFoldWidget = function(toggleParent) {
      var row = this.selection.getCursor().row;
      row = this.getRowFoldStart(row);
      var range = this.$toggleFoldWidget(row, {});

      if (range)
        return;
      var data = this.getParentFoldRangeData(row, true);
      range = data.range || data.firstRange;

      if (range) {
        row = range.start.row;
        var fold = this.getFoldAt(row, this.getLine(row).length, 1);

        if (fold) {
          this.removeFold(fold);
        } else {
          this.addFold("...", range);
        }
      }
    };

    this.updateFoldWidgets = function(delta) {
      var firstRow = delta.start.row;
      var len = delta.end.row - firstRow;

      if (len === 0) {
        this.foldWidgets[firstRow] = null;
      } else if (delta.action == 'remove') {
        this.foldWidgets.splice(firstRow, len + 1, null);
      } else {
        var args = Array(len + 1);
        args.unshift(firstRow, 1);
        this.foldWidgets.splice.apply(this.foldWidgets, args);
      }
    };
    this.tokenizerUpdateFoldWidgets = function(e) {
      var rows = e.data;
      if (rows.first != rows.last) {
        if (this.foldWidgets.length > rows.first)
          this.foldWidgets.splice(rows.first, this.foldWidgets.length);
      }
    };
  }

  exports.Folding = Folding;

});

ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(require, exports, module) {
  "use strict";

  var TokenIterator = require("../token_iterator").TokenIterator;
  var Range = require("../range").Range;


  function BracketMatch() {

    this.findMatchingBracket = function(position, chr) {
      if (position.column == 0) return null;

      var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
      if (charBeforeCursor == "") return null;

      var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
      if (!match)
        return null;

      if (match[1])
        return this.$findClosingBracket(match[1], position);
      else
        return this.$findOpeningBracket(match[2], position);
    };

    this.getBracketRange = function(pos) {
      var line = this.getLine(pos.row);
      var before = true, range;

      var chr = line.charAt(pos.column-1);
      var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
      if (!match) {
        chr = line.charAt(pos.column);
        pos = {row: pos.row, column: pos.column + 1};
        match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        before = false;
      }
      if (!match)
        return null;

      if (match[1]) {
        var bracketPos = this.$findClosingBracket(match[1], pos);
        if (!bracketPos)
          return null;
        range = Range.fromPoints(pos, bracketPos);
        if (!before) {
          range.end.column++;
          range.start.column--;
        }
        range.cursor = range.end;
      } else {
        var bracketPos = this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
          return null;
        range = Range.fromPoints(bracketPos, pos);
        if (!before) {
          range.start.column++;
          range.end.column--;
        }
        range.cursor = range.start;
      }

      return range;
    };

    this.$brackets = {
      ")": "(",
      "(": ")",
      "]": "[",
      "[": "]",
      "{": "}",
      "}": "{"
    };

    this.$findOpeningBracket = function(bracket, position, typeRe) {
      var openBracket = this.$brackets[bracket];
      var depth = 1;

      var iterator = new TokenIterator(this, position.row, position.column);
      var token = iterator.getCurrentToken();
      if (!token)
        token = iterator.stepForward();
      if (!token)
        return;

      if (!typeRe){
        typeRe = new RegExp(
          "(\\.?" +
          token.type.replace(".", "\\.").replace("rparen", ".paren")
            .replace(/\b(?:end)\b/, "(?:start|begin|end)")
          + ")+"
        );
      }
      var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
      var value = token.value;

      while (true) {

        while (valueIndex >= 0) {
          var chr = value.charAt(valueIndex);
          if (chr == openBracket) {
            depth -= 1;
            if (depth == 0) {
              return {row: iterator.getCurrentTokenRow(),
                column: valueIndex + iterator.getCurrentTokenColumn()};
            }
          }
          else if (chr == bracket) {
            depth += 1;
          }
          valueIndex -= 1;
        }
        do {
          token = iterator.stepBackward();
        } while (token && !typeRe.test(token.type));

        if (token == null)
          break;

        value = token.value;
        valueIndex = value.length - 1;
      }

      return null;
    };

    this.$findClosingBracket = function(bracket, position, typeRe) {
      var closingBracket = this.$brackets[bracket];
      var depth = 1;

      var iterator = new TokenIterator(this, position.row, position.column);
      var token = iterator.getCurrentToken();
      if (!token)
        token = iterator.stepForward();
      if (!token)
        return;

      if (!typeRe){
        typeRe = new RegExp(
          "(\\.?" +
          token.type.replace(".", "\\.").replace("lparen", ".paren")
            .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
          + ")+"
        );
      }
      var valueIndex = position.column - iterator.getCurrentTokenColumn();

      while (true) {

        var value = token.value;
        var valueLength = value.length;
        while (valueIndex < valueLength) {
          var chr = value.charAt(valueIndex);
          if (chr == closingBracket) {
            depth -= 1;
            if (depth == 0) {
              return {row: iterator.getCurrentTokenRow(),
                column: valueIndex + iterator.getCurrentTokenColumn()};
            }
          }
          else if (chr == bracket) {
            depth += 1;
          }
          valueIndex += 1;
        }
        do {
          token = iterator.stepForward();
        } while (token && !typeRe.test(token.type));

        if (token == null)
          break;

        valueIndex = 0;
      }

      return null;
    };
  }
  exports.BracketMatch = BracketMatch;

});

ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var lang = require("./lib/lang");
  var config = require("./config");
  var EventEmitter = require("./lib/event_emitter").EventEmitter;
  var Selection = require("./selection").Selection;
  var TextMode = require("./mode/text").Mode;
  var Range = require("./range").Range;
  var Document = require("./document").Document;
  var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
  var SearchHighlight = require("./search_highlight").SearchHighlight;

  var EditSession = function(text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;

    this.$foldData = [];
    this.id = "session" + (++EditSession.$uid);
    this.$foldData.toString = function() {
      return this.join("\n");
    };
    this.on("changeFold", this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);

    if (typeof text != "object" || !text.getLine)
      text = new Document(text);

    this.setDocument(text);
    this.selection = new Selection(this);

    config.resetOptions(this);
    this.setMode(mode);
    config._signal("session", this);
  };


  (function() {

    oop.implement(this, EventEmitter);
    this.setDocument = function(doc) {
      if (this.doc)
        this.doc.removeListener("change", this.$onChange);

      this.doc = doc;
      doc.on("change", this.$onChange);

      if (this.bgTokenizer)
        this.bgTokenizer.setDocument(this.getDocument());

      this.resetCaches();
    };
    this.getDocument = function() {
      return this.doc;
    };
    this.$resetRowCache = function(docRow) {
      if (!docRow) {
        this.$docRowCache = [];
        this.$screenRowCache = [];
        return;
      }
      var l = this.$docRowCache.length;
      var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
      if (l > i) {
        this.$docRowCache.splice(i, l);
        this.$screenRowCache.splice(i, l);
      }
    };

    this.$getRowCacheIndex = function(cacheArray, val) {
      var low = 0;
      var hi = cacheArray.length - 1;

      while (low <= hi) {
        var mid = (low + hi) >> 1;
        var c = cacheArray[mid];

        if (val > c)
          low = mid + 1;
        else if (val < c)
          hi = mid - 1;
        else
          return mid;
      }

      return low -1;
    };

    this.resetCaches = function() {
      this.$modified = true;
      this.$wrapData = [];
      this.$rowLengthCache = [];
      this.$resetRowCache(0);
      if (this.bgTokenizer)
        this.bgTokenizer.start(0);
    };

    this.onChangeFold = function(e) {
      var fold = e.data;
      this.$resetRowCache(fold.start.row);
    };

    this.onChange = function(delta) {
      this.$modified = true;

      this.$resetRowCache(delta.start.row);

      var removedFolds = this.$updateInternalDataOnChange(delta);
      if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
        this.$deltasDoc.push(delta);
        if (removedFolds && removedFolds.length != 0) {
          this.$deltasFold.push({
            action: "removeFolds",
            folds:  removedFolds
          });
        }

        this.$informUndoManager.schedule();
      }

      this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
      this._signal("change", delta);
    };
    this.setValue = function(text) {
      this.doc.setValue(text);
      this.selection.moveTo(0, 0);

      this.$resetRowCache(0);
      this.$deltas = [];
      this.$deltasDoc = [];
      this.$deltasFold = [];
      this.setUndoManager(this.$undoManager);
      this.getUndoManager().reset();
    };
    this.getValue =
      this.toString = function() {
        return this.doc.getValue();
      };
    this.getSelection = function() {
      return this.selection;
    };
    this.getState = function(row) {
      return this.bgTokenizer.getState(row);
    };
    this.getTokens = function(row) {
      return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function(row, column) {
      var tokens = this.bgTokenizer.getTokens(row);
      var token, c = 0;
      if (column == null) {
        i = tokens.length - 1;
        c = this.getLine(row).length;
      } else {
        for (var i = 0; i < tokens.length; i++) {
          c += tokens[i].value.length;
          if (c >= column)
            break;
        }
      }
      token = tokens[i];
      if (!token)
        return null;
      token.index = i;
      token.start = c - token.value.length;
      return token;
    };
    this.setUndoManager = function(undoManager) {
      this.$undoManager = undoManager;
      this.$deltas = [];
      this.$deltasDoc = [];
      this.$deltasFold = [];

      if (this.$informUndoManager)
        this.$informUndoManager.cancel();

      if (undoManager) {
        var self = this;

        this.$syncInformUndoManager = function() {
          self.$informUndoManager.cancel();

          if (self.$deltasFold.length) {
            self.$deltas.push({
              group: "fold",
              deltas: self.$deltasFold
            });
            self.$deltasFold = [];
          }

          if (self.$deltasDoc.length) {
            self.$deltas.push({
              group: "doc",
              deltas: self.$deltasDoc
            });
            self.$deltasDoc = [];
          }

          if (self.$deltas.length > 0) {
            undoManager.execute({
              action: "aceupdate",
              args: [self.$deltas, self],
              merge: self.mergeUndoDeltas
            });
          }
          self.mergeUndoDeltas = false;
          self.$deltas = [];
        };
        this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
      }
    };
    this.markUndoGroup = function() {
      if (this.$syncInformUndoManager)
        this.$syncInformUndoManager();
    };

    this.$defaultUndoManager = {
      undo: function() {},
      redo: function() {},
      reset: function() {}
    };
    this.getUndoManager = function() {
      return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function() {
      if (this.getUseSoftTabs()) {
        return lang.stringRepeat(" ", this.getTabSize());
      } else {
        return "\t";
      }
    };
    this.setUseSoftTabs = function(val) {
      this.setOption("useSoftTabs", val);
    };
    this.getUseSoftTabs = function() {
      return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function(tabSize) {
      this.setOption("tabSize", tabSize);
    };
    this.getTabSize = function() {
      return this.$tabSize;
    };
    this.isTabStop = function(position) {
      return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    };

    this.$overwrite = false;
    this.setOverwrite = function(overwrite) {
      this.setOption("overwrite", overwrite);
    };
    this.getOverwrite = function() {
      return this.$overwrite;
    };
    this.toggleOverwrite = function() {
      this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function(row, className) {
      if (!this.$decorations[row])
        this.$decorations[row] = "";
      this.$decorations[row] += " " + className;
      this._signal("changeBreakpoint", {});
    };
    this.removeGutterDecoration = function(row, className) {
      this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
      this._signal("changeBreakpoint", {});
    };
    this.getBreakpoints = function() {
      return this.$breakpoints;
    };
    this.setBreakpoints = function(rows) {
      this.$breakpoints = [];
      for (var i=0; i<rows.length; i++) {
        this.$breakpoints[rows[i]] = "ace_breakpoint";
      }
      this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoints = function() {
      this.$breakpoints = [];
      this._signal("changeBreakpoint", {});
    };
    this.setBreakpoint = function(row, className) {
      if (className === undefined)
        className = "ace_breakpoint";
      if (className)
        this.$breakpoints[row] = className;
      else
        delete this.$breakpoints[row];
      this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoint = function(row) {
      delete this.$breakpoints[row];
      this._signal("changeBreakpoint", {});
    };
    this.addMarker = function(range, clazz, type, inFront) {
      var id = this.$markerId++;

      var marker = {
        range : range,
        type : type || "line",
        renderer: typeof type == "function" ? type : null,
        clazz : clazz,
        inFront: !!inFront,
        id: id
      };

      if (inFront) {
        this.$frontMarkers[id] = marker;
        this._signal("changeFrontMarker");
      } else {
        this.$backMarkers[id] = marker;
        this._signal("changeBackMarker");
      }

      return id;
    };
    this.addDynamicMarker = function(marker, inFront) {
      if (!marker.update)
        return;
      var id = this.$markerId++;
      marker.id = id;
      marker.inFront = !!inFront;

      if (inFront) {
        this.$frontMarkers[id] = marker;
        this._signal("changeFrontMarker");
      } else {
        this.$backMarkers[id] = marker;
        this._signal("changeBackMarker");
      }

      return marker;
    };
    this.removeMarker = function(markerId) {
      var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
      if (!marker)
        return;

      var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
      if (marker) {
        delete (markers[markerId]);
        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
      }
    };
    this.getMarkers = function(inFront) {
      return inFront ? this.$frontMarkers : this.$backMarkers;
    };

    this.highlight = function(re) {
      if (!this.$searchHighlight) {
        var highlight = new SearchHighlight(null, "ace_selected-word", "text");
        this.$searchHighlight = this.addDynamicMarker(highlight);
      }
      this.$searchHighlight.setRegexp(re);
    };
    this.highlightLines = function(startRow, endRow, clazz, inFront) {
      if (typeof endRow != "number") {
        clazz = endRow;
        endRow = startRow;
      }
      if (!clazz)
        clazz = "ace_step";

      var range = new Range(startRow, 0, endRow, Infinity);
      range.id = this.addMarker(range, clazz, "fullLine", inFront);
      return range;
    };
    this.setAnnotations = function(annotations) {
      this.$annotations = annotations;
      this._signal("changeAnnotation", {});
    };
    this.getAnnotations = function() {
      return this.$annotations || [];
    };
    this.clearAnnotations = function() {
      this.setAnnotations([]);
    };
    this.$detectNewLine = function(text) {
      var match = text.match(/^.*?(\r?\n)/m);
      if (match) {
        this.$autoNewLine = match[1];
      } else {
        this.$autoNewLine = "\n";
      }
    };
    this.getWordRange = function(row, column) {
      var line = this.getLine(row);

      var inToken = false;
      if (column > 0)
        inToken = !!line.charAt(column - 1).match(this.tokenRe);

      if (!inToken)
        inToken = !!line.charAt(column).match(this.tokenRe);

      if (inToken)
        var re = this.tokenRe;
      else if (/^\s+$/.test(line.slice(column-1, column+1)))
        var re = /\s/;
      else
        var re = this.nonTokenRe;

      var start = column;
      if (start > 0) {
        do {
          start--;
        }
        while (start >= 0 && line.charAt(start).match(re));
        start++;
      }

      var end = column;
      while (end < line.length && line.charAt(end).match(re)) {
        end++;
      }

      return new Range(row, start, row, end);
    };
    this.getAWordRange = function(row, column) {
      var wordRange = this.getWordRange(row, column);
      var line = this.getLine(wordRange.end.row);

      while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
        wordRange.end.column += 1;
      }
      return wordRange;
    };
    this.setNewLineMode = function(newLineMode) {
      this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function() {
      return this.doc.getNewLineMode();
    };
    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
    this.getUseWorker = function() { return this.$useWorker; };
    this.onReloadTokenizer = function(e) {
      var rows = e.data;
      this.bgTokenizer.start(rows.first);
      this._signal("tokenizerUpdate", e);
    };

    this.$modes = {};
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function(mode, cb) {
      if (mode && typeof mode === "object") {
        if (mode.getTokenizer)
          return this.$onChangeMode(mode);
        var options = mode;
        var path = options.path;
      } else {
        path = mode || "ace/mode/text";
      }
      if (!this.$modes["ace/mode/text"])
        this.$modes["ace/mode/text"] = new TextMode();

      if (this.$modes[path] && !options) {
        this.$onChangeMode(this.$modes[path]);
        cb && cb();
        return;
      }
      this.$modeId = path;
      config.loadModule(["mode", path], function(m) {
        if (this.$modeId !== path)
          return cb && cb();
        if (this.$modes[path] && !options) {
          this.$onChangeMode(this.$modes[path]);
        } else if (m && m.Mode) {
          m = new m.Mode(options);
          if (!options) {
            this.$modes[path] = m;
            m.$id = path;
          }
          this.$onChangeMode(m);
        }
        cb && cb();
      }.bind(this));
      if (!this.$mode)
        this.$onChangeMode(this.$modes["ace/mode/text"], true);
    };

    this.$onChangeMode = function(mode, $isPlaceholder) {
      if (!$isPlaceholder)
        this.$modeId = mode.$id;
      if (this.$mode === mode)
        return;

      this.$mode = mode;

      this.$stopWorker();

      if (this.$useWorker)
        this.$startWorker();

      var tokenizer = mode.getTokenizer();

      if(tokenizer.addEventListener !== undefined) {
        var onReloadTokenizer = this.onReloadTokenizer.bind(this);
        tokenizer.addEventListener("update", onReloadTokenizer);
      }

      if (!this.bgTokenizer) {
        this.bgTokenizer = new BackgroundTokenizer(tokenizer);
        var _self = this;
        this.bgTokenizer.addEventListener("update", function(e) {
          _self._signal("tokenizerUpdate", e);
        });
      } else {
        this.bgTokenizer.setTokenizer(tokenizer);
      }

      this.bgTokenizer.setDocument(this.getDocument());

      this.tokenRe = mode.tokenRe;
      this.nonTokenRe = mode.nonTokenRe;


      if (!$isPlaceholder) {
        if (mode.attachToSession)
          mode.attachToSession(this);
        this.$options.wrapMethod.set.call(this, this.$wrapMethod);
        this.$setFolding(mode.foldingRules);
        this.bgTokenizer.start(0);
        this._emit("changeMode");
      }
    };

    this.$stopWorker = function() {
      if (this.$worker) {
        this.$worker.terminate();
        this.$worker = null;
      }
    };

    this.$startWorker = function() {
      try {
        this.$worker = this.$mode.createWorker(this);
      } catch (e) {
        config.warn("Could not load worker", e);
        this.$worker = null;
      }
    };
    this.getMode = function() {
      return this.$mode;
    };

    this.$scrollTop = 0;
    this.setScrollTop = function(scrollTop) {
      if (this.$scrollTop === scrollTop || isNaN(scrollTop))
        return;

      this.$scrollTop = scrollTop;
      this._signal("changeScrollTop", scrollTop);
    };
    this.getScrollTop = function() {
      return this.$scrollTop;
    };

    this.$scrollLeft = 0;
    this.setScrollLeft = function(scrollLeft) {
      if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
        return;

      this.$scrollLeft = scrollLeft;
      this._signal("changeScrollLeft", scrollLeft);
    };
    this.getScrollLeft = function() {
      return this.$scrollLeft;
    };
    this.getScreenWidth = function() {
      this.$computeWidth();
      if (this.lineWidgets)
        return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
      return this.screenWidth;
    };

    this.getLineWidgetMaxWidth = function() {
      if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
      var width = 0;
      this.lineWidgets.forEach(function(w) {
        if (w && w.screenWidth > width)
          width = w.screenWidth;
      });
      return this.lineWidgetWidth = width;
    };

    this.$computeWidth = function(force) {
      if (this.$modified || force) {
        this.$modified = false;

        if (this.$useWrapMode)
          return this.screenWidth = this.$wrapLimit;

        var lines = this.doc.getAllLines();
        var cache = this.$rowLengthCache;
        var longestScreenLine = 0;
        var foldIndex = 0;
        var foldLine = this.$foldData[foldIndex];
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        var len = lines.length;

        for (var i = 0; i < len; i++) {
          if (i > foldStart) {
            i = foldLine.end.row + 1;
            if (i >= len)
              break;
            foldLine = this.$foldData[foldIndex++];
            foldStart = foldLine ? foldLine.start.row : Infinity;
          }

          if (cache[i] == null)
            cache[i] = this.$getStringScreenWidth(lines[i])[0];

          if (cache[i] > longestScreenLine)
            longestScreenLine = cache[i];
        }
        this.screenWidth = longestScreenLine;
      }
    };
    this.getLine = function(row) {
      return this.doc.getLine(row);
    };
    this.getLines = function(firstRow, lastRow) {
      return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function() {
      return this.doc.getLength();
    };
    this.getTextRange = function(range) {
      return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function(position, text) {
      return this.doc.insert(position, text);
    };
    this.remove = function(range) {
      return this.doc.remove(range);
    };
    this.removeFullLines = function(firstRow, lastRow){
      return this.doc.removeFullLines(firstRow, lastRow);
    };
    this.undoChanges = function(deltas, dontSelect) {
      if (!deltas.length)
        return;

      this.$fromUndo = true;
      var lastUndoRange = null;
      for (var i = deltas.length - 1; i != -1; i--) {
        var delta = deltas[i];
        if (delta.group == "doc") {
          this.doc.revertDeltas(delta.deltas);
          lastUndoRange =
            this.$getUndoSelection(delta.deltas, true, lastUndoRange);
        } else {
          delta.deltas.forEach(function(foldDelta) {
            this.addFolds(foldDelta.folds);
          }, this);
        }
      }
      this.$fromUndo = false;
      lastUndoRange &&
      this.$undoSelect &&
      !dontSelect &&
      this.selection.setSelectionRange(lastUndoRange);
      return lastUndoRange;
    };
    this.redoChanges = function(deltas, dontSelect) {
      if (!deltas.length)
        return;

      this.$fromUndo = true;
      var lastUndoRange = null;
      for (var i = 0; i < deltas.length; i++) {
        var delta = deltas[i];
        if (delta.group == "doc") {
          this.doc.applyDeltas(delta.deltas);
          lastUndoRange =
            this.$getUndoSelection(delta.deltas, false, lastUndoRange);
        }
      }
      this.$fromUndo = false;
      lastUndoRange &&
      this.$undoSelect &&
      !dontSelect &&
      this.selection.setSelectionRange(lastUndoRange);
      return lastUndoRange;
    };
    this.setUndoSelect = function(enable) {
      this.$undoSelect = enable;
    };

    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
      function isInsert(delta) {
        return isUndo ? delta.action !== "insert" : delta.action === "insert";
      }

      var delta = deltas[0];
      var range, point;
      var lastDeltaIsInsert = false;
      if (isInsert(delta)) {
        range = Range.fromPoints(delta.start, delta.end);
        lastDeltaIsInsert = true;
      } else {
        range = Range.fromPoints(delta.start, delta.start);
        lastDeltaIsInsert = false;
      }

      for (var i = 1; i < deltas.length; i++) {
        delta = deltas[i];
        if (isInsert(delta)) {
          point = delta.start;
          if (range.compare(point.row, point.column) == -1) {
            range.setStart(point);
          }
          point = delta.end;
          if (range.compare(point.row, point.column) == 1) {
            range.setEnd(point);
          }
          lastDeltaIsInsert = true;
        } else {
          point = delta.start;
          if (range.compare(point.row, point.column) == -1) {
            range = Range.fromPoints(delta.start, delta.start);
          }
          lastDeltaIsInsert = false;
        }
      }
      if (lastUndoRange != null) {
        if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
          lastUndoRange.start.column += range.end.column - range.start.column;
          lastUndoRange.end.column += range.end.column - range.start.column;
        }

        var cmp = lastUndoRange.compareRange(range);
        if (cmp == 1) {
          range.setStart(lastUndoRange.start);
        } else if (cmp == -1) {
          range.setEnd(lastUndoRange.end);
        }
      }

      return range;
    };
    this.replace = function(range, text) {
      return this.doc.replace(range, text);
    };
    this.moveText = function(fromRange, toPosition, copy) {
      var text = this.getTextRange(fromRange);
      var folds = this.getFoldsInRange(fromRange);

      var toRange = Range.fromPoints(toPosition, toPosition);
      if (!copy) {
        this.remove(fromRange);
        var rowDiff = fromRange.start.row - fromRange.end.row;
        var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
        if (collDiff) {
          if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
            toRange.start.column += collDiff;
          if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
            toRange.end.column += collDiff;
        }
        if (rowDiff && toRange.start.row >= fromRange.end.row) {
          toRange.start.row += rowDiff;
          toRange.end.row += rowDiff;
        }
      }

      toRange.end = this.insert(toRange.start, text);
      if (folds.length) {
        var oldStart = fromRange.start;
        var newStart = toRange.start;
        var rowDiff = newStart.row - oldStart.row;
        var collDiff = newStart.column - oldStart.column;
        this.addFolds(folds.map(function(x) {
          x = x.clone();
          if (x.start.row == oldStart.row)
            x.start.column += collDiff;
          if (x.end.row == oldStart.row)
            x.end.column += collDiff;
          x.start.row += rowDiff;
          x.end.row += rowDiff;
          return x;
        }));
      }

      return toRange;
    };
    this.indentRows = function(startRow, endRow, indentString) {
      indentString = indentString.replace(/\t/g, this.getTabString());
      for (var row=startRow; row<=endRow; row++)
        this.doc.insertInLine({row: row, column: 0}, indentString);
    };
    this.outdentRows = function (range) {
      var rowRange = range.collapseRows();
      var deleteRange = new Range(0, 0, 0, 0);
      var size = this.getTabSize();

      for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
        var line = this.getLine(i);

        deleteRange.start.row = i;
        deleteRange.end.row = i;
        for (var j = 0; j < size; ++j)
          if (line.charAt(j) != ' ')
            break;
        if (j < size && line.charAt(j) == '\t') {
          deleteRange.start.column = j;
          deleteRange.end.column = j + 1;
        } else {
          deleteRange.start.column = 0;
          deleteRange.end.column = j;
        }
        this.remove(deleteRange);
      }
    };

    this.$moveLines = function(firstRow, lastRow, dir) {
      firstRow = this.getRowFoldStart(firstRow);
      lastRow = this.getRowFoldEnd(lastRow);
      if (dir < 0) {
        var row = this.getRowFoldStart(firstRow + dir);
        if (row < 0) return 0;
        var diff = row-firstRow;
      } else if (dir > 0) {
        var row = this.getRowFoldEnd(lastRow + dir);
        if (row > this.doc.getLength()-1) return 0;
        var diff = row-lastRow;
      } else {
        firstRow = this.$clipRowToDocument(firstRow);
        lastRow = this.$clipRowToDocument(lastRow);
        var diff = lastRow - firstRow + 1;
      }

      var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
      var folds = this.getFoldsInRange(range).map(function(x){
        x = x.clone();
        x.start.row += diff;
        x.end.row += diff;
        return x;
      });

      var lines = dir == 0
        ? this.doc.getLines(firstRow, lastRow)
        : this.doc.removeFullLines(firstRow, lastRow);
      this.doc.insertFullLines(firstRow+diff, lines);
      folds.length && this.addFolds(folds);
      return diff;
    };
    this.moveLinesUp = function(firstRow, lastRow) {
      return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function(firstRow, lastRow) {
      return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function(firstRow, lastRow) {
      return this.$moveLines(firstRow, lastRow, 0);
    };


    this.$clipRowToDocument = function(row) {
      return Math.max(0, Math.min(row, this.doc.getLength()-1));
    };

    this.$clipColumnToRow = function(row, column) {
      if (column < 0)
        return 0;
      return Math.min(this.doc.getLine(row).length, column);
    };


    this.$clipPositionToDocument = function(row, column) {
      column = Math.max(0, column);

      if (row < 0) {
        row = 0;
        column = 0;
      } else {
        var len = this.doc.getLength();
        if (row >= len) {
          row = len - 1;
          column = this.doc.getLine(len-1).length;
        } else {
          column = Math.min(this.doc.getLine(row).length, column);
        }
      }

      return {
        row: row,
        column: column
      };
    };

    this.$clipRangeToDocument = function(range) {
      if (range.start.row < 0) {
        range.start.row = 0;
        range.start.column = 0;
      } else {
        range.start.column = this.$clipColumnToRow(
          range.start.row,
          range.start.column
        );
      }

      var len = this.doc.getLength() - 1;
      if (range.end.row > len) {
        range.end.row = len;
        range.end.column = this.doc.getLine(len).length;
      } else {
        range.end.column = this.$clipColumnToRow(
          range.end.row,
          range.end.column
        );
      }
      return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
      min : null,
      max : null
    };
    this.setUseWrapMode = function(useWrapMode) {
      if (useWrapMode != this.$useWrapMode) {
        this.$useWrapMode = useWrapMode;
        this.$modified = true;
        this.$resetRowCache(0);
        if (useWrapMode) {
          var len = this.getLength();
          this.$wrapData = Array(len);
          this.$updateWrapData(0, len - 1);
        }

        this._signal("changeWrapMode");
      }
    };
    this.getUseWrapMode = function() {
      return this.$useWrapMode;
    };
    this.setWrapLimitRange = function(min, max) {
      if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
        this.$wrapLimitRange = { min: min, max: max };
        this.$modified = true;
        if (this.$useWrapMode)
          this._signal("changeWrapMode");
      }
    };
    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
      var limits = this.$wrapLimitRange;
      if (limits.max < 0)
        limits = {min: $printMargin, max: $printMargin};
      var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
      if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
        this.$wrapLimit = wrapLimit;
        this.$modified = true;
        if (this.$useWrapMode) {
          this.$updateWrapData(0, this.getLength() - 1);
          this.$resetRowCache(0);
          this._signal("changeWrapLimit");
        }
        return true;
      }
      return false;
    };

    this.$constrainWrapLimit = function(wrapLimit, min, max) {
      if (min)
        wrapLimit = Math.max(min, wrapLimit);

      if (max)
        wrapLimit = Math.min(max, wrapLimit);

      return wrapLimit;
    };
    this.getWrapLimit = function() {
      return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
      this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function() {
      return {
        min : this.$wrapLimitRange.min,
        max : this.$wrapLimitRange.max
      };
    };

    this.$updateInternalDataOnChange = function(delta) {
      var useWrapMode = this.$useWrapMode;
      var action = delta.action;
      var start = delta.start;
      var end = delta.end;
      var firstRow = start.row;
      var lastRow = end.row;
      var len = lastRow - firstRow;
      var removedFolds = null;

      this.$updating = true;
      if (len != 0) {
        if (action === "remove") {
          this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

          var foldLines = this.$foldData;
          removedFolds = this.getFoldsInRange(delta);
          this.removeFolds(removedFolds);

          var foldLine = this.getFoldLine(end.row);
          var idx = 0;
          if (foldLine) {
            foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
            foldLine.shiftRow(-len);

            var foldLineBefore = this.getFoldLine(firstRow);
            if (foldLineBefore && foldLineBefore !== foldLine) {
              foldLineBefore.merge(foldLine);
              foldLine = foldLineBefore;
            }
            idx = foldLines.indexOf(foldLine) + 1;
          }

          for (idx; idx < foldLines.length; idx++) {
            var foldLine = foldLines[idx];
            if (foldLine.start.row >= end.row) {
              foldLine.shiftRow(-len);
            }
          }

          lastRow = firstRow;
        } else {
          var args = Array(len);
          args.unshift(firstRow, 0);
          var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
          arr.splice.apply(arr, args);
          var foldLines = this.$foldData;
          var foldLine = this.getFoldLine(firstRow);
          var idx = 0;
          if (foldLine) {
            var cmp = foldLine.range.compareInside(start.row, start.column);
            if (cmp == 0) {
              foldLine = foldLine.split(start.row, start.column);
              if (foldLine) {
                foldLine.shiftRow(len);
                foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
              }
            } else
            if (cmp == -1) {
              foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
              foldLine.shiftRow(len);
            }
            idx = foldLines.indexOf(foldLine) + 1;
          }

          for (idx; idx < foldLines.length; idx++) {
            var foldLine = foldLines[idx];
            if (foldLine.start.row >= firstRow) {
              foldLine.shiftRow(len);
            }
          }
        }
      } else {
        len = Math.abs(delta.start.column - delta.end.column);
        if (action === "remove") {
          removedFolds = this.getFoldsInRange(delta);
          this.removeFolds(removedFolds);

          len = -len;
        }
        var foldLine = this.getFoldLine(firstRow);
        if (foldLine) {
          foldLine.addRemoveChars(firstRow, start.column, len);
        }
      }

      if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
        console.error("doc.getLength() and $wrapData.length have to be the same!");
      }
      this.$updating = false;

      if (useWrapMode)
        this.$updateWrapData(firstRow, lastRow);
      else
        this.$updateRowLengthCache(firstRow, lastRow);

      return removedFolds;
    };

    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
      this.$rowLengthCache[firstRow] = null;
      this.$rowLengthCache[lastRow] = null;
    };

    this.$updateWrapData = function(firstRow, lastRow) {
      var lines = this.doc.getAllLines();
      var tabSize = this.getTabSize();
      var wrapData = this.$wrapData;
      var wrapLimit = this.$wrapLimit;
      var tokens;
      var foldLine;

      var row = firstRow;
      lastRow = Math.min(lastRow, lines.length - 1);
      while (row <= lastRow) {
        foldLine = this.getFoldLine(row, foldLine);
        if (!foldLine) {
          tokens = this.$getDisplayTokens(lines[row]);
          wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
          row ++;
        } else {
          tokens = [];
          foldLine.walk(function(placeholder, row, column, lastColumn) {
              var walkTokens;
              if (placeholder != null) {
                walkTokens = this.$getDisplayTokens(
                  placeholder, tokens.length);
                walkTokens[0] = PLACEHOLDER_START;
                for (var i = 1; i < walkTokens.length; i++) {
                  walkTokens[i] = PLACEHOLDER_BODY;
                }
              } else {
                walkTokens = this.$getDisplayTokens(
                  lines[row].substring(lastColumn, column),
                  tokens.length);
              }
              tokens = tokens.concat(walkTokens);
            }.bind(this),
            foldLine.end.row,
            lines[foldLine.end.row].length + 1
          );

          wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
          row = foldLine.end.row + 1;
        }
      }
    };
    var CHAR = 1,
      CHAR_EXT = 2,
      PLACEHOLDER_START = 3,
      PLACEHOLDER_BODY =  4,
      PUNCTUATION = 9,
      SPACE = 10,
      TAB = 11,
      TAB_SPACE = 12;


    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
      if (tokens.length == 0) {
        return [];
      }

      var splits = [];
      var displayLength = tokens.length;
      var lastSplit = 0, lastDocSplit = 0;

      var isCode = this.$wrapAsCode;

      var indentedSoftWrap = this.$indentedSoftWrap;
      var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
      || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

      function getWrapIndent() {
        var indentation = 0;
        if (maxIndent === 0)
          return indentation;
        if (indentedSoftWrap) {
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (token == SPACE)
              indentation += 1;
            else if (token == TAB)
              indentation += tabSize;
            else if (token == TAB_SPACE)
              continue;
            else
              break;
          }
        }
        if (isCode && indentedSoftWrap !== false)
          indentation += tabSize;
        return Math.min(indentation, maxIndent);
      }
      function addSplit(screenPos) {
        var displayed = tokens.slice(lastSplit, screenPos);
        var len = displayed.length;
        displayed.join("")
          .replace(/12/g, function() {
            len -= 1;
          })
          .replace(/2/g, function() {
            len -= 1;
          });

        if (!splits.length) {
          indent = getWrapIndent();
          splits.indent = indent;
        }
        lastDocSplit += len;
        splits.push(lastDocSplit);
        lastSplit = screenPos;
      }
      var indent = 0;
      while (displayLength - lastSplit > wrapLimit - indent) {
        var split = lastSplit + wrapLimit - indent;
        if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
          addSplit(split);
          continue;
        }
        if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
          for (split; split != lastSplit - 1; split--) {
            if (tokens[split] == PLACEHOLDER_START) {
              break;
            }
          }
          if (split > lastSplit) {
            addSplit(split);
            continue;
          }
          split = lastSplit + wrapLimit;
          for (split; split < tokens.length; split++) {
            if (tokens[split] != PLACEHOLDER_BODY) {
              break;
            }
          }
          if (split == tokens.length) {
            break;  // Breaks the while-loop.
          }
          addSplit(split);
          continue;
        }
        var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
        while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
          split --;
        }
        if (isCode) {
          while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
            split --;
          }
          while (split > minSplit && tokens[split] == PUNCTUATION) {
            split --;
          }
        } else {
          while (split > minSplit && tokens[split] < SPACE) {
            split --;
          }
        }
        if (split > minSplit) {
          addSplit(++split);
          continue;
        }
        split = lastSplit + wrapLimit;
        if (tokens[split] == CHAR_EXT)
          split--;
        addSplit(split - indent);
      }
      return splits;
    };
    this.$getDisplayTokens = function(str, offset) {
      var arr = [];
      var tabSize;
      offset = offset || 0;

      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c == 9) {
          tabSize = this.getScreenTabSize(arr.length + offset);
          arr.push(TAB);
          for (var n = 1; n < tabSize; n++) {
            arr.push(TAB_SPACE);
          }
        }
        else if (c == 32) {
          arr.push(SPACE);
        } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
          arr.push(PUNCTUATION);
        }
        else if (c >= 0x1100 && isFullWidth(c)) {
          arr.push(CHAR, CHAR_EXT);
        } else {
          arr.push(CHAR);
        }
      }
      return arr;
    };
    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
      if (maxScreenColumn == 0)
        return [0, 0];
      if (maxScreenColumn == null)
        maxScreenColumn = Infinity;
      screenColumn = screenColumn || 0;

      var c, column;
      for (column = 0; column < str.length; column++) {
        c = str.charCodeAt(column);
        if (c == 9) {
          screenColumn += this.getScreenTabSize(screenColumn);
        }
        else if (c >= 0x1100 && isFullWidth(c)) {
          screenColumn += 2;
        } else {
          screenColumn += 1;
        }
        if (screenColumn > maxScreenColumn) {
          break;
        }
      }

      return [screenColumn, column];
    };

    this.lineWidgets = null;
    this.getRowLength = function(row) {
      if (this.lineWidgets)
        var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
      else
        h = 0
      if (!this.$useWrapMode || !this.$wrapData[row]) {
        return 1 + h;
      } else {
        return this.$wrapData[row].length + 1 + h;
      }
    };
    this.getRowLineCount = function(row) {
      if (!this.$useWrapMode || !this.$wrapData[row]) {
        return 1;
      } else {
        return this.$wrapData[row].length + 1;
      }
    };

    this.getRowWrapIndent = function(screenRow) {
      if (this.$useWrapMode) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        var splits = this.$wrapData[pos.row];
        return splits.length && splits[0] < pos.column ? splits.indent : 0;
      } else {
        return 0;
      }
    }
    this.getScreenLastRowColumn = function(screenRow) {
      var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
      return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function(docRow, docColumn) {
      var screenRow = this.documentToScreenRow(docRow, docColumn);
      return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
      var screenRow = this.documentToScreenRow(docRow, docColumn);
      return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function(row) {
      if (!this.$useWrapMode) {
        return undefined;
      } else {
        return this.$wrapData[row];
      }
    };
    this.getScreenTabSize = function(screenColumn) {
      return this.$tabSize - screenColumn % this.$tabSize;
    };


    this.screenToDocumentRow = function(screenRow, screenColumn) {
      return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };


    this.screenToDocumentColumn = function(screenRow, screenColumn) {
      return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function(screenRow, screenColumn) {
      if (screenRow < 0)
        return {row: 0, column: 0};

      var line;
      var docRow = 0;
      var docColumn = 0;
      var column;
      var row = 0;
      var rowLength = 0;

      var rowCache = this.$screenRowCache;
      var i = this.$getRowCacheIndex(rowCache, screenRow);
      var l = rowCache.length;
      if (l && i >= 0) {
        var row = rowCache[i];
        var docRow = this.$docRowCache[i];
        var doCache = screenRow > rowCache[l - 1];
      } else {
        var doCache = !l;
      }

      var maxRow = this.getLength() - 1;
      var foldLine = this.getNextFoldLine(docRow);
      var foldStart = foldLine ? foldLine.start.row : Infinity;

      while (row <= screenRow) {
        rowLength = this.getRowLength(docRow);
        if (row + rowLength > screenRow || docRow >= maxRow) {
          break;
        } else {
          row += rowLength;
          docRow++;
          if (docRow > foldStart) {
            docRow = foldLine.end.row+1;
            foldLine = this.getNextFoldLine(docRow, foldLine);
            foldStart = foldLine ? foldLine.start.row : Infinity;
          }
        }

        if (doCache) {
          this.$docRowCache.push(docRow);
          this.$screenRowCache.push(row);
        }
      }

      if (foldLine && foldLine.start.row <= docRow) {
        line = this.getFoldDisplayLine(foldLine);
        docRow = foldLine.start.row;
      } else if (row + rowLength <= screenRow || docRow > maxRow) {
        return {
          row: maxRow,
          column: this.getLine(maxRow).length
        };
      } else {
        line = this.getLine(docRow);
        foldLine = null;
      }
      var wrapIndent = 0;
      if (this.$useWrapMode) {
        var splits = this.$wrapData[docRow];
        if (splits) {
          var splitIndex = Math.floor(screenRow - row);
          column = splits[splitIndex];
          if(splitIndex > 0 && splits.length) {
            wrapIndent = splits.indent;
            docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
            line = line.substring(docColumn);
          }
        }
      }

      docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
      if (this.$useWrapMode && docColumn >= column)
        docColumn = column - 1;

      if (foldLine)
        return foldLine.idxToPosition(docColumn);

      return {row: docRow, column: docColumn};
    };
    this.documentToScreenPosition = function(docRow, docColumn) {
      if (typeof docColumn === "undefined")
        var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
      else
        pos = this.$clipPositionToDocument(docRow, docColumn);

      docRow = pos.row;
      docColumn = pos.column;

      var screenRow = 0;
      var foldStartRow = null;
      var fold = null;
      fold = this.getFoldAt(docRow, docColumn, 1);
      if (fold) {
        docRow = fold.start.row;
        docColumn = fold.start.column;
      }

      var rowEnd, row = 0;


      var rowCache = this.$docRowCache;
      var i = this.$getRowCacheIndex(rowCache, docRow);
      var l = rowCache.length;
      if (l && i >= 0) {
        var row = rowCache[i];
        var screenRow = this.$screenRowCache[i];
        var doCache = docRow > rowCache[l - 1];
      } else {
        var doCache = !l;
      }

      var foldLine = this.getNextFoldLine(row);
      var foldStart = foldLine ?foldLine.start.row :Infinity;

      while (row < docRow) {
        if (row >= foldStart) {
          rowEnd = foldLine.end.row + 1;
          if (rowEnd > docRow)
            break;
          foldLine = this.getNextFoldLine(rowEnd, foldLine);
          foldStart = foldLine ?foldLine.start.row :Infinity;
        }
        else {
          rowEnd = row + 1;
        }

        screenRow += this.getRowLength(row);
        row = rowEnd;

        if (doCache) {
          this.$docRowCache.push(row);
          this.$screenRowCache.push(screenRow);
        }
      }
      var textLine = "";
      if (foldLine && row >= foldStart) {
        textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
        foldStartRow = foldLine.start.row;
      } else {
        textLine = this.getLine(docRow).substring(0, docColumn);
        foldStartRow = docRow;
      }
      var wrapIndent = 0;
      if (this.$useWrapMode) {
        var wrapRow = this.$wrapData[foldStartRow];
        if (wrapRow) {
          var screenRowOffset = 0;
          while (textLine.length >= wrapRow[screenRowOffset]) {
            screenRow ++;
            screenRowOffset++;
          }
          textLine = textLine.substring(
            wrapRow[screenRowOffset - 1] || 0, textLine.length
          );
          wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
        }
      }

      return {
        row: screenRow,
        column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
      };
    };
    this.documentToScreenColumn = function(row, docColumn) {
      return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function(docRow, docColumn) {
      return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function() {
      var screenRows = 0;
      var fold = null;
      if (!this.$useWrapMode) {
        screenRows = this.getLength();
        var foldData = this.$foldData;
        for (var i = 0; i < foldData.length; i++) {
          fold = foldData[i];
          screenRows -= fold.end.row - fold.start.row;
        }
      } else {
        var lastRow = this.$wrapData.length;
        var row = 0, i = 0;
        var fold = this.$foldData[i++];
        var foldStart = fold ? fold.start.row :Infinity;

        while (row < lastRow) {
          var splits = this.$wrapData[row];
          screenRows += splits ? splits.length + 1 : 1;
          row ++;
          if (row > foldStart) {
            row = fold.end.row+1;
            fold = this.$foldData[i++];
            foldStart = fold ?fold.start.row :Infinity;
          }
        }
      }
      if (this.lineWidgets)
        screenRows += this.$getWidgetScreenLength();

      return screenRows;
    };
    this.$setFontMetrics = function(fm) {
      if (!this.$enableVarChar) return;
      this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn === 0)
          return [0, 0];
        if (!maxScreenColumn)
          maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
          c = str.charAt(column);
          if (c === "\t") {
            screenColumn += this.getScreenTabSize(screenColumn);
          } else {
            screenColumn += fm.getCharacterWidth(c);
          }
          if (screenColumn > maxScreenColumn) {
            break;
          }
        }

        return [screenColumn, column];
      };
    };

    this.destroy = function() {
      if (this.bgTokenizer) {
        this.bgTokenizer.setDocument(null);
        this.bgTokenizer = null;
      }
      this.$stopWorker();
    };
    function isFullWidth(c) {
      if (c < 0x1100)
        return false;
      return c >= 0x1100 && c <= 0x115F ||
        c >= 0x11A3 && c <= 0x11A7 ||
        c >= 0x11FA && c <= 0x11FF ||
        c >= 0x2329 && c <= 0x232A ||
        c >= 0x2E80 && c <= 0x2E99 ||
        c >= 0x2E9B && c <= 0x2EF3 ||
        c >= 0x2F00 && c <= 0x2FD5 ||
        c >= 0x2FF0 && c <= 0x2FFB ||
        c >= 0x3000 && c <= 0x303E ||
        c >= 0x3041 && c <= 0x3096 ||
        c >= 0x3099 && c <= 0x30FF ||
        c >= 0x3105 && c <= 0x312D ||
        c >= 0x3131 && c <= 0x318E ||
        c >= 0x3190 && c <= 0x31BA ||
        c >= 0x31C0 && c <= 0x31E3 ||
        c >= 0x31F0 && c <= 0x321E ||
        c >= 0x3220 && c <= 0x3247 ||
        c >= 0x3250 && c <= 0x32FE ||
        c >= 0x3300 && c <= 0x4DBF ||
        c >= 0x4E00 && c <= 0xA48C ||
        c >= 0xA490 && c <= 0xA4C6 ||
        c >= 0xA960 && c <= 0xA97C ||
        c >= 0xAC00 && c <= 0xD7A3 ||
        c >= 0xD7B0 && c <= 0xD7C6 ||
        c >= 0xD7CB && c <= 0xD7FB ||
        c >= 0xF900 && c <= 0xFAFF ||
        c >= 0xFE10 && c <= 0xFE19 ||
        c >= 0xFE30 && c <= 0xFE52 ||
        c >= 0xFE54 && c <= 0xFE66 ||
        c >= 0xFE68 && c <= 0xFE6B ||
        c >= 0xFF01 && c <= 0xFF60 ||
        c >= 0xFFE0 && c <= 0xFFE6;
    }

  }).call(EditSession.prototype);

  require("./edit_session/folding").Folding.call(EditSession.prototype);
  require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


  config.defineOptions(EditSession.prototype, "session", {
    wrap: {
      set: function(value) {
        if (!value || value == "off")
          value = false;
        else if (value == "free")
          value = true;
        else if (value == "printMargin")
          value = -1;
        else if (typeof value == "string")
          value = parseInt(value, 10) || false;

        if (this.$wrap == value)
          return;
        this.$wrap = value;
        if (!value) {
          this.setUseWrapMode(false);
        } else {
          var col = typeof value == "number" ? value : null;
          this.setWrapLimitRange(col, col);
          this.setUseWrapMode(true);
        }
      },
      get: function() {
        if (this.getUseWrapMode()) {
          if (this.$wrap == -1)
            return "printMargin";
          if (!this.getWrapLimitRange().min)
            return "free";
          return this.$wrap;
        }
        return "off";
      },
      handlesSet: true
    },
    wrapMethod: {
      set: function(val) {
        val = val == "auto"
          ? this.$mode.type != "text"
          : val != "text";
        if (val != this.$wrapAsCode) {
          this.$wrapAsCode = val;
          if (this.$useWrapMode) {
            this.$modified = true;
            this.$resetRowCache(0);
            this.$updateWrapData(0, this.getLength() - 1);
          }
        }
      },
      initialValue: "auto"
    },
    indentedSoftWrap: { initialValue: true },
    firstLineNumber: {
      set: function() {this._signal("changeBreakpoint");},
      initialValue: 1
    },
    useWorker: {
      set: function(useWorker) {
        this.$useWorker = useWorker;

        this.$stopWorker();
        if (useWorker)
          this.$startWorker();
      },
      initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
      set: function(tabSize) {
        if (isNaN(tabSize) || this.$tabSize === tabSize) return;

        this.$modified = true;
        this.$rowLengthCache = [];
        this.$tabSize = tabSize;
        this._signal("changeTabSize");
      },
      initialValue: 4,
      handlesSet: true
    },
    overwrite: {
      set: function(val) {this._signal("changeOverwrite");},
      initialValue: false
    },
    newLineMode: {
      set: function(val) {this.doc.setNewLineMode(val)},
      get: function() {return this.doc.getNewLineMode()},
      handlesSet: true
    },
    mode: {
      set: function(val) { this.setMode(val) },
      get: function() { return this.$modeId }
    }
  });

  exports.EditSession = EditSession;
});

ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {
  "use strict";

  var lang = require("./lib/lang");
  var oop = require("./lib/oop");
  var Range = require("./range").Range;

  var Search = function() {
    this.$options = {};
  };

  (function() {
    this.set = function(options) {
      oop.mixin(this.$options, options);
      return this;
    };
    this.getOptions = function() {
      return lang.copyObject(this.$options);
    };
    this.setOptions = function(options) {
      this.$options = options;
    };
    this.find = function(session) {
      var options = this.$options;
      var iterator = this.$matchIterator(session, options);
      if (!iterator)
        return false;

      var firstRange = null;
      iterator.forEach(function(range, row, offset) {
        if (!range.start) {
          var column = range.offset + (offset || 0);
          firstRange = new Range(row, column, row, column + range.length);
          if (!range.length && options.start && options.start.start
            && options.skipCurrent != false && firstRange.isEqual(options.start)
          ) {
            firstRange = null;
            return false;
          }
        } else
          firstRange = range;
        return true;
      });

      return firstRange;
    };
    this.findAll = function(session) {
      var options = this.$options;
      if (!options.needle)
        return [];
      this.$assembleRegExp(options);

      var range = options.range;
      var lines = range
        ? session.getLines(range.start.row, range.end.row)
        : session.doc.getAllLines();

      var ranges = [];
      var re = options.re;
      if (options.$isMultiLine) {
        var len = re.length;
        var maxRow = lines.length - len;
        var prevRange;
        outer: for (var row = re.offset || 0; row <= maxRow; row++) {
          for (var j = 0; j < len; j++)
            if (lines[row + j].search(re[j]) == -1)
              continue outer;

          var startLine = lines[row];
          var line = lines[row + len - 1];
          var startIndex = startLine.length - startLine.match(re[0])[0].length;
          var endIndex = line.match(re[len - 1])[0].length;

          if (prevRange && prevRange.end.row === row &&
            prevRange.end.column > startIndex
          ) {
            continue;
          }
          ranges.push(prevRange = new Range(
            row, startIndex, row + len - 1, endIndex
          ));
          if (len > 2)
            row = row + len - 2;
        }
      } else {
        for (var i = 0; i < lines.length; i++) {
          var matches = lang.getMatchOffsets(lines[i], re);
          for (var j = 0; j < matches.length; j++) {
            var match = matches[j];
            ranges.push(new Range(i, match.offset, i, match.offset + match.length));
          }
        }
      }

      if (range) {
        var startColumn = range.start.column;
        var endColumn = range.start.column;
        var i = 0, j = ranges.length - 1;
        while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
          i++;

        while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
          j--;

        ranges = ranges.slice(i, j + 1);
        for (i = 0, j = ranges.length; i < j; i++) {
          ranges[i].start.row += range.start.row;
          ranges[i].end.row += range.start.row;
        }
      }

      return ranges;
    };
    this.replace = function(input, replacement) {
      var options = this.$options;

      var re = this.$assembleRegExp(options);
      if (options.$isMultiLine)
        return replacement;

      if (!re)
        return;

      var match = re.exec(input);
      if (!match || match[0].length != input.length)
        return null;

      replacement = input.replace(re, replacement);
      if (options.preserveCase) {
        replacement = replacement.split("");
        for (var i = Math.min(input.length, input.length); i--; ) {
          var ch = input[i];
          if (ch && ch.toLowerCase() != ch)
            replacement[i] = replacement[i].toUpperCase();
          else
            replacement[i] = replacement[i].toLowerCase();
        }
        replacement = replacement.join("");
      }

      return replacement;
    };

    this.$matchIterator = function(session, options) {
      var re = this.$assembleRegExp(options);
      if (!re)
        return false;

      var callback;
      if (options.$isMultiLine) {
        var len = re.length;
        var matchIterator = function(line, row, offset) {
          var startIndex = line.search(re[0]);
          if (startIndex == -1)
            return;
          for (var i = 1; i < len; i++) {
            line = session.getLine(row + i);
            if (line.search(re[i]) == -1)
              return;
          }

          var endIndex = line.match(re[len - 1])[0].length;

          var range = new Range(row, startIndex, row + len - 1, endIndex);
          if (re.offset == 1) {
            range.start.row--;
            range.start.column = Number.MAX_VALUE;
          } else if (offset)
            range.start.column += offset;

          if (callback(range))
            return true;
        };
      } else if (options.backwards) {
        var matchIterator = function(line, row, startIndex) {
          var matches = lang.getMatchOffsets(line, re);
          for (var i = matches.length-1; i >= 0; i--)
            if (callback(matches[i], row, startIndex))
              return true;
        };
      } else {
        var matchIterator = function(line, row, startIndex) {
          var matches = lang.getMatchOffsets(line, re);
          for (var i = 0; i < matches.length; i++)
            if (callback(matches[i], row, startIndex))
              return true;
        };
      }

      var lineIterator = this.$lineIterator(session, options);

      return {
        forEach: function(_callback) {
          callback = _callback;
          lineIterator.forEach(matchIterator);
        }
      };
    };

    this.$assembleRegExp = function(options, $disableFakeMultiline) {
      if (options.needle instanceof RegExp)
        return options.re = options.needle;

      var needle = options.needle;

      if (!options.needle)
        return options.re = false;

      if (!options.regExp)
        needle = lang.escapeRegExp(needle);

      if (options.wholeWord)
        needle = addWordBoundary(needle, options);

      var modifier = options.caseSensitive ? "gm" : "gmi";

      options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
      if (options.$isMultiLine)
        return options.re = this.$assembleMultilineRegExp(needle, modifier);

      try {
        var re = new RegExp(needle, modifier);
      } catch(e) {
        re = false;
      }
      return options.re = re;
    };

    this.$assembleMultilineRegExp = function(needle, modifier) {
      var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
      var re = [];
      for (var i = 0; i < parts.length; i++) try {
        re.push(new RegExp(parts[i], modifier));
      } catch(e) {
        return false;
      }
      if (parts[0] == "") {
        re.shift();
        re.offset = 1;
      } else {
        re.offset = 0;
      }
      return re;
    };

    this.$lineIterator = function(session, options) {
      var backwards = options.backwards == true;
      var skipCurrent = options.skipCurrent != false;

      var range = options.range;
      var start = options.start;
      if (!start)
        start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();

      if (start.start)
        start = start[skipCurrent != backwards ? "end" : "start"];

      var firstRow = range ? range.start.row : 0;
      var lastRow = range ? range.end.row : session.getLength() - 1;

      var forEach = backwards ? function(callback) {
          var row = start.row;

          var line = session.getLine(row).substring(0, start.column);
          if (callback(line, row))
            return;

          for (row--; row >= firstRow; row--)
            if (callback(session.getLine(row), row))
              return;

          if (options.wrap == false)
            return;

          for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
            if (callback(session.getLine(row), row))
              return;
        } : function(callback) {
          var row = start.row;

          var line = session.getLine(row).substr(start.column);
          if (callback(line, row, start.column))
            return;

          for (row = row+1; row <= lastRow; row++)
            if (callback(session.getLine(row), row))
              return;

          if (options.wrap == false)
            return;

          for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
            if (callback(session.getLine(row), row))
              return;
        };

      return {forEach: forEach};
    };

  }).call(Search.prototype);

  function addWordBoundary(needle, options) {
    function wordBoundary(c) {
      if (/\w/.test(c) || options.regExp) return "\\b";
      return "";
    }
    return wordBoundary(needle[0]) + needle
      + wordBoundary(needle[needle.length - 1]);
  }

  exports.Search = Search;
});

ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {
  "use strict";

  var keyUtil = require("../lib/keys");
  var useragent = require("../lib/useragent");
  var KEY_MODS = keyUtil.KEY_MODS;

  function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? "mac" : "win");
    this.commands = {};
    this.commandKeyBinding = {};
    this.addCommands(config);
    this.$singleCommand = true;
  }

  function MultiHashHandler(config, platform) {
    HashHandler.call(this, config, platform);
    this.$singleCommand = false;
  }

  MultiHashHandler.prototype = HashHandler.prototype;

  (function() {


    this.addCommand = function(command) {
      if (this.commands[command.name])
        this.removeCommand(command);

      this.commands[command.name] = command;

      if (command.bindKey)
        this._buildKeyHash(command);
    };

    this.removeCommand = function(command, keepCommand) {
      var name = command && (typeof command === 'string' ? command : command.name);
      command = this.commands[name];
      if (!keepCommand)
        delete this.commands[name];
      var ckb = this.commandKeyBinding;
      for (var keyId in ckb) {
        var cmdGroup = ckb[keyId];
        if (cmdGroup == command) {
          delete ckb[keyId];
        } else if (Array.isArray(cmdGroup)) {
          var i = cmdGroup.indexOf(command);
          if (i != -1) {
            cmdGroup.splice(i, 1);
            if (cmdGroup.length == 1)
              ckb[keyId] = cmdGroup[0];
          }
        }
      }
    };

    this.bindKey = function(key, command, position) {
      if (typeof key == "object" && key) {
        if (position == undefined)
          position = key.position;
        key = key[this.platform];
      }
      if (!key)
        return;
      if (typeof command == "function")
        return this.addCommand({exec: command, bindKey: key, name: command.name || key});

      key.split("|").forEach(function(keyPart) {
        var chain = "";
        if (keyPart.indexOf(" ") != -1) {
          var parts = keyPart.split(/\s+/);
          keyPart = parts.pop();
          parts.forEach(function(keyPart) {
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            chain += (chain ? " " : "") + id;
            this._addCommandToBinding(chain, "chainKeys");
          }, this);
          chain += " ";
        }
        var binding = this.parseKeys(keyPart);
        var id = KEY_MODS[binding.hashId] + binding.key;
        this._addCommandToBinding(chain + id, command, position);
      }, this);
    };

    function getPosition(command) {
      return typeof command == "object" && command.bindKey
        && command.bindKey.position || 0;
    }
    this._addCommandToBinding = function(keyId, command, position) {
      var ckb = this.commandKeyBinding, i;
      if (!command) {
        delete ckb[keyId];
      } else if (!ckb[keyId] || this.$singleCommand) {
        ckb[keyId] = command;
      } else {
        if (!Array.isArray(ckb[keyId])) {
          ckb[keyId] = [ckb[keyId]];
        } else if ((i = ckb[keyId].indexOf(command)) != -1) {
          ckb[keyId].splice(i, 1);
        }

        if (typeof position != "number") {
          if (position || command.isDefault)
            position = -100;
          else
            position = getPosition(command);
        }
        var commands = ckb[keyId];
        for (i = 0; i < commands.length; i++) {
          var other = commands[i];
          var otherPos = getPosition(other);
          if (otherPos > position)
            break;
        }
        commands.splice(i, 0, command);
      }
    };

    this.addCommands = function(commands) {
      commands && Object.keys(commands).forEach(function(name) {
        var command = commands[name];
        if (!command)
          return;

        if (typeof command === "string")
          return this.bindKey(command, name);

        if (typeof command === "function")
          command = { exec: command };

        if (typeof command !== "object")
          return;

        if (!command.name)
          command.name = name;

        this.addCommand(command);
      }, this);
    };

    this.removeCommands = function(commands) {
      Object.keys(commands).forEach(function(name) {
        this.removeCommand(commands[name]);
      }, this);
    };

    this.bindKeys = function(keyList) {
      Object.keys(keyList).forEach(function(key) {
        this.bindKey(key, keyList[key]);
      }, this);
    };

    this._buildKeyHash = function(command) {
      this.bindKey(command.bindKey, command);
    };
    this.parseKeys = function(keys) {
      var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
      var key = parts.pop();

      var keyCode = keyUtil[key];
      if (keyUtil.FUNCTION_KEYS[keyCode])
        key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
      else if (!parts.length)
        return {key: key, hashId: -1};
      else if (parts.length == 1 && parts[0] == "shift")
        return {key: key.toUpperCase(), hashId: -1};

      var hashId = 0;
      for (var i = parts.length; i--;) {
        var modifier = keyUtil.KEY_MODS[parts[i]];
        if (modifier == null) {
          if (typeof console != "undefined")
            console.error("invalid modifier " + parts[i] + " in " + keys);
          return false;
        }
        hashId |= modifier;
      }
      return {key: key, hashId: hashId};
    };

    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
      var key = KEY_MODS[hashId] + keyString;
      return this.commandKeyBinding[key];
    };

    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
      if (keyCode < 0) return;
      var key = KEY_MODS[hashId] + keyString;
      var command = this.commandKeyBinding[key];
      if (data.$keyChain) {
        data.$keyChain += " " + key;
        command = this.commandKeyBinding[data.$keyChain] || command;
      }

      if (command) {
        if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
          data.$keyChain = data.$keyChain || key;
          return {command: "null"};
        }
      }

      if (data.$keyChain) {
        if ((!hashId || hashId == 4) && keyString.length == 1)
          data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
        else if (hashId == -1 || keyCode > 0)
          data.$keyChain = ""; // reset keyChain
      }
      return {command: command};
    };

    this.getStatusText = function(editor, data) {
      return data.$keyChain || "";
    };

  }).call(HashHandler.prototype);

  exports.HashHandler = HashHandler;
  exports.MultiHashHandler = MultiHashHandler;
});

ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(require, exports, module) {
  "use strict";

  var oop = require("../lib/oop");
  var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
  var EventEmitter = require("../lib/event_emitter").EventEmitter;

  var CommandManager = function(platform, commands) {
    MultiHashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler("exec", function(e) {
      return e.command.exec(e.editor, e.args || {});
    });
  };

  oop.inherits(CommandManager, MultiHashHandler);

  (function() {

    oop.implement(this, EventEmitter);

    this.exec = function(command, editor, args) {
      if (Array.isArray(command)) {
        for (var i = command.length; i--; ) {
          if (this.exec(command[i], editor, args)) return true;
        }
        return false;
      }

      if (typeof command === "string")
        command = this.commands[command];

      if (!command)
        return false;

      if (editor && editor.$readOnly && !command.readOnly)
        return false;

      var e = {editor: editor, command: command, args: args};
      e.returnValue = this._emit("exec", e);
      this._signal("afterExec", e);

      return e.returnValue === false ? false : true;
    };

    this.toggleRecording = function(editor) {
      if (this.$inReplay)
        return;

      editor && editor._emit("changeStatus");
      if (this.recording) {
        this.macro.pop();
        this.removeEventListener("exec", this.$addCommandToMacro);

        if (!this.macro.length)
          this.macro = this.oldMacro;

        return this.recording = false;
      }
      if (!this.$addCommandToMacro) {
        this.$addCommandToMacro = function(e) {
          this.macro.push([e.command, e.args]);
        }.bind(this);
      }

      this.oldMacro = this.macro;
      this.macro = [];
      this.on("exec", this.$addCommandToMacro);
      return this.recording = true;
    };

    this.replay = function(editor) {
      if (this.$inReplay || !this.macro)
        return;

      if (this.recording)
        return this.toggleRecording(editor);

      try {
        this.$inReplay = true;
        this.macro.forEach(function(x) {
          if (typeof x == "string")
            this.exec(x, editor);
          else
            this.exec(x[0], editor, x[1]);
        }, this);
      } finally {
        this.$inReplay = false;
      }
    };

    this.trimMacro = function(m) {
      return m.map(function(x){
        if (typeof x[0] != "string")
          x[0] = x[0].name;
        if (!x[1])
          x = x[0];
        return x;
      });
    };

  }).call(CommandManager.prototype);

  exports.CommandManager = CommandManager;

});

ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(require, exports, module) {
  "use strict";

  var lang = require("../lib/lang");
  var config = require("../config");
  var Range = require("../range").Range;

  function bindKey(win, mac) {
    return {win: win, mac: mac};
  }
  exports.commands = [{
    name: "showSettingsMenu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
      config.loadModule("ace/ext/settings_menu", function(module) {
        module.init(editor);
        editor.showSettingsMenu();
      });
    },
    readOnly: true
  }, {
    name: "goToNextError",
    bindKey: bindKey("Alt-E", "F4"),
    exec: function(editor) {
      config.loadModule("ace/ext/error_marker", function(module) {
        module.showErrorMarker(editor, 1);
      });
    },
    scrollIntoView: "animate",
    readOnly: true
  }, {
    name: "goToPreviousError",
    bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
    exec: function(editor) {
      config.loadModule("ace/ext/error_marker", function(module) {
        module.showErrorMarker(editor, -1);
      });
    },
    scrollIntoView: "animate",
    readOnly: true
  }, {
    name: "selectall",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
  }, {
    name: "centerselection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
  }, {
    name: "gotoline",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor) {
      var line = parseInt(prompt("Enter line number:"), 10);
      if (!isNaN(line)) {
        editor.gotoLine(line);
      }
    },
    readOnly: true
  }, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "toggleFoldWidget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "toggleParentFoldWidget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "foldall",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "foldOther",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) {
      editor.session.foldAll();
      editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "unfoldall",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "findnext",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "findprevious",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
  }, {
    name: "selectOrFindNext",
    bindKey: bindKey("Alt-K", "Ctrl-G"),
    exec: function(editor) {
      if (editor.selection.isEmpty())
        editor.selection.selectWord();
      else
        editor.findNext();
    },
    readOnly: true
  }, {
    name: "selectOrFindPrevious",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) {
      if (editor.selection.isEmpty())
        editor.selection.selectWord();
      else
        editor.findPrevious();
    },
    readOnly: true
  }, {
    name: "find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
      config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor)});
    },
    readOnly: true
  }, {
    name: "overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
  }, {
    name: "selecttostart",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
  }, {
    name: "gotostart",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
  }, {
    name: "selectup",
    bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "golineup",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selecttoend",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
  }, {
    name: "gotoend",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
  }, {
    name: "selectdown",
    bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "golinedown",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectwordleft",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "gotowordleft",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selecttolinestart",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "gotolinestart",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectleft",
    bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "gotoleft",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectwordright",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "gotowordright",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selecttolineend",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "gotolineend",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectright",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "gotoright",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectpagedown",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
  }, {
    name: "pagedown",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
  }, {
    name: "gotopagedown",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
  }, {
    name: "selectpageup",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
  }, {
    name: "pageup",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
  }, {
    name: "gotopageup",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
  }, {
    name: "scrollup",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
  }, {
    name: "scrolldown",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
  }, {
    name: "selectlinestart",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectlineend",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "togglerecording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
  }, {
    name: "replaymacro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
  }, {
    name: "jumptomatching",
    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
  }, {
    name: "selecttomatching",
    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
  }, {
    name: "expandToMatching",
    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
    exec: function(editor) { editor.jumpToMatching(true, true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
  }, {
    name: "passKeysToBrowser",
    bindKey: bindKey(null, null),
    exec: function() {},
    passEvent: true,
    readOnly: true
  }, {
    name: "copy",
    exec: function(editor) {
    },
    readOnly: true
  },
    {
      name: "cut",
      exec: function(editor) {
        var range = editor.getSelectionRange();
        editor._emit("cut", range);

        if (!editor.selection.isEmpty()) {
          editor.session.remove(range);
          editor.clearSelection();
        }
      },
      scrollIntoView: "cursor",
      multiSelectAction: "forEach"
    }, {
      name: "paste",
      exec: function(editor, args) {
        editor.$handlePaste(args);
      },
      scrollIntoView: "cursor"
    }, {
      name: "removeline",
      bindKey: bindKey("Ctrl-D", "Command-D"),
      exec: function(editor) { editor.removeLines(); },
      scrollIntoView: "cursor",
      multiSelectAction: "forEachLine"
    }, {
      name: "duplicateSelection",
      bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
      exec: function(editor) { editor.duplicateSelection(); },
      scrollIntoView: "cursor",
      multiSelectAction: "forEach"
    }, {
      name: "sortlines",
      bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
      exec: function(editor) { editor.sortLines(); },
      scrollIntoView: "selection",
      multiSelectAction: "forEachLine"
    }, {
      name: "togglecomment",
      bindKey: bindKey("Ctrl-/", "Command-/"),
      exec: function(editor) { editor.toggleCommentLines(); },
      multiSelectAction: "forEachLine",
      scrollIntoView: "selectionPart"
    }, {
      name: "toggleBlockComment",
      bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
      exec: function(editor) { editor.toggleBlockComment(); },
      multiSelectAction: "forEach",
      scrollIntoView: "selectionPart"
    }, {
      name: "modifyNumberUp",
      bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
      exec: function(editor) { editor.modifyNumber(1); },
      scrollIntoView: "cursor",
      multiSelectAction: "forEach"
    }, {
      name: "modifyNumberDown",
      bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
      exec: function(editor) { editor.modifyNumber(-1); },
      scrollIntoView: "cursor",
      multiSelectAction: "forEach"
    }, {
      name: "replace",
      bindKey: bindKey("Ctrl-H", "Command-Option-F"),
      exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
      }
    }, {
      name: "undo",
      bindKey: bindKey("Ctrl-Z", "Command-Z"),
      exec: function(editor) { editor.undo(); }
    }, {
      name: "redo",
      bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
      exec: function(editor) { editor.redo(); }
    }, {
      name: "copylinesup",
      bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
      exec: function(editor) { editor.copyLinesUp(); },
      scrollIntoView: "cursor"
    }, {
      name: "movelinesup",
      bindKey: bindKey("Alt-Up", "Option-Up"),
      exec: function(editor) { editor.moveLinesUp(); },
      scrollIntoView: "cursor"
    }, {
      name: "copylinesdown",
      bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
      exec: function(editor) { editor.copyLinesDown(); },
      scrollIntoView: "cursor"
    }, {
      name: "movelinesdown",
      bindKey: bindKey("Alt-Down", "Option-Down"),
      exec: function(editor) { editor.moveLinesDown(); },
      scrollIntoView: "cursor"
    }, {
      name: "del",
      bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
      exec: function(editor) { editor.remove("right"); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "backspace",
      bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
      ),
      exec: function(editor) { editor.remove("left"); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "cut_or_delete",
      bindKey: bindKey("Shift-Delete", null),
      exec: function(editor) {
        if (editor.selection.isEmpty()) {
          editor.remove("left");
        } else {
          return false;
        }
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "removetolinestart",
      bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
      exec: function(editor) { editor.removeToLineStart(); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "removetolineend",
      bindKey: bindKey("Alt-Delete", "Ctrl-K"),
      exec: function(editor) { editor.removeToLineEnd(); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "removewordleft",
      bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
      exec: function(editor) { editor.removeWordLeft(); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "removewordright",
      bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
      exec: function(editor) { editor.removeWordRight(); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "outdent",
      bindKey: bindKey("Shift-Tab", "Shift-Tab"),
      exec: function(editor) { editor.blockOutdent(); },
      multiSelectAction: "forEach",
      scrollIntoView: "selectionPart"
    }, {
      name: "indent",
      bindKey: bindKey("Tab", "Tab"),
      exec: function(editor) { editor.indent(); },
      multiSelectAction: "forEach",
      scrollIntoView: "selectionPart"
    }, {
      name: "blockoutdent",
      bindKey: bindKey("Ctrl-[", "Ctrl-["),
      exec: function(editor) { editor.blockOutdent(); },
      multiSelectAction: "forEachLine",
      scrollIntoView: "selectionPart"
    }, {
      name: "blockindent",
      bindKey: bindKey("Ctrl-]", "Ctrl-]"),
      exec: function(editor) { editor.blockIndent(); },
      multiSelectAction: "forEachLine",
      scrollIntoView: "selectionPart"
    }, {
      name: "insertstring",
      exec: function(editor, str) { editor.insert(str); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "inserttext",
      exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "splitline",
      bindKey: bindKey(null, "Ctrl-O"),
      exec: function(editor) { editor.splitLine(); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "transposeletters",
      bindKey: bindKey("Ctrl-T", "Ctrl-T"),
      exec: function(editor) { editor.transposeLetters(); },
      multiSelectAction: function(editor) {editor.transposeSelections(1); },
      scrollIntoView: "cursor"
    }, {
      name: "touppercase",
      bindKey: bindKey("Ctrl-U", "Ctrl-U"),
      exec: function(editor) { editor.toUpperCase(); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "tolowercase",
      bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
      exec: function(editor) { editor.toLowerCase(); },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "expandtoline",
      bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
      exec: function(editor) {
        var range = editor.selection.getRange();

        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "joinlines",
      bindKey: bindKey(null, null),
      exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);

        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
          var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
          if (curLine.length !== 0) {
            curLine = " " + curLine;
          }
          insertLine += curLine;
        }

        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
          insertLine += editor.session.doc.getNewLineCharacter();
        }

        editor.clearSelection();
        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

        if (selectedCount > 0) {
          editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
          editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
          firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
          editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
      },
      multiSelectAction: "forEach",
      readOnly: true
    }, {
      name: "invertSelection",
      bindKey: bindKey(null, null),
      exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];
        if (ranges.length < 1) {
          ranges = [editor.selection.getRange()];
        }

        for (var i = 0; i < ranges.length; i++) {
          if (i == (ranges.length - 1)) {
            if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
              newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
            }
          }

          if (i === 0) {
            if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
              newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
            }
          } else {
            newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
          }
        }

        editor.exitMultiSelectMode();
        editor.clearSelection();

        for(var i = 0; i < newRanges.length; i++) {
          editor.selection.addRange(newRanges[i], false);
        }
      },
      readOnly: true,
      scrollIntoView: "none"
    }];

});

ace.define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator"], function(require, exports, module) {
  "use strict";

  require("./lib/fixoldbrowsers");

  var oop = require("./lib/oop");
  var dom = require("./lib/dom");
  var lang = require("./lib/lang");
  var useragent = require("./lib/useragent");
  var TextInput = require("./keyboard/textinput").TextInput;
  var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
  var FoldHandler = require("./mouse/fold_handler").FoldHandler;
  var KeyBinding = require("./keyboard/keybinding").KeyBinding;
  var EditSession = require("./edit_session").EditSession;
  var Search = require("./search").Search;
  var Range = require("./range").Range;
  var EventEmitter = require("./lib/event_emitter").EventEmitter;
  var CommandManager = require("./commands/command_manager").CommandManager;
  var defaultCommands = require("./commands/default_commands").commands;
  var config = require("./config");
  var TokenIterator = require("./token_iterator").TokenIterator;
  var Editor = function(renderer, session) {
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
    this.renderer.textarea = this.textInput.getElement();
    this.keyBinding = new KeyBinding(this);
    this.$mouseHandler = new MouseHandler(this);
    new FoldHandler(this);

    this.$blockScrolling = 0;
    this.$search = new Search().set({
      wrap: true
    });

    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on("exec", this.$historyTracker);

    this.$initOperationListeners();

    this._$emitInputEvent = lang.delayedCall(function() {
      this._signal("input", {});
      if (this.session && this.session.bgTokenizer)
        this.session.bgTokenizer.scheduleStart();
    }.bind(this));

    this.on("change", function(_, _self) {
      _self._$emitInputEvent.schedule(31);
    });

    this.setSession(session || new EditSession(""));
    config.resetOptions(this);
    config._signal("editor", this);
  };

  (function(){

    oop.implement(this, EventEmitter);

    this.$initOperationListeners = function() {
      function last(a) {return a[a.length - 1]}

      this.selections = [];
      this.commands.on("exec", this.startOperation.bind(this), true);
      this.commands.on("afterExec", this.endOperation.bind(this), true);

      this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

      this.on("change", function() {
        this.curOp || this.startOperation();
        this.curOp.docChanged = true;
      }.bind(this), true);

      this.on("changeSelection", function() {
        this.curOp || this.startOperation();
        this.curOp.selectionChanged = true;
      }.bind(this), true);
    };

    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function(commadEvent) {
      if (this.curOp) {
        if (!commadEvent || this.curOp.command)
          return;
        this.prevOp = this.curOp;
      }
      if (!commadEvent) {
        this.previousCommand = null;
        commadEvent = {};
      }

      this.$opResetTimer.schedule();
      this.curOp = {
        command: commadEvent.command || {},
        args: commadEvent.args,
        scrollTop: this.renderer.scrollTop
      };
      if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
        this.$blockScrolling++;
    };

    this.endOperation = function(e) {
      if (this.curOp) {
        if (e && e.returnValue === false)
          return this.curOp = null;
        this._signal("beforeEndOperation");
        var command = this.curOp.command;
        if (command.name && this.$blockScrolling > 0)
          this.$blockScrolling--;
        var scrollIntoView = command && command.scrollIntoView;
        if (scrollIntoView) {
          switch (scrollIntoView) {
            case "center-animate":
              scrollIntoView = "animate";
            case "center":
              this.renderer.scrollCursorIntoView(null, 0.5);
              break;
            case "animate":
            case "cursor":
              this.renderer.scrollCursorIntoView();
              break;
            case "selectionPart":
              var range = this.selection.getRange();
              var config = this.renderer.layerConfig;
              if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
              }
              break;
            default:
              break;
          }
          if (scrollIntoView == "animate")
            this.renderer.animateScrolling(this.curOp.scrollTop);
        }

        this.prevOp = this.curOp;
        this.curOp = null;
      }
    };
    this.$mergeableCommands = ["backspace", "del", "insertstring"];
    this.$historyTracker = function(e) {
      if (!this.$mergeUndoDeltas)
        return;

      var prev = this.prevOp;
      var mergeableCommands = this.$mergeableCommands;
      var shouldMerge = prev.command && (e.command.name == prev.command.name);
      if (e.command.name == "insertstring") {
        var text = e.args;
        if (this.mergeNextCommand === undefined)
          this.mergeNextCommand = true;

        shouldMerge = shouldMerge
          && this.mergeNextCommand // previous command allows to coalesce with
          && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

        this.mergeNextCommand = true;
      } else {
        shouldMerge = shouldMerge
          && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
      }

      if (
        this.$mergeUndoDeltas != "always"
        && Date.now() - this.sequenceStartTime > 2000
      ) {
        shouldMerge = false; // the sequence is too long
      }

      if (shouldMerge)
        this.session.mergeUndoDeltas = true;
      else if (mergeableCommands.indexOf(e.command.name) !== -1)
        this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function(keyboardHandler, cb) {
      if (keyboardHandler && typeof keyboardHandler === "string") {
        this.$keybindingId = keyboardHandler;
        var _self = this;
        config.loadModule(["keybinding", keyboardHandler], function(module) {
          if (_self.$keybindingId == keyboardHandler)
            _self.keyBinding.setKeyboardHandler(module && module.handler);
          cb && cb();
        });
      } else {
        this.$keybindingId = null;
        this.keyBinding.setKeyboardHandler(keyboardHandler);
        cb && cb();
      }
    };
    this.getKeyboardHandler = function() {
      return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function(session) {
      if (this.session == session)
        return;
      if (this.curOp) this.endOperation();
      this.curOp = {};

      var oldSession = this.session;
      if (oldSession) {
        this.session.off("change", this.$onDocumentChange);
        this.session.off("changeMode", this.$onChangeMode);
        this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
        this.session.off("changeTabSize", this.$onChangeTabSize);
        this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
        this.session.off("changeWrapMode", this.$onChangeWrapMode);
        this.session.off("changeFold", this.$onChangeFold);
        this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
        this.session.off("changeBackMarker", this.$onChangeBackMarker);
        this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
        this.session.off("changeAnnotation", this.$onChangeAnnotation);
        this.session.off("changeOverwrite", this.$onCursorChange);
        this.session.off("changeScrollTop", this.$onScrollTopChange);
        this.session.off("changeScrollLeft", this.$onScrollLeftChange);

        var selection = this.session.getSelection();
        selection.off("changeCursor", this.$onCursorChange);
        selection.off("changeSelection", this.$onSelectionChange);
      }

      this.session = session;
      if (session) {
        this.$onDocumentChange = this.onDocumentChange.bind(this);
        session.on("change", this.$onDocumentChange);
        this.renderer.setSession(session);

        this.$onChangeMode = this.onChangeMode.bind(this);
        session.on("changeMode", this.$onChangeMode);

        this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
        session.on("tokenizerUpdate", this.$onTokenizerUpdate);

        this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
        session.on("changeTabSize", this.$onChangeTabSize);

        this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
        session.on("changeWrapLimit", this.$onChangeWrapLimit);

        this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
        session.on("changeWrapMode", this.$onChangeWrapMode);

        this.$onChangeFold = this.onChangeFold.bind(this);
        session.on("changeFold", this.$onChangeFold);

        this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
        this.session.on("changeFrontMarker", this.$onChangeFrontMarker);

        this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
        this.session.on("changeBackMarker", this.$onChangeBackMarker);

        this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
        this.session.on("changeBreakpoint", this.$onChangeBreakpoint);

        this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
        this.session.on("changeAnnotation", this.$onChangeAnnotation);

        this.$onCursorChange = this.onCursorChange.bind(this);
        this.session.on("changeOverwrite", this.$onCursorChange);

        this.$onScrollTopChange = this.onScrollTopChange.bind(this);
        this.session.on("changeScrollTop", this.$onScrollTopChange);

        this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
        this.session.on("changeScrollLeft", this.$onScrollLeftChange);

        this.selection = session.getSelection();
        this.selection.on("changeCursor", this.$onCursorChange);

        this.$onSelectionChange = this.onSelectionChange.bind(this);
        this.selection.on("changeSelection", this.$onSelectionChange);

        this.onChangeMode();

        this.$blockScrolling += 1;
        this.onCursorChange();
        this.$blockScrolling -= 1;

        this.onScrollTopChange();
        this.onScrollLeftChange();
        this.onSelectionChange();
        this.onChangeFrontMarker();
        this.onChangeBackMarker();
        this.onChangeBreakpoint();
        this.onChangeAnnotation();
        this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
        this.renderer.updateFull();
      } else {
        this.selection = null;
        this.renderer.setSession(session);
      }

      this._signal("changeSession", {
        session: session,
        oldSession: oldSession
      });

      this.curOp = null;

      oldSession && oldSession._signal("changeEditor", {oldEditor: this});
      session && session._signal("changeEditor", {editor: this});
    };
    this.getSession = function() {
      return this.session;
    };
    this.setValue = function(val, cursorPos) {
      this.session.doc.setValue(val);

      if (!cursorPos)
        this.selectAll();
      else if (cursorPos == 1)
        this.navigateFileEnd();
      else if (cursorPos == -1)
        this.navigateFileStart();

      return val;
    };
    this.getValue = function() {
      return this.session.getValue();
    };
    this.getSelection = function() {
      return this.selection;
    };
    this.resize = function(force) {
      this.renderer.onResize(force);
    };
    this.setTheme = function(theme, cb) {
      this.renderer.setTheme(theme, cb);
    };
    this.getTheme = function() {
      return this.renderer.getTheme();
    };
    this.setStyle = function(style) {
      this.renderer.setStyle(style);
    };
    this.unsetStyle = function(style) {
      this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
      return this.getOption("fontSize") ||
        dom.computedStyle(this.container, "fontSize");
    };
    this.setFontSize = function(size) {
      this.setOption("fontSize", size);
    };

    this.$highlightBrackets = function() {
      if (this.session.$bracketHighlight) {
        this.session.removeMarker(this.session.$bracketHighlight);
        this.session.$bracketHighlight = null;
      }

      if (this.$highlightPending) {
        return;
      }
      var self = this;
      this.$highlightPending = true;
      setTimeout(function() {
        self.$highlightPending = false;
        var session = self.session;
        if (!session || !session.bgTokenizer) return;
        var pos = session.findMatchingBracket(self.getCursorPosition());
        if (pos) {
          var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
        } else if (session.$mode.getMatching) {
          var range = session.$mode.getMatching(self.session);
        }
        if (range)
          session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
      }, 50);
    };
    this.$highlightTags = function() {
      if (this.$highlightTagPending)
        return;
      var self = this;
      this.$highlightTagPending = true;
      setTimeout(function() {
        self.$highlightTagPending = false;

        var session = self.session;
        if (!session || !session.bgTokenizer) return;

        var pos = self.getCursorPosition();
        var iterator = new TokenIterator(self.session, pos.row, pos.column);
        var token = iterator.getCurrentToken();

        if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
          session.removeMarker(session.$tagHighlight);
          session.$tagHighlight = null;
          return;
        }

        if (token.type.indexOf("tag-open") != -1) {
          token = iterator.stepForward();
          if (!token)
            return;
        }

        var tag = token.value;
        var depth = 0;
        var prevToken = iterator.stepBackward();

        if (prevToken.value == '<'){
          do {
            prevToken = token;
            token = iterator.stepForward();

            if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
              if (prevToken.value === '<'){
                depth++;
              } else if (prevToken.value === '</'){
                depth--;
              }
            }

          } while (token && depth >= 0);
        } else {
          do {
            token = prevToken;
            prevToken = iterator.stepBackward();

            if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
              if (prevToken.value === '<') {
                depth++;
              } else if (prevToken.value === '</') {
                depth--;
              }
            }
          } while (prevToken && depth <= 0);
          iterator.stepForward();
        }

        if (!token) {
          session.removeMarker(session.$tagHighlight);
          session.$tagHighlight = null;
          return;
        }

        var row = iterator.getCurrentTokenRow();
        var column = iterator.getCurrentTokenColumn();
        var range = new Range(row, column, row, column+token.value.length);
        var sbm = session.$backMarkers[session.$tagHighlight];
        if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
          session.removeMarker(session.$tagHighlight);
          session.$tagHighlight = null;
        }

        if (range && !session.$tagHighlight)
          session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
      }, 50);
    };
    this.focus = function() {
      var _self = this;
      setTimeout(function() {
        _self.textInput.focus();
      });
      this.textInput.focus();
    };
    this.isFocused = function() {
      return this.textInput.isFocused();
    };
    this.blur = function() {
      this.textInput.blur();
    };
    this.onFocus = function(e) {
      if (this.$isFocused)
        return;
      this.$isFocused = true;
      this.renderer.showCursor();
      this.renderer.visualizeFocus();
      this._emit("focus", e);
    };
    this.onBlur = function(e) {
      if (!this.$isFocused)
        return;
      this.$isFocused = false;
      this.renderer.hideCursor();
      this.renderer.visualizeBlur();
      this._emit("blur", e);
    };

    this.$cursorChange = function() {
      this.renderer.updateCursor();
    };
    this.onDocumentChange = function(delta) {
      var wrap = this.session.$useWrapMode;
      var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
      this.renderer.updateLines(delta.start.row, lastRow, wrap);

      this._signal("change", delta);
      this.$cursorChange();
      this.$updateHighlightActiveLine();
    };

    this.onTokenizerUpdate = function(e) {
      var rows = e.data;
      this.renderer.updateLines(rows.first, rows.last);
    };


    this.onScrollTopChange = function() {
      this.renderer.scrollToY(this.session.getScrollTop());
    };

    this.onScrollLeftChange = function() {
      this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function() {
      this.$cursorChange();

      if (!this.$blockScrolling) {
        config.warn("Automatically scrolling cursor into view after selection change",
          "this will be disabled in the next version",
          "set editor.$blockScrolling = Infinity to disable this message"
        );
        this.renderer.scrollCursorIntoView();
      }

      this.$highlightBrackets();
      this.$highlightTags();
      this.$updateHighlightActiveLine();
      this._signal("changeSelection");
    };

    this.$updateHighlightActiveLine = function() {
      var session = this.getSession();

      var highlight;
      if (this.$highlightActiveLine) {
        if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
          highlight = this.getCursorPosition();
        if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
          highlight = false;
      }

      if (session.$highlightLineMarker && !highlight) {
        session.removeMarker(session.$highlightLineMarker.id);
        session.$highlightLineMarker = null;
      } else if (!session.$highlightLineMarker && highlight) {
        var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
        range.id = session.addMarker(range, "ace_active-line", "screenLine");
        session.$highlightLineMarker = range;
      } else if (highlight) {
        session.$highlightLineMarker.start.row = highlight.row;
        session.$highlightLineMarker.end.row = highlight.row;
        session.$highlightLineMarker.start.column = highlight.column;
        session._signal("changeBackMarker");
      }
    };

    this.onSelectionChange = function(e) {
      var session = this.session;

      if (session.$selectionMarker) {
        session.removeMarker(session.$selectionMarker);
      }
      session.$selectionMarker = null;

      if (!this.selection.isEmpty()) {
        var range = this.selection.getRange();
        var style = this.getSelectionStyle();
        session.$selectionMarker = session.addMarker(range, "ace_selection", style);
      } else {
        this.$updateHighlightActiveLine();
      }

      var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
      this.session.highlight(re);

      this._signal("changeSelection");
    };

    this.$getSelectionHighLightRegexp = function() {
      var session = this.session;

      var selection = this.getSelectionRange();
      if (selection.isEmpty() || selection.isMultiLine())
        return;

      var startOuter = selection.start.column - 1;
      var endOuter = selection.end.column + 1;
      var line = session.getLine(selection.start.row);
      var lineCols = line.length;
      var needle = line.substring(Math.max(startOuter, 0),
        Math.min(endOuter, lineCols));
      if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
        (endOuter <= lineCols && /[\w\d]$/.test(needle)))
        return;

      needle = line.substring(selection.start.column, selection.end.column);
      if (!/^[\w\d]+$/.test(needle))
        return;

      var re = this.$search.$assembleRegExp({
        wholeWord: true,
        caseSensitive: true,
        needle: needle
      });

      return re;
    };


    this.onChangeFrontMarker = function() {
      this.renderer.updateFrontMarkers();
    };

    this.onChangeBackMarker = function() {
      this.renderer.updateBackMarkers();
    };


    this.onChangeBreakpoint = function() {
      this.renderer.updateBreakpoints();
    };

    this.onChangeAnnotation = function() {
      this.renderer.setAnnotations(this.session.getAnnotations());
    };


    this.onChangeMode = function(e) {
      this.renderer.updateText();
      this._emit("changeMode", e);
    };


    this.onChangeWrapLimit = function() {
      this.renderer.updateFull();
    };

    this.onChangeWrapMode = function() {
      this.renderer.onResize(true);
    };


    this.onChangeFold = function() {
      this.$updateHighlightActiveLine();
      this.renderer.updateFull();
    };
    this.getSelectedText = function() {
      return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function() {
      var text = this.getSelectedText();
      this._signal("copy", text);
      return text;
    };
    this.onCopy = function() {
      this.commands.exec("copy", this);
    };
    this.onCut = function() {
      this.commands.exec("cut", this);
    };
    this.onPaste = function(text, event) {
      var e = {text: text, event: event};
      this.commands.exec("paste", this, e);
    };

    this.$handlePaste = function(e) {
      if (typeof e == "string")
        e = {text: e};
      this._signal("paste", e);
      var text = e.text;
      if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
        this.insert(text);
      } else {
        var lines = text.split(/\r\n|\r|\n/);
        var ranges = this.selection.rangeList.ranges;

        if (lines.length > ranges.length || lines.length < 2 || !lines[1])
          return this.commands.exec("insertstring", this, text);

        for (var i = ranges.length; i--;) {
          var range = ranges[i];
          if (!range.isEmpty())
            this.session.remove(range);

          this.session.insert(range.start, lines[i]);
        }
      }
    };

    this.execCommand = function(command, args) {
      return this.commands.exec(command, this, args);
    };
    this.insert = function(text, pasted) {
      var session = this.session;
      var mode = session.getMode();
      var cursor = this.getCursorPosition();

      if (this.getBehavioursEnabled() && !pasted) {
        var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
        if (transform) {
          if (text !== transform.text) {
            this.session.mergeUndoDeltas = false;
            this.$mergeNextCommand = false;
          }
          text = transform.text;

        }
      }

      if (text == "\t")
        text = this.session.getTabString();
      if (!this.selection.isEmpty()) {
        var range = this.getSelectionRange();
        cursor = this.session.remove(range);
        this.clearSelection();
      }
      else if (this.session.getOverwrite()) {
        var range = new Range.fromPoints(cursor, cursor);
        range.end.column += text.length;
        this.session.remove(range);
      }

      if (text == "\n" || text == "\r\n") {
        var line = session.getLine(cursor.row);
        if (cursor.column > line.search(/\S|$/)) {
          var d = line.substr(cursor.column).search(/\S|$/);
          session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
        }
      }
      this.clearSelection();

      var start = cursor.column;
      var lineState = session.getState(cursor.row);
      var line = session.getLine(cursor.row);
      var shouldOutdent = mode.checkOutdent(lineState, line, text);
      var end = session.insert(cursor, text);

      if (transform && transform.selection) {
        if (transform.selection.length == 2) { // Transform relative to the current column
          this.selection.setSelectionRange(
            new Range(cursor.row, start + transform.selection[0],
              cursor.row, start + transform.selection[1]));
        } else { // Transform relative to the current row.
          this.selection.setSelectionRange(
            new Range(cursor.row + transform.selection[0],
              transform.selection[1],
              cursor.row + transform.selection[2],
              transform.selection[3]));
        }
      }

      if (session.getDocument().isNewLine(text)) {
        var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

        session.insert({row: cursor.row+1, column: 0}, lineIndent);
      }
      if (shouldOutdent)
        mode.autoOutdent(lineState, session, cursor.row);
    };

    this.onTextInput = function(text) {
      this.keyBinding.onTextInput(text);
    };

    this.onCommandKey = function(e, hashId, keyCode) {
      this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function(overwrite) {
      this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function() {
      return this.session.getOverwrite();
    };
    this.toggleOverwrite = function() {
      this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function(speed) {
      this.setOption("scrollSpeed", speed);
    };
    this.getScrollSpeed = function() {
      return this.getOption("scrollSpeed");
    };
    this.setDragDelay = function(dragDelay) {
      this.setOption("dragDelay", dragDelay);
    };
    this.getDragDelay = function() {
      return this.getOption("dragDelay");
    };
    this.setSelectionStyle = function(val) {
      this.setOption("selectionStyle", val);
    };
    this.getSelectionStyle = function() {
      return this.getOption("selectionStyle");
    };
    this.setHighlightActiveLine = function(shouldHighlight) {
      this.setOption("highlightActiveLine", shouldHighlight);
    };
    this.getHighlightActiveLine = function() {
      return this.getOption("highlightActiveLine");
    };
    this.setHighlightGutterLine = function(shouldHighlight) {
      this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
      return this.getOption("highlightGutterLine");
    };
    this.setHighlightSelectedWord = function(shouldHighlight) {
      this.setOption("highlightSelectedWord", shouldHighlight);
    };
    this.getHighlightSelectedWord = function() {
      return this.$highlightSelectedWord;
    };

    this.setAnimatedScroll = function(shouldAnimate){
      this.renderer.setAnimatedScroll(shouldAnimate);
    };

    this.getAnimatedScroll = function(){
      return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function(showInvisibles) {
      this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function() {
      return this.renderer.getShowInvisibles();
    };

    this.setDisplayIndentGuides = function(display) {
      this.renderer.setDisplayIndentGuides(display);
    };

    this.getDisplayIndentGuides = function() {
      return this.renderer.getDisplayIndentGuides();
    };
    this.setShowPrintMargin = function(showPrintMargin) {
      this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function() {
      return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
      this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
      return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function(readOnly) {
      this.setOption("readOnly", readOnly);
    };
    this.getReadOnly = function() {
      return this.getOption("readOnly");
    };
    this.setBehavioursEnabled = function (enabled) {
      this.setOption("behavioursEnabled", enabled);
    };
    this.getBehavioursEnabled = function () {
      return this.getOption("behavioursEnabled");
    };
    this.setWrapBehavioursEnabled = function (enabled) {
      this.setOption("wrapBehavioursEnabled", enabled);
    };
    this.getWrapBehavioursEnabled = function () {
      return this.getOption("wrapBehavioursEnabled");
    };
    this.setShowFoldWidgets = function(show) {
      this.setOption("showFoldWidgets", show);

    };
    this.getShowFoldWidgets = function() {
      return this.getOption("showFoldWidgets");
    };

    this.setFadeFoldWidgets = function(fade) {
      this.setOption("fadeFoldWidgets", fade);
    };

    this.getFadeFoldWidgets = function() {
      return this.getOption("fadeFoldWidgets");
    };
    this.remove = function(dir) {
      if (this.selection.isEmpty()){
        if (dir == "left")
          this.selection.selectLeft();
        else
          this.selection.selectRight();
      }

      var range = this.getSelectionRange();
      if (this.getBehavioursEnabled()) {
        var session = this.session;
        var state = session.getState(range.start.row);
        var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

        if (range.end.column === 0) {
          var text = session.getTextRange(range);
          if (text[text.length - 1] == "\n") {
            var line = session.getLine(range.end.row);
            if (/^\s+$/.test(line)) {
              range.end.column = line.length;
            }
          }
        }
        if (new_range)
          range = new_range;
      }

      this.session.remove(range);
      this.clearSelection();
    };
    this.removeWordRight = function() {
      if (this.selection.isEmpty())
        this.selection.selectWordRight();

      this.session.remove(this.getSelectionRange());
      this.clearSelection();
    };
    this.removeWordLeft = function() {
      if (this.selection.isEmpty())
        this.selection.selectWordLeft();

      this.session.remove(this.getSelectionRange());
      this.clearSelection();
    };
    this.removeToLineStart = function() {
      if (this.selection.isEmpty())
        this.selection.selectLineStart();

      this.session.remove(this.getSelectionRange());
      this.clearSelection();
    };
    this.removeToLineEnd = function() {
      if (this.selection.isEmpty())
        this.selection.selectLineEnd();

      var range = this.getSelectionRange();
      if (range.start.column == range.end.column && range.start.row == range.end.row) {
        range.end.column = 0;
        range.end.row++;
      }

      this.session.remove(range);
      this.clearSelection();
    };
    this.splitLine = function() {
      if (!this.selection.isEmpty()) {
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
      }

      var cursor = this.getCursorPosition();
      this.insert("\n");
      this.moveCursorToPosition(cursor);
    };
    this.transposeLetters = function() {
      if (!this.selection.isEmpty()) {
        return;
      }

      var cursor = this.getCursorPosition();
      var column = cursor.column;
      if (column === 0)
        return;

      var line = this.session.getLine(cursor.row);
      var swap, range;
      if (column < line.length) {
        swap = line.charAt(column) + line.charAt(column-1);
        range = new Range(cursor.row, column-1, cursor.row, column+1);
      }
      else {
        swap = line.charAt(column-1) + line.charAt(column-2);
        range = new Range(cursor.row, column-2, cursor.row, column);
      }
      this.session.replace(range, swap);
    };
    this.toLowerCase = function() {
      var originalRange = this.getSelectionRange();
      if (this.selection.isEmpty()) {
        this.selection.selectWord();
      }

      var range = this.getSelectionRange();
      var text = this.session.getTextRange(range);
      this.session.replace(range, text.toLowerCase());
      this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function() {
      var originalRange = this.getSelectionRange();
      if (this.selection.isEmpty()) {
        this.selection.selectWord();
      }

      var range = this.getSelectionRange();
      var text = this.session.getTextRange(range);
      this.session.replace(range, text.toUpperCase());
      this.selection.setSelectionRange(originalRange);
    };
    this.indent = function() {
      var session = this.session;
      var range = this.getSelectionRange();

      if (range.start.row < range.end.row) {
        var rows = this.$getSelectedRows();
        session.indentRows(rows.first, rows.last, "\t");
        return;
      } else if (range.start.column < range.end.column) {
        var text = session.getTextRange(range);
        if (!/^\s+$/.test(text)) {
          var rows = this.$getSelectedRows();
          session.indentRows(rows.first, rows.last, "\t");
          return;
        }
      }

      var line = session.getLine(range.start.row);
      var position = range.start;
      var size = session.getTabSize();
      var column = session.documentToScreenColumn(position.row, position.column);

      if (this.session.getUseSoftTabs()) {
        var count = (size - column % size);
        var indentString = lang.stringRepeat(" ", count);
      } else {
        var count = column % size;
        while (line[range.start.column - 1] == " " && count) {
          range.start.column--;
          count--;
        }
        this.selection.setSelectionRange(range);
        indentString = "\t";
      }
      return this.insert(indentString);
    };
    this.blockIndent = function() {
      var rows = this.$getSelectedRows();
      this.session.indentRows(rows.first, rows.last, "\t");
    };
    this.blockOutdent = function() {
      var selection = this.session.getSelection();
      this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function() {
      var rows = this.$getSelectedRows();
      var session = this.session;

      var lines = [];
      for (i = rows.first; i <= rows.last; i++)
        lines.push(session.getLine(i));

      lines.sort(function(a, b) {
        if (a.toLowerCase() < b.toLowerCase()) return -1;
        if (a.toLowerCase() > b.toLowerCase()) return 1;
        return 0;
      });

      var deleteRange = new Range(0, 0, 0, 0);
      for (var i = rows.first; i <= rows.last; i++) {
        var line = session.getLine(i);
        deleteRange.start.row = i;
        deleteRange.end.row = i;
        deleteRange.end.column = line.length;
        session.replace(deleteRange, lines[i-rows.first]);
      }
    };
    this.toggleCommentLines = function() {
      var state = this.session.getState(this.getCursorPosition().row);
      var rows = this.$getSelectedRows();
      this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };

    this.toggleBlockComment = function() {
      var cursor = this.getCursorPosition();
      var state = this.session.getState(cursor.row);
      var range = this.getSelectionRange();
      this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function(row, column) {
      var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
      _numberRx.lastIndex = 0;

      var s = this.session.getLine(row);
      while (_numberRx.lastIndex < column) {
        var m = _numberRx.exec(s);
        if(m.index <= column && m.index+m[0].length >= column){
          var number = {
            value: m[0],
            start: m.index,
            end: m.index+m[0].length
          };
          return number;
        }
      }
      return null;
    };
    this.modifyNumber = function(amount) {
      var row = this.selection.getCursor().row;
      var column = this.selection.getCursor().column;
      var charRange = new Range(row, column-1, row, column);

      var c = this.session.getTextRange(charRange);
      if (!isNaN(parseFloat(c)) && isFinite(c)) {
        var nr = this.getNumberAt(row, column);
        if (nr) {
          var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
          var decimals = nr.start + nr.value.length - fp;

          var t = parseFloat(nr.value);
          t *= Math.pow(10, decimals);


          if(fp !== nr.end && column < fp){
            amount *= Math.pow(10, nr.end - column - 1);
          } else {
            amount *= Math.pow(10, nr.end - column);
          }

          t += amount;
          t /= Math.pow(10, decimals);
          var nnr = t.toFixed(decimals);
          var replaceRange = new Range(row, nr.start, row, nr.end);
          this.session.replace(replaceRange, nnr);
          this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

        }
      }
    };
    this.removeLines = function() {
      var rows = this.$getSelectedRows();
      this.session.removeFullLines(rows.first, rows.last);
      this.clearSelection();
    };

    this.duplicateSelection = function() {
      var sel = this.selection;
      var doc = this.session;
      var range = sel.getRange();
      var reverse = sel.isBackwards();
      if (range.isEmpty()) {
        var row = range.start.row;
        doc.duplicateLines(row, row);
      } else {
        var point = reverse ? range.start : range.end;
        var endPoint = doc.insert(point, doc.getTextRange(range), false);
        range.start = point;
        range.end = endPoint;

        sel.setSelectionRange(range, reverse);
      }
    };
    this.moveLinesDown = function() {
      this.$moveLines(1, false);
    };
    this.moveLinesUp = function() {
      this.$moveLines(-1, false);
    };
    this.moveText = function(range, toPosition, copy) {
      return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function() {
      this.$moveLines(-1, true);
    };
    this.copyLinesDown = function() {
      this.$moveLines(1, true);
    };
    this.$moveLines = function(dir, copy) {
      var rows, moved;
      var selection = this.selection;
      if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
        var range = selection.toOrientedRange();
        rows = this.$getSelectedRows(range);
        moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
        if (copy && dir == -1) moved = 0;
        range.moveBy(moved, 0);
        selection.fromOrientedRange(range);
      } else {
        var ranges = selection.rangeList.ranges;
        selection.rangeList.detach(this.session);
        this.inVirtualSelectionMode = true;

        var diff = 0;
        var totalDiff = 0;
        var l = ranges.length;
        for (var i = 0; i < l; i++) {
          var rangeIndex = i;
          ranges[i].moveBy(diff, 0);
          rows = this.$getSelectedRows(ranges[i]);
          var first = rows.first;
          var last = rows.last;
          while (++i < l) {
            if (totalDiff) ranges[i].moveBy(totalDiff, 0);
            var subRows = this.$getSelectedRows(ranges[i]);
            if (copy && subRows.first != last)
              break;
            else if (!copy && subRows.first > last + 1)
              break;
            last = subRows.last;
          }
          i--;
          diff = this.session.$moveLines(first, last, copy ? 0 : dir);
          if (copy && dir == -1) rangeIndex = i + 1;
          while (rangeIndex <= i) {
            ranges[rangeIndex].moveBy(diff, 0);
            rangeIndex++;
          }
          if (!copy) diff = 0;
          totalDiff += diff;
        }

        selection.fromOrientedRange(selection.ranges[0]);
        selection.rangeList.attach(this.session);
        this.inVirtualSelectionMode = false;
      }
    };
    this.$getSelectedRows = function(range) {
      range = (range || this.getSelectionRange()).collapseRows();

      return {
        first: this.session.getRowFoldStart(range.start.row),
        last: this.session.getRowFoldEnd(range.end.row)
      };
    };

    this.onCompositionStart = function(text) {
      this.renderer.showComposition(this.getCursorPosition());
    };

    this.onCompositionUpdate = function(text) {
      this.renderer.setCompositionText(text);
    };

    this.onCompositionEnd = function() {
      this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function() {
      return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function() {
      return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function(row) {
      return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };
    this.isRowFullyVisible = function(row) {
      return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };
    this.$getVisibleRowCount = function() {
      return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };

    this.$moveByPage = function(dir, select) {
      var renderer = this.renderer;
      var config = this.renderer.layerConfig;
      var rows = dir * Math.floor(config.height / config.lineHeight);

      this.$blockScrolling++;
      if (select === true) {
        this.selection.$moveSelection(function(){
          this.moveCursorBy(rows, 0);
        });
      } else if (select === false) {
        this.selection.moveCursorBy(rows, 0);
        this.selection.clearSelection();
      }
      this.$blockScrolling--;

      var scrollTop = renderer.scrollTop;

      renderer.scrollBy(0, rows * config.lineHeight);
      if (select != null)
        renderer.scrollCursorIntoView(null, 0.5);

      renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function() {
      this.$moveByPage(1, true);
    };
    this.selectPageUp = function() {
      this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function() {
      this.$moveByPage(1, false);
    };
    this.gotoPageUp = function() {
      this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function() {
      this.$moveByPage(1);
    };
    this.scrollPageUp = function() {
      this.$moveByPage(-1);
    };
    this.scrollToRow = function(row) {
      this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function(line, center, animate, callback) {
      this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function() {
      var range = this.getSelectionRange();
      var pos = {
        row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
        column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
      };
      this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function() {
      return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function() {
      return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function() {
      return this.selection.getRange();
    };
    this.selectAll = function() {
      this.$blockScrolling += 1;
      this.selection.selectAll();
      this.$blockScrolling -= 1;
    };
    this.clearSelection = function() {
      this.selection.clearSelection();
    };
    this.moveCursorTo = function(row, column) {
      this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function(pos) {
      this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function(select, expand) {
      var cursor = this.getCursorPosition();
      var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
      var prevToken = iterator.getCurrentToken();
      var token = prevToken || iterator.stepForward();

      if (!token) return;
      var matchType;
      var found = false;
      var depth = {};
      var i = cursor.column - token.start;
      var bracketType;
      var brackets = {
        ")": "(",
        "(": "(",
        "]": "[",
        "[": "[",
        "{": "{",
        "}": "{"
      };

      do {
        if (token.value.match(/[{}()\[\]]/g)) {
          for (; i < token.value.length && !found; i++) {
            if (!brackets[token.value[i]]) {
              continue;
            }

            bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

            if (isNaN(depth[bracketType])) {
              depth[bracketType] = 0;
            }

            switch (token.value[i]) {
              case '(':
              case '[':
              case '{':
                depth[bracketType]++;
                break;
              case ')':
              case ']':
              case '}':
                depth[bracketType]--;

                if (depth[bracketType] === -1) {
                  matchType = 'bracket';
                  found = true;
                }
                break;
            }
          }
        }
        else if (token && token.type.indexOf('tag-name') !== -1) {
          if (isNaN(depth[token.value])) {
            depth[token.value] = 0;
          }

          if (prevToken.value === '<') {
            depth[token.value]++;
          }
          else if (prevToken.value === '</') {
            depth[token.value]--;
          }

          if (depth[token.value] === -1) {
            matchType = 'tag';
            found = true;
          }
        }

        if (!found) {
          prevToken = token;
          token = iterator.stepForward();
          i = 0;
        }
      } while (token && !found);
      if (!matchType)
        return;

      var range, pos;
      if (matchType === 'bracket') {
        range = this.session.getBracketRange(cursor);
        if (!range) {
          range = new Range(
            iterator.getCurrentTokenRow(),
            iterator.getCurrentTokenColumn() + i - 1,
            iterator.getCurrentTokenRow(),
            iterator.getCurrentTokenColumn() + i - 1
          );
          pos = range.start;
          if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
            range = this.session.getBracketRange(pos);
        }
      }
      else if (matchType === 'tag') {
        if (token && token.type.indexOf('tag-name') !== -1)
          var tag = token.value;
        else
          return;

        range = new Range(
          iterator.getCurrentTokenRow(),
          iterator.getCurrentTokenColumn() - 2,
          iterator.getCurrentTokenRow(),
          iterator.getCurrentTokenColumn() - 2
        );
        if (range.compare(cursor.row, cursor.column) === 0) {
          found = false;
          do {
            token = prevToken;
            prevToken = iterator.stepBackward();

            if (prevToken) {
              if (prevToken.type.indexOf('tag-close') !== -1) {
                range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
              }

              if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                if (prevToken.value === '<') {
                  depth[tag]++;
                }
                else if (prevToken.value === '</') {
                  depth[tag]--;
                }

                if (depth[tag] === 0)
                  found = true;
              }
            }
          } while (prevToken && !found);
        }
        if (token && token.type.indexOf('tag-name')) {
          pos = range.start;
          if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
            pos = range.end;
        }
      }

      pos = range && range.cursor || pos;
      if (pos) {
        if (select) {
          if (range && expand) {
            this.selection.setRange(range);
          } else if (range && range.isEqual(this.getSelectionRange())) {
            this.clearSelection();
          } else {
            this.selection.selectTo(pos.row, pos.column);
          }
        } else {
          this.selection.moveTo(pos.row, pos.column);
        }
      }
    };
    this.gotoLine = function(lineNumber, column, animate) {
      this.selection.clearSelection();
      this.session.unfold({row: lineNumber - 1, column: column || 0});

      this.$blockScrolling += 1;
      this.exitMultiSelectMode && this.exitMultiSelectMode();
      this.moveCursorTo(lineNumber - 1, column || 0);
      this.$blockScrolling -= 1;

      if (!this.isRowFullyVisible(lineNumber - 1))
        this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function(row, column) {
      this.selection.moveTo(row, column);
    };
    this.navigateUp = function(times) {
      if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
        var selectionStart = this.selection.anchor.getPosition();
        return this.moveCursorToPosition(selectionStart);
      }
      this.selection.clearSelection();
      this.selection.moveCursorBy(-times || -1, 0);
    };
    this.navigateDown = function(times) {
      if (this.selection.isMultiLine() && this.selection.isBackwards()) {
        var selectionEnd = this.selection.anchor.getPosition();
        return this.moveCursorToPosition(selectionEnd);
      }
      this.selection.clearSelection();
      this.selection.moveCursorBy(times || 1, 0);
    };
    this.navigateLeft = function(times) {
      if (!this.selection.isEmpty()) {
        var selectionStart = this.getSelectionRange().start;
        this.moveCursorToPosition(selectionStart);
      }
      else {
        times = times || 1;
        while (times--) {
          this.selection.moveCursorLeft();
        }
      }
      this.clearSelection();
    };
    this.navigateRight = function(times) {
      if (!this.selection.isEmpty()) {
        var selectionEnd = this.getSelectionRange().end;
        this.moveCursorToPosition(selectionEnd);
      }
      else {
        times = times || 1;
        while (times--) {
          this.selection.moveCursorRight();
        }
      }
      this.clearSelection();
    };
    this.navigateLineStart = function() {
      this.selection.moveCursorLineStart();
      this.clearSelection();
    };
    this.navigateLineEnd = function() {
      this.selection.moveCursorLineEnd();
      this.clearSelection();
    };
    this.navigateFileEnd = function() {
      this.selection.moveCursorFileEnd();
      this.clearSelection();
    };
    this.navigateFileStart = function() {
      this.selection.moveCursorFileStart();
      this.clearSelection();
    };
    this.navigateWordRight = function() {
      this.selection.moveCursorWordRight();
      this.clearSelection();
    };
    this.navigateWordLeft = function() {
      this.selection.moveCursorWordLeft();
      this.clearSelection();
    };
    this.replace = function(replacement, options) {
      if (options)
        this.$search.set(options);

      var range = this.$search.find(this.session);
      var replaced = 0;
      if (!range)
        return replaced;

      if (this.$tryReplace(range, replacement)) {
        replaced = 1;
      }
      if (range !== null) {
        this.selection.setSelectionRange(range);
        this.renderer.scrollSelectionIntoView(range.start, range.end);
      }

      return replaced;
    };
    this.replaceAll = function(replacement, options) {
      if (options) {
        this.$search.set(options);
      }

      var ranges = this.$search.findAll(this.session);
      var replaced = 0;
      if (!ranges.length)
        return replaced;

      this.$blockScrolling += 1;

      var selection = this.getSelectionRange();
      this.selection.moveTo(0, 0);

      for (var i = ranges.length - 1; i >= 0; --i) {
        if(this.$tryReplace(ranges[i], replacement)) {
          replaced++;
        }
      }

      this.selection.setSelectionRange(selection);
      this.$blockScrolling -= 1;

      return replaced;
    };

    this.$tryReplace = function(range, replacement) {
      var input = this.session.getTextRange(range);
      replacement = this.$search.replace(input, replacement);
      if (replacement !== null) {
        range.end = this.session.replace(range, replacement);
        return range;
      } else {
        return null;
      }
    };
    this.getLastSearchOptions = function() {
      return this.$search.getOptions();
    };
    this.find = function(needle, options, animate) {
      if (!options)
        options = {};

      if (typeof needle == "string" || needle instanceof RegExp)
        options.needle = needle;
      else if (typeof needle == "object")
        oop.mixin(options, needle);

      var range = this.selection.getRange();
      if (options.needle == null) {
        needle = this.session.getTextRange(range)
          || this.$search.$options.needle;
        if (!needle) {
          range = this.session.getWordRange(range.start.row, range.start.column);
          needle = this.session.getTextRange(range);
        }
        this.$search.set({needle: needle});
      }

      this.$search.set(options);
      if (!options.start)
        this.$search.set({start: range});

      var newRange = this.$search.find(this.session);
      if (options.preventScroll)
        return newRange;
      if (newRange) {
        this.revealRange(newRange, animate);
        return newRange;
      }
      if (options.backwards)
        range.start = range.end;
      else
        range.end = range.start;
      this.selection.setRange(range);
    };
    this.findNext = function(options, animate) {
      this.find({skipCurrent: true, backwards: false}, options, animate);
    };
    this.findPrevious = function(options, animate) {
      this.find(options, {skipCurrent: true, backwards: true}, animate);
    };

    this.revealRange = function(range, animate) {
      this.$blockScrolling += 1;
      this.session.unfold(range);
      this.selection.setSelectionRange(range);
      this.$blockScrolling -= 1;

      var scrollTop = this.renderer.scrollTop;
      this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
      if (animate !== false)
        this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function() {
      this.$blockScrolling++;
      this.session.getUndoManager().undo();
      this.$blockScrolling--;
      this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function() {
      this.$blockScrolling++;
      this.session.getUndoManager().redo();
      this.$blockScrolling--;
      this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function() {
      this.renderer.destroy();
      this._signal("destroy", this);
      if (this.session) {
        this.session.destroy();
      }
    };
    this.setAutoScrollEditorIntoView = function(enable) {
      if (!enable)
        return;
      var rect;
      var self = this;
      var shouldScroll = false;
      if (!this.$scrollAnchor)
        this.$scrollAnchor = document.createElement("div");
      var scrollAnchor = this.$scrollAnchor;
      scrollAnchor.style.cssText = "position:absolute";
      this.container.insertBefore(scrollAnchor, this.container.firstChild);
      var onChangeSelection = this.on("changeSelection", function() {
        shouldScroll = true;
      });
      var onBeforeRender = this.renderer.on("beforeRender", function() {
        if (shouldScroll)
          rect = self.renderer.container.getBoundingClientRect();
      });
      var onAfterRender = this.renderer.on("afterRender", function() {
        if (shouldScroll && rect && (self.isFocused()
          || self.searchBox && self.searchBox.isFocused())
        ) {
          var renderer = self.renderer;
          var pos = renderer.$cursorLayer.$pixelPos;
          var config = renderer.layerConfig;
          var top = pos.top - config.offset;
          if (pos.top >= 0 && top + rect.top < 0) {
            shouldScroll = true;
          } else if (pos.top < config.height &&
            pos.top + rect.top + config.lineHeight > window.innerHeight) {
            shouldScroll = false;
          } else {
            shouldScroll = null;
          }
          if (shouldScroll != null) {
            scrollAnchor.style.top = top + "px";
            scrollAnchor.style.left = pos.left + "px";
            scrollAnchor.style.height = config.lineHeight + "px";
            scrollAnchor.scrollIntoView(shouldScroll);
          }
          shouldScroll = rect = null;
        }
      });
      this.setAutoScrollEditorIntoView = function(enable) {
        if (enable)
          return;
        delete this.setAutoScrollEditorIntoView;
        this.off("changeSelection", onChangeSelection);
        this.renderer.off("afterRender", onAfterRender);
        this.renderer.off("beforeRender", onBeforeRender);
      };
    };


    this.$resetCursorStyle = function() {
      var style = this.$cursorStyle || "ace";
      var cursorLayer = this.renderer.$cursorLayer;
      if (!cursorLayer)
        return;
      cursorLayer.setSmoothBlinking(/smooth/.test(style));
      cursorLayer.isBlinking = !this.$readOnly && style != "wide";
      dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    };

  }).call(Editor.prototype);



  config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
      set: function(style) {
        this.onSelectionChange();
        this._signal("changeSelectionStyle", {data: style});
      },
      initialValue: "line"
    },
    highlightActiveLine: {
      set: function() {this.$updateHighlightActiveLine();},
      initialValue: true
    },
    highlightSelectedWord: {
      set: function(shouldHighlight) {this.$onSelectionChange();},
      initialValue: true
    },
    readOnly: {
      set: function(readOnly) {
        this.$resetCursorStyle();
      },
      initialValue: false
    },
    cursorStyle: {
      set: function(val) { this.$resetCursorStyle(); },
      values: ["ace", "slim", "smooth", "wide"],
      initialValue: "ace"
    },
    mergeUndoDeltas: {
      values: [false, true, "always"],
      initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},
    autoScrollEditorIntoView: {
      set: function(val) {this.setAutoScrollEditorIntoView(val)}
    },
    keyboardHandler: {
      set: function(val) { this.setKeyboardHandler(val); },
      get: function() { return this.keybindingId; },
      handlesSet: true
    },

    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    showLineNumbers: "renderer",
    showGutter: "renderer",
    displayIndentGuides: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimout: "$mouseHandler",
    tooltipFollowsMouse: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    indentedSoftWrap: "session",
    foldStyle: "session",
    mode: "session"
  });

  exports.Editor = Editor;
});

ace.define("ace/undomanager",["require","exports","module"], function(require, exports, module) {
  "use strict";
  var UndoManager = function() {
    this.reset();
  };

  (function() {
    this.execute = function(options) {
      var deltaSets = options.args[0];
      this.$doc  = options.args[1];
      if (options.merge && this.hasUndo()){
        this.dirtyCounter--;
        deltaSets = this.$undoStack.pop().concat(deltaSets);
      }
      this.$undoStack.push(deltaSets);
      this.$redoStack = [];
      if (this.dirtyCounter < 0) {
        this.dirtyCounter = NaN;
      }
      this.dirtyCounter++;
    };
    this.undo = function(dontSelect) {
      var deltaSets = this.$undoStack.pop();
      var undoSelectionRange = null;
      if (deltaSets) {
        undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
        this.$redoStack.push(deltaSets);
        this.dirtyCounter--;
      }

      return undoSelectionRange;
    };
    this.redo = function(dontSelect) {
      var deltaSets = this.$redoStack.pop();
      var redoSelectionRange = null;
      if (deltaSets) {
        redoSelectionRange =
          this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
        this.$undoStack.push(deltaSets);
        this.dirtyCounter++;
      }
      return redoSelectionRange;
    };
    this.reset = function() {
      this.$undoStack = [];
      this.$redoStack = [];
      this.dirtyCounter = 0;
    };
    this.hasUndo = function() {
      return this.$undoStack.length > 0;
    };
    this.hasRedo = function() {
      return this.$redoStack.length > 0;
    };
    this.markClean = function() {
      this.dirtyCounter = 0;
    };
    this.isClean = function() {
      return this.dirtyCounter === 0;
    };
    this.$serializeDeltas = function(deltaSets) {
      return cloneDeltaSetsObj(deltaSets, $serializeDelta);
    };
    this.$deserializeDeltas = function(deltaSets) {
      return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
    };

    function $serializeDelta(delta){
      return {
        action: delta.action,
        start: delta.start,
        end: delta.end,
        lines: delta.lines.length == 1 ? null : delta.lines,
        text: delta.lines.length == 1 ? delta.lines[0] : null
      };
    }

    function $deserializeDelta(delta) {
      return {
        action: delta.action,
        start: delta.start,
        end: delta.end,
        lines: delta.lines || [delta.text]
      };
    }

    function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
      var deltaSets_new = new Array(deltaSets_old.length);
      for (var i = 0; i < deltaSets_old.length; i++) {
        var deltaSet_old = deltaSets_old[i];
        var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length)};

        for (var j = 0; j < deltaSet_old.deltas.length; j++) {
          var delta_old = deltaSet_old.deltas[j];
          deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
        }

        deltaSets_new[i] = deltaSet_new;
      }
      return deltaSets_new;
    }

  }).call(UndoManager.prototype);

  exports.UndoManager = UndoManager;
});

ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter"], function(require, exports, module) {
  "use strict";

  var dom = require("../lib/dom");
  var oop = require("../lib/oop");
  var lang = require("../lib/lang");
  var EventEmitter = require("../lib/event_emitter").EventEmitter;

  var Gutter = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);

    this.gutterWidth = 0;

    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);

    this.$cells = [];
  };

  (function() {

    oop.implement(this, EventEmitter);

    this.setSession = function(session) {
      if (this.session)
        this.session.removeEventListener("change", this.$updateAnnotations);
      this.session = session;
      if (session)
        session.on("change", this.$updateAnnotations);
    };

    this.addGutterDecoration = function(row, className){
      if (window.console)
        console.warn && console.warn("deprecated use session.addGutterDecoration");
      this.session.addGutterDecoration(row, className);
    };

    this.removeGutterDecoration = function(row, className){
      if (window.console)
        console.warn && console.warn("deprecated use session.removeGutterDecoration");
      this.session.removeGutterDecoration(row, className);
    };

    this.setAnnotations = function(annotations) {
      this.$annotations = [];
      for (var i = 0; i < annotations.length; i++) {
        var annotation = annotations[i];
        var row = annotation.row;
        var rowInfo = this.$annotations[row];
        if (!rowInfo)
          rowInfo = this.$annotations[row] = {text: []};

        var annoText = annotation.text;
        annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

        if (rowInfo.text.indexOf(annoText) === -1)
          rowInfo.text.push(annoText);

        var type = annotation.type;
        if (type == "error")
          rowInfo.className = " ace_error";
        else if (type == "warning" && rowInfo.className != " ace_error")
          rowInfo.className = " ace_warning";
        else if (type == "info" && (!rowInfo.className))
          rowInfo.className = " ace_info";
      }
    };

    this.$updateAnnotations = function (delta) {
      if (!this.$annotations.length)
        return;
      var firstRow = delta.start.row;
      var len = delta.end.row - firstRow;
      if (len === 0) {
      } else if (delta.action == 'remove') {
        this.$annotations.splice(firstRow, len + 1, null);
      } else {
        var args = new Array(len + 1);
        args.unshift(firstRow, 1);
        this.$annotations.splice.apply(this.$annotations, args);
      }
    };

    this.update = function(config) {
      var session = this.session;
      var firstRow = config.firstRow;
      var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
        session.getLength() - 1);
      var fold = session.getNextFoldLine(firstRow);
      var foldStart = fold ? fold.start.row : Infinity;
      var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
      var breakpoints = session.$breakpoints;
      var decorations = session.$decorations;
      var firstLineNumber = session.$firstLineNumber;
      var lastLineNumber = 0;

      var gutterRenderer = session.gutterRenderer || this.$renderer;

      var cell = null;
      var index = -1;
      var row = firstRow;
      while (true) {
        if (row > foldStart) {
          row = fold.end.row + 1;
          fold = session.getNextFoldLine(row, fold);
          foldStart = fold ? fold.start.row : Infinity;
        }
        if (row > lastRow) {
          while (this.$cells.length > index + 1) {
            cell = this.$cells.pop();
            this.element.removeChild(cell.element);
          }
          break;
        }

        cell = this.$cells[++index];
        if (!cell) {
          cell = {element: null, textNode: null, foldWidget: null};
          cell.element = dom.createElement("div");
          cell.textNode = document.createTextNode('');
          cell.element.appendChild(cell.textNode);
          this.element.appendChild(cell.element);
          this.$cells[index] = cell;
        }

        var className = "ace_gutter-cell ";
        if (breakpoints[row])
          className += breakpoints[row];
        if (decorations[row])
          className += decorations[row];
        if (this.$annotations[row])
          className += this.$annotations[row].className;
        if (cell.element.className != className)
          cell.element.className = className;

        var height = session.getRowLength(row) * config.lineHeight + "px";
        if (height != cell.element.style.height)
          cell.element.style.height = height;

        if (foldWidgets) {
          var c = foldWidgets[row];
          if (c == null)
            c = foldWidgets[row] = session.getFoldWidget(row);
        }

        if (c) {
          if (!cell.foldWidget) {
            cell.foldWidget = dom.createElement("span");
            cell.element.appendChild(cell.foldWidget);
          }
          var className = "ace_fold-widget ace_" + c;
          if (c == "start" && row == foldStart && row < fold.end.row)
            className += " ace_closed";
          else
            className += " ace_open";
          if (cell.foldWidget.className != className)
            cell.foldWidget.className = className;

          var height = config.lineHeight + "px";
          if (cell.foldWidget.style.height != height)
            cell.foldWidget.style.height = height;
        } else {
          if (cell.foldWidget) {
            cell.element.removeChild(cell.foldWidget);
            cell.foldWidget = null;
          }
        }

        var text = lastLineNumber = gutterRenderer
          ? gutterRenderer.getText(session, row)
          : row + firstLineNumber;
        if (text != cell.textNode.data)
          cell.textNode.data = text;

        row++;
      }

      this.element.style.height = config.minHeight + "px";

      if (this.$fixedWidth || session.$useWrapMode)
        lastLineNumber = session.getLength() + firstLineNumber;

      var gutterWidth = gutterRenderer
        ? gutterRenderer.getWidth(session, lastLineNumber, config)
        : lastLineNumber.toString().length * config.characterWidth;

      var padding = this.$padding || this.$computePadding();
      gutterWidth += padding.left + padding.right;
      if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
        this.gutterWidth = gutterWidth;
        this.element.style.width = Math.ceil(this.gutterWidth) + "px";
        this._emit("changeGutterWidth", gutterWidth);
      }
    };

    this.$fixedWidth = false;

    this.$showLineNumbers = true;
    this.$renderer = "";
    this.setShowLineNumbers = function(show) {
      this.$renderer = !show && {
          getWidth: function() {return ""},
          getText: function() {return ""}
        };
    };

    this.getShowLineNumbers = function() {
      return this.$showLineNumbers;
    };

    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function(show) {
      if (show)
        dom.addCssClass(this.element, "ace_folding-enabled");
      else
        dom.removeCssClass(this.element, "ace_folding-enabled");

      this.$showFoldWidgets = show;
      this.$padding = null;
    };

    this.getShowFoldWidgets = function() {
      return this.$showFoldWidgets;
    };

    this.$computePadding = function() {
      if (!this.element.firstChild)
        return {left: 0, right: 0};
      var style = dom.computedStyle(this.element.firstChild);
      this.$padding = {};
      this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
      this.$padding.right = parseInt(style.paddingRight) || 0;
      return this.$padding;
    };

    this.getRegion = function(point) {
      var padding = this.$padding || this.$computePadding();
      var rect = this.element.getBoundingClientRect();
      if (point.x < padding.left + rect.left)
        return "markers";
      if (this.$showFoldWidgets && point.x > rect.right - padding.right)
        return "foldWidgets";
    };

  }).call(Gutter.prototype);

  exports.Gutter = Gutter;

});

ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(require, exports, module) {
  "use strict";

  var Range = require("../range").Range;
  var dom = require("../lib/dom");

  var Marker = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
  };

  (function() {

    this.$padding = 0;

    this.setPadding = function(padding) {
      this.$padding = padding;
    };
    this.setSession = function(session) {
      this.session = session;
    };

    this.setMarkers = function(markers) {
      this.markers = markers;
    };

    this.update = function(config) {
      var config = config || this.config;
      if (!config)
        return;

      this.config = config;


      var html = [];
      for (var key in this.markers) {
        var marker = this.markers[key];

        if (!marker.range) {
          marker.update(html, this, this.session, config);
          continue;
        }

        var range = marker.range.clipRows(config.firstRow, config.lastRow);
        if (range.isEmpty()) continue;

        range = range.toScreenRange(this.session);
        if (marker.renderer) {
          var top = this.$getTop(range.start.row, config);
          var left = this.$padding + range.start.column * config.characterWidth;
          marker.renderer(html, range, left, top, config);
        } else if (marker.type == "fullLine") {
          this.drawFullLineMarker(html, range, marker.clazz, config);
        } else if (marker.type == "screenLine") {
          this.drawScreenLineMarker(html, range, marker.clazz, config);
        } else if (range.isMultiLine()) {
          if (marker.type == "text")
            this.drawTextMarker(html, range, marker.clazz, config);
          else
            this.drawMultiLineMarker(html, range, marker.clazz, config);
        } else {
          this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
        }
      }
      this.element.innerHTML = html.join("");
    };

    this.$getTop = function(row, layerConfig) {
      return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };

    function getBorderClass(tl, tr, br, bl) {
      return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
      var session = this.session;
      var start = range.start.row;
      var end = range.end.row;
      var row = start;
      var prev = 0;
      var curr = 0;
      var next = session.getScreenLastRowColumn(row);
      var lineRange = new Range(row, range.start.column, row, curr);
      for (; row <= end; row++) {
        lineRange.start.row = lineRange.end.row = row;
        lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
        lineRange.end.column = next;
        prev = curr;
        curr = next;
        next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
        this.drawSingleLineMarker(stringBuilder, lineRange,
          clazz + (row == start  ? " ace_start" : "") + " ace_br"
          + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
          layerConfig, row == end ? 0 : 1, extraStyle);
      }
    };
    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
      var padding = this.$padding;
      var height = config.lineHeight;
      var top = this.$getTop(range.start.row, config);
      var left = padding + range.start.column * config.characterWidth;
      extraStyle = extraStyle || "";

      stringBuilder.push(
        "<div class='", clazz, " ace_br1 ace_start' style='",
        "height:", height, "px;",
        "right:0;",
        "top:", top, "px;",
        "left:", left, "px;", extraStyle, "'></div>"
      );
      top = this.$getTop(range.end.row, config);
      var width = range.end.column * config.characterWidth;

      stringBuilder.push(
        "<div class='", clazz, " ace_br12' style='",
        "height:", height, "px;",
        "width:", width, "px;",
        "top:", top, "px;",
        "left:", padding, "px;", extraStyle, "'></div>"
      );
      height = (range.end.row - range.start.row - 1) * config.lineHeight;
      if (height <= 0)
        return;
      top = this.$getTop(range.start.row + 1, config);

      var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

      stringBuilder.push(
        "<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='",
        "height:", height, "px;",
        "right:0;",
        "top:", top, "px;",
        "left:", padding, "px;", extraStyle, "'></div>"
      );
    };
    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
      var height = config.lineHeight;
      var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

      var top = this.$getTop(range.start.row, config);
      var left = this.$padding + range.start.column * config.characterWidth;

      stringBuilder.push(
        "<div class='", clazz, "' style='",
        "height:", height, "px;",
        "width:", width, "px;",
        "top:", top, "px;",
        "left:", left, "px;", extraStyle || "", "'></div>"
      );
    };

    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
      var top = this.$getTop(range.start.row, config);
      var height = config.lineHeight;
      if (range.start.row != range.end.row)
        height += this.$getTop(range.end.row, config) - top;

      stringBuilder.push(
        "<div class='", clazz, "' style='",
        "height:", height, "px;",
        "top:", top, "px;",
        "left:0;right:0;", extraStyle || "", "'></div>"
      );
    };

    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
      var top = this.$getTop(range.start.row, config);
      var height = config.lineHeight;

      stringBuilder.push(
        "<div class='", clazz, "' style='",
        "height:", height, "px;",
        "top:", top, "px;",
        "left:0;right:0;", extraStyle || "", "'></div>"
      );
    };

  }).call(Marker.prototype);

  exports.Marker = Marker;

});

ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module) {
  "use strict";

  var oop = require("../lib/oop");
  var dom = require("../lib/dom");
  var lang = require("../lib/lang");
  var useragent = require("../lib/useragent");
  var EventEmitter = require("../lib/event_emitter").EventEmitter;

  var Text = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
  };

  (function() {

    oop.implement(this, EventEmitter);

    this.EOF_CHAR = "\xB6";
    this.EOL_CHAR_LF = "\xAC";
    this.EOL_CHAR_CRLF = "\xa4";
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = "\u2014"; //"\u21E5";
    this.SPACE_CHAR = "\xB7";
    this.$padding = 0;

    this.$updateEolChar = function() {
      var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
        ? this.EOL_CHAR_LF
        : this.EOL_CHAR_CRLF;
      if (this.EOL_CHAR != EOL_CHAR) {
        this.EOL_CHAR = EOL_CHAR;
        return true;
      }
    }

    this.setPadding = function(padding) {
      this.$padding = padding;
      this.element.style.padding = "0 " + padding + "px";
    };

    this.getLineHeight = function() {
      return this.$fontMetrics.$characterSize.height || 0;
    };

    this.getCharacterWidth = function() {
      return this.$fontMetrics.$characterSize.width || 0;
    };

    this.$setFontMetrics = function(measure) {
      this.$fontMetrics = measure;
      this.$fontMetrics.on("changeCharacterSize", function(e) {
        this._signal("changeCharacterSize", e);
      }.bind(this));
      this.$pollSizeChanges();
    }

    this.checkForSizeChanges = function() {
      this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function() {
      return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function(session) {
      this.session = session;
      if (session)
        this.$computeTabString();
    };

    this.showInvisibles = false;
    this.setShowInvisibles = function(showInvisibles) {
      if (this.showInvisibles == showInvisibles)
        return false;

      this.showInvisibles = showInvisibles;
      this.$computeTabString();
      return true;
    };

    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function(display) {
      if (this.displayIndentGuides == display)
        return false;

      this.displayIndentGuides = display;
      this.$computeTabString();
      return true;
    };

    this.$tabStrings = [];
    this.onChangeTabSize =
      this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
          if (this.showInvisibles) {
            tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
              + lang.stringRepeat(this.TAB_CHAR, i)
              + "</span>");
          } else {
            tabStr.push(lang.stringRepeat(" ", i));
          }
        }
        if (this.displayIndentGuides) {
          this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
          var className = "ace_indent-guide";
          var spaceClass = "";
          var tabClass = "";
          if (this.showInvisibles) {
            className += " ace_invisible";
            spaceClass = " ace_invisible_space";
            tabClass = " ace_invisible_tab";
            var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
            var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
          } else{
            var spaceContent = lang.stringRepeat(" ", this.tabSize);
            var tabContent = spaceContent;
          }

          this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
          this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
        }
      };

    this.updateLines = function(config, firstRow, lastRow) {
      if (this.config.lastRow != config.lastRow ||
        this.config.firstRow != config.firstRow) {
        this.scrollLines(config);
      }
      this.config = config;

      var first = Math.max(firstRow, config.firstRow);
      var last = Math.min(lastRow, config.lastRow);

      var lineElements = this.element.childNodes;
      var lineElementsIdx = 0;

      for (var row = config.firstRow; row < first; row++) {
        var foldLine = this.session.getFoldLine(row);
        if (foldLine) {
          if (foldLine.containsRow(first)) {
            first = foldLine.start.row;
            break;
          } else {
            row = foldLine.end.row;
          }
        }
        lineElementsIdx ++;
      }

      var row = first;
      var foldLine = this.session.getNextFoldLine(row);
      var foldStart = foldLine ? foldLine.start.row : Infinity;

      while (true) {
        if (row > foldStart) {
          row = foldLine.end.row+1;
          foldLine = this.session.getNextFoldLine(row, foldLine);
          foldStart = foldLine ? foldLine.start.row :Infinity;
        }
        if (row > last)
          break;

        var lineElement = lineElements[lineElementsIdx++];
        if (lineElement) {
          var html = [];
          this.$renderLine(
            html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
          );
          lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
          lineElement.innerHTML = html.join("");
        }
        row++;
      }
    };

    this.scrollLines = function(config) {
      var oldConfig = this.config;
      this.config = config;

      if (!oldConfig || oldConfig.lastRow < config.firstRow)
        return this.update(config);

      if (config.lastRow < oldConfig.firstRow)
        return this.update(config);

      var el = this.element;
      if (oldConfig.firstRow < config.firstRow)
        for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
          el.removeChild(el.firstChild);

      if (oldConfig.lastRow > config.lastRow)
        for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
          el.removeChild(el.lastChild);

      if (config.firstRow < oldConfig.firstRow) {
        var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
        if (el.firstChild)
          el.insertBefore(fragment, el.firstChild);
        else
          el.appendChild(fragment);
      }

      if (config.lastRow > oldConfig.lastRow) {
        var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
        el.appendChild(fragment);
      }
    };

    this.$renderLinesFragment = function(config, firstRow, lastRow) {
      var fragment = this.element.ownerDocument.createDocumentFragment();
      var row = firstRow;
      var foldLine = this.session.getNextFoldLine(row);
      var foldStart = foldLine ? foldLine.start.row : Infinity;

      while (true) {
        if (row > foldStart) {
          row = foldLine.end.row+1;
          foldLine = this.session.getNextFoldLine(row, foldLine);
          foldStart = foldLine ? foldLine.start.row : Infinity;
        }
        if (row > lastRow)
          break;

        var container = dom.createElement("div");

        var html = [];
        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
        container.innerHTML = html.join("");
        if (this.$useLineGroups()) {
          container.className = 'ace_line_group';
          fragment.appendChild(container);
          container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

        } else {
          while(container.firstChild)
            fragment.appendChild(container.firstChild);
        }

        row++;
      }
      return fragment;
    };

    this.update = function(config) {
      this.config = config;

      var html = [];
      var firstRow = config.firstRow, lastRow = config.lastRow;

      var row = firstRow;
      var foldLine = this.session.getNextFoldLine(row);
      var foldStart = foldLine ? foldLine.start.row : Infinity;

      while (true) {
        if (row > foldStart) {
          row = foldLine.end.row+1;
          foldLine = this.session.getNextFoldLine(row, foldLine);
          foldStart = foldLine ? foldLine.start.row :Infinity;
        }
        if (row > lastRow)
          break;

        if (this.$useLineGroups())
          html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")

        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

        if (this.$useLineGroups())
          html.push("</div>"); // end the line group

        row++;
      }
      this.element.innerHTML = html.join("");
    };

    this.$textToken = {
      "text": true,
      "rparen": true,
      "lparen": true
    };

    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
      var self = this;
      var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
      var replaceFunc = function(c, a, b, tabIdx, idx4) {
        if (a) {
          return self.showInvisibles
            ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
            : c;
        } else if (c == "&") {
          return "&#38;";
        } else if (c == "<") {
          return "&#60;";
        } else if (c == ">") {
          return "&#62;";
        } else if (c == "\t") {
          var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
          screenColumn += tabSize - 1;
          return self.$tabStrings[tabSize];
        } else if (c == "\u3000") {
          var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
          var space = self.showInvisibles ? self.SPACE_CHAR : "";
          screenColumn += 1;
          return "<span class='" + classToUse + "' style='width:" +
            (self.config.characterWidth * 2) +
            "px'>" + space + "</span>";
        } else if (b) {
          return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
        } else {
          screenColumn += 1;
          return "<span class='ace_cjk' style='width:" +
            (self.config.characterWidth * 2) +
            "px'>" + c + "</span>";
        }
      };

      var output = value.replace(replaceReg, replaceFunc);

      if (!this.$textToken[token.type]) {
        var classes = "ace_" + token.type.replace(/\./g, " ace_");
        var style = "";
        if (token.type == "fold")
          style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
        stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
      }
      else {
        stringBuilder.push(output);
      }
      return screenColumn + value.length;
    };

    this.renderIndentGuide = function(stringBuilder, value, max) {
      var cols = value.search(this.$indentGuideRe);
      if (cols <= 0 || cols >= max)
        return value;
      if (value[0] == " ") {
        cols -= cols % this.tabSize;
        stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
        return value.substr(cols);
      } else if (value[0] == "\t") {
        stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
        return value.substr(cols);
      }
      return value;
    };

    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
      var chars = 0;
      var split = 0;
      var splitChars = splits[0];
      var screenColumn = 0;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var value = token.value;
        if (i == 0 && this.displayIndentGuides) {
          chars = value.length;
          value = this.renderIndentGuide(stringBuilder, value, splitChars);
          if (!value)
            continue;
          chars -= value.length;
        }

        if (chars + value.length < splitChars) {
          screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          chars += value.length;
        } else {
          while (chars + value.length >= splitChars) {
            screenColumn = this.$renderToken(
              stringBuilder, screenColumn,
              token, value.substring(0, splitChars - chars)
            );
            value = value.substring(splitChars - chars);
            chars = splitChars;

            if (!onlyContents) {
              stringBuilder.push("</div>",
                "<div class='ace_line' style='height:",
                this.config.lineHeight, "px'>"
              );
            }

            stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

            split ++;
            screenColumn = 0;
            splitChars = splits[split] || Number.MAX_VALUE;
          }
          if (value.length != 0) {
            chars += value.length;
            screenColumn = this.$renderToken(
              stringBuilder, screenColumn, token, value
            );
          }
        }
      }
    };

    this.$renderSimpleLine = function(stringBuilder, tokens) {
      var screenColumn = 0;
      var token = tokens[0];
      var value = token.value;
      if (this.displayIndentGuides)
        value = this.renderIndentGuide(stringBuilder, value);
      if (value)
        screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
      for (var i = 1; i < tokens.length; i++) {
        token = tokens[i];
        value = token.value;
        screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
      }
    };
    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
      if (!foldLine && foldLine != false)
        foldLine = this.session.getFoldLine(row);

      if (foldLine)
        var tokens = this.$getFoldLineTokens(row, foldLine);
      else
        var tokens = this.session.getTokens(row);


      if (!onlyContents) {
        stringBuilder.push(
          "<div class='ace_line' style='height:",
          this.config.lineHeight * (
            this.$useLineGroups() ? 1 :this.session.getRowLength(row)
          ), "px'>"
        );
      }

      if (tokens.length) {
        var splits = this.session.getRowSplitData(row);
        if (splits && splits.length)
          this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
        else
          this.$renderSimpleLine(stringBuilder, tokens);
      }

      if (this.showInvisibles) {
        if (foldLine)
          row = foldLine.end.row

        stringBuilder.push(
          "<span class='ace_invisible ace_invisible_eol'>",
          row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
          "</span>"
        );
      }
      if (!onlyContents)
        stringBuilder.push("</div>");
    };

    this.$getFoldLineTokens = function(row, foldLine) {
      var session = this.session;
      var renderTokens = [];

      function addTokens(tokens, from, to) {
        var idx = 0, col = 0;
        while ((col + tokens[idx].value.length) < from) {
          col += tokens[idx].value.length;
          idx++;

          if (idx == tokens.length)
            return;
        }
        if (col != from) {
          var value = tokens[idx].value.substring(from - col);
          if (value.length > (to - from))
            value = value.substring(0, to - from);

          renderTokens.push({
            type: tokens[idx].type,
            value: value
          });

          col = from + value.length;
          idx += 1;
        }

        while (col < to && idx < tokens.length) {
          var value = tokens[idx].value;
          if (value.length + col > to) {
            renderTokens.push({
              type: tokens[idx].type,
              value: value.substring(0, to - col)
            });
          } else
            renderTokens.push(tokens[idx]);
          col += value.length;
          idx += 1;
        }
      }

      var tokens = session.getTokens(row);
      foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
        if (placeholder != null) {
          renderTokens.push({
            type: "fold",
            value: placeholder
          });
        } else {
          if (isNewRow)
            tokens = session.getTokens(row);

          if (tokens.length)
            addTokens(tokens, lastColumn, column);
        }
      }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

      return renderTokens;
    };

    this.$useLineGroups = function() {
      return this.session.getUseWrapMode();
    };

    this.destroy = function() {
      clearInterval(this.$pollSizeChangesTimer);
      if (this.$measureNode)
        this.$measureNode.parentNode.removeChild(this.$measureNode);
      delete this.$measureNode;
    };

  }).call(Text.prototype);

  exports.Text = Text;

});

ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
  "use strict";

  var dom = require("../lib/dom");
  var isIE8;

  var Cursor = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);

    if (isIE8 === undefined)
      isIE8 = !("opacity" in this.element.style);

    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;

    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, "ace_hidden-cursors");
    this.$updateCursors = (isIE8
      ? this.$updateVisibility
      : this.$updateOpacity).bind(this);
  };

  (function() {

    this.$updateVisibility = function(val) {
      var cursors = this.cursors;
      for (var i = cursors.length; i--; )
        cursors[i].style.visibility = val ? "" : "hidden";
    };
    this.$updateOpacity = function(val) {
      var cursors = this.cursors;
      for (var i = cursors.length; i--; )
        cursors[i].style.opacity = val ? "" : "0";
    };


    this.$padding = 0;
    this.setPadding = function(padding) {
      this.$padding = padding;
    };

    this.setSession = function(session) {
      this.session = session;
    };

    this.setBlinking = function(blinking) {
      if (blinking != this.isBlinking){
        this.isBlinking = blinking;
        this.restartTimer();
      }
    };

    this.setBlinkInterval = function(blinkInterval) {
      if (blinkInterval != this.blinkInterval){
        this.blinkInterval = blinkInterval;
        this.restartTimer();
      }
    };

    this.setSmoothBlinking = function(smoothBlinking) {
      if (smoothBlinking != this.smoothBlinking && !isIE8) {
        this.smoothBlinking = smoothBlinking;
        dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
        this.$updateCursors(true);
        this.$updateCursors = (this.$updateOpacity).bind(this);
        this.restartTimer();
      }
    };

    this.addCursor = function() {
      var el = dom.createElement("div");
      el.className = "ace_cursor";
      this.element.appendChild(el);
      this.cursors.push(el);
      return el;
    };

    this.removeCursor = function() {
      if (this.cursors.length > 1) {
        var el = this.cursors.pop();
        el.parentNode.removeChild(el);
        return el;
      }
    };

    this.hideCursor = function() {
      this.isVisible = false;
      dom.addCssClass(this.element, "ace_hidden-cursors");
      this.restartTimer();
    };

    this.showCursor = function() {
      this.isVisible = true;
      dom.removeCssClass(this.element, "ace_hidden-cursors");
      this.restartTimer();
    };

    this.restartTimer = function() {
      var update = this.$updateCursors;
      clearInterval(this.intervalId);
      clearTimeout(this.timeoutId);
      if (this.smoothBlinking) {
        dom.removeCssClass(this.element, "ace_smooth-blinking");
      }

      update(true);

      if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
        return;

      if (this.smoothBlinking) {
        setTimeout(function(){
          dom.addCssClass(this.element, "ace_smooth-blinking");
        }.bind(this));
      }

      var blink = function(){
        this.timeoutId = setTimeout(function() {
          update(false);
        }, 0.6 * this.blinkInterval);
      }.bind(this);

      this.intervalId = setInterval(function() {
        update(true);
        blink();
      }, this.blinkInterval);

      blink();
    };

    this.getPixelPosition = function(position, onScreen) {
      if (!this.config || !this.session)
        return {left : 0, top : 0};

      if (!position)
        position = this.session.selection.getCursor();
      var pos = this.session.documentToScreenPosition(position);
      var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
      var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
        this.config.lineHeight;

      return {left : cursorLeft, top : cursorTop};
    };

    this.update = function(config) {
      this.config = config;

      var selections = this.session.$selectionMarkers;
      var i = 0, cursorIndex = 0;

      if (selections === undefined || selections.length === 0){
        selections = [{cursor: null}];
      }

      for (var i = 0, n = selections.length; i < n; i++) {
        var pixelPos = this.getPixelPosition(selections[i].cursor, true);
        if ((pixelPos.top > config.height + config.offset ||
          pixelPos.top < 0) && i > 1) {
          continue;
        }

        var style = (this.cursors[cursorIndex++] || this.addCursor()).style;

        if (!this.drawCursor) {
          style.left = pixelPos.left + "px";
          style.top = pixelPos.top + "px";
          style.width = config.characterWidth + "px";
          style.height = config.lineHeight + "px";
        } else {
          this.drawCursor(style, pixelPos, config, selections[i], this.session);
        }
      }
      while (this.cursors.length > cursorIndex)
        this.removeCursor();

      var overwrite = this.session.getOverwrite();
      this.$setOverwrite(overwrite);
      this.$pixelPos = pixelPos;
      this.restartTimer();
    };

    this.drawCursor = null;

    this.$setOverwrite = function(overwrite) {
      if (overwrite != this.overwrite) {
        this.overwrite = overwrite;
        if (overwrite)
          dom.addCssClass(this.element, "ace_overwrite-cursors");
        else
          dom.removeCssClass(this.element, "ace_overwrite-cursors");
      }
    };

    this.destroy = function() {
      clearInterval(this.intervalId);
      clearTimeout(this.timeoutId);
    };

  }).call(Cursor.prototype);

  exports.Cursor = Cursor;

});

ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var dom = require("./lib/dom");
  var event = require("./lib/event");
  var EventEmitter = require("./lib/event_emitter").EventEmitter;
  var MAX_SCROLL_H = 0x8000;
  var ScrollBar = function(parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

    this.inner = dom.createElement("div");
    this.inner.className = "ace_scrollbar-inner";
    this.element.appendChild(this.inner);

    parent.appendChild(this.element);

    this.setVisible(false);
    this.skipEvent = false;

    event.addListener(this.element, "scroll", this.onScroll.bind(this));
    event.addListener(this.element, "mousedown", event.preventDefault);
  };

  (function() {
    oop.implement(this, EventEmitter);

    this.setVisible = function(isVisible) {
      this.element.style.display = isVisible ? "" : "none";
      this.isVisible = isVisible;
      this.coeff = 1;
    };
  }).call(ScrollBar.prototype);
  var VScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    this.scrollHeight = 0;
    renderer.$scrollbarWidth =
      this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
      this.element.style.width = (this.width || 15) + 5 + "px";
  };

  oop.inherits(VScrollBar, ScrollBar);

  (function() {

    this.classSuffix = '-v';
    this.onScroll = function() {
      if (!this.skipEvent) {
        this.scrollTop = this.element.scrollTop;
        if (this.coeff != 1) {
          var h = this.element.clientHeight / this.scrollHeight;
          this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
        }
        this._emit("scroll", {data: this.scrollTop});
      }
      this.skipEvent = false;
    };
    this.getWidth = function() {
      return this.isVisible ? this.width : 0;
    };
    this.setHeight = function(height) {
      this.element.style.height = height + "px";
    };
    this.setInnerHeight =
      this.setScrollHeight = function(height) {
        this.scrollHeight = height;
        if (height > MAX_SCROLL_H) {
          this.coeff = MAX_SCROLL_H / height;
          height = MAX_SCROLL_H;
        } else if (this.coeff != 1) {
          this.coeff = 1
        }
        this.inner.style.height = height + "px";
      };
    this.setScrollTop = function(scrollTop) {
      if (this.scrollTop != scrollTop) {
        this.skipEvent = true;
        this.scrollTop = scrollTop;
        this.element.scrollTop = scrollTop * this.coeff;
      }
    };

  }).call(VScrollBar.prototype);
  var HScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
      this.element.style.height = (this.height || 15) + 5 + "px";
  };

  oop.inherits(HScrollBar, ScrollBar);

  (function() {

    this.classSuffix = '-h';
    this.onScroll = function() {
      if (!this.skipEvent) {
        this.scrollLeft = this.element.scrollLeft;
        this._emit("scroll", {data: this.scrollLeft});
      }
      this.skipEvent = false;
    };
    this.getHeight = function() {
      return this.isVisible ? this.height : 0;
    };
    this.setWidth = function(width) {
      this.element.style.width = width + "px";
    };
    this.setInnerWidth = function(width) {
      this.inner.style.width = width + "px";
    };
    this.setScrollWidth = function(width) {
      this.inner.style.width = width + "px";
    };
    this.setScrollLeft = function(scrollLeft) {
      if (this.scrollLeft != scrollLeft) {
        this.skipEvent = true;
        this.scrollLeft = this.element.scrollLeft = scrollLeft;
      }
    };

  }).call(HScrollBar.prototype);


  exports.ScrollBar = VScrollBar; // backward compatibility
  exports.ScrollBarV = VScrollBar; // backward compatibility
  exports.ScrollBarH = HScrollBar; // backward compatibility

  exports.VScrollBar = VScrollBar;
  exports.HScrollBar = HScrollBar;
});

ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(require, exports, module) {
  "use strict";

  var event = require("./lib/event");


  var RenderLoop = function(onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.window = win || window;
  };

  (function() {


    this.schedule = function(change) {
      this.changes = this.changes | change;
      if (!this.pending && this.changes) {
        this.pending = true;
        var _self = this;
        event.nextFrame(function() {
          _self.pending = false;
          var changes;
          while (changes = _self.changes) {
            _self.changes = 0;
            _self.onRender(changes);
          }
        }, this.window);
      }
    };

  }).call(RenderLoop.prototype);

  exports.RenderLoop = RenderLoop;
});

ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module) {

  var oop = require("../lib/oop");
  var dom = require("../lib/dom");
  var lang = require("../lib/lang");
  var useragent = require("../lib/useragent");
  var EventEmitter = require("../lib/event_emitter").EventEmitter;

  var CHAR_COUNT = 0;

  var FontMetrics = exports.FontMetrics = function(parentEl) {
    this.el = dom.createElement("div");
    this.$setMeasureNodeStyles(this.el.style, true);

    this.$main = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$main.style);

    this.$measureNode = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$measureNode.style);


    this.el.appendChild(this.$main);
    this.el.appendChild(this.$measureNode);
    parentEl.appendChild(this.el);

    if (!CHAR_COUNT)
      this.$testFractionalRect();
    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);

    this.$characterSize = {width: 0, height: 0};
    this.checkForSizeChanges();
  };

  (function() {

    oop.implement(this, EventEmitter);

    this.$characterSize = {width: 0, height: 0};

    this.$testFractionalRect = function() {
      var el = dom.createElement("div");
      this.$setMeasureNodeStyles(el.style);
      el.style.width = "0.2px";
      document.documentElement.appendChild(el);
      var w = el.getBoundingClientRect().width;
      if (w > 0 && w < 1)
        CHAR_COUNT = 50;
      else
        CHAR_COUNT = 100;
      el.parentNode.removeChild(el);
    };

    this.$setMeasureNodeStyles = function(style, isRoot) {
      style.width = style.height = "auto";
      style.left = style.top = "0px";
      style.visibility = "hidden";
      style.position = "absolute";
      style.whiteSpace = "pre";

      if (useragent.isIE < 8) {
        style["font-family"] = "inherit";
      } else {
        style.font = "inherit";
      }
      style.overflow = isRoot ? "hidden" : "visible";
    };

    this.checkForSizeChanges = function() {
      var size = this.$measureSizes();
      if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
        this.$measureNode.style.fontWeight = "bold";
        var boldSize = this.$measureSizes();
        this.$measureNode.style.fontWeight = "";
        this.$characterSize = size;
        this.charSizes = Object.create(null);
        this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
        this._emit("changeCharacterSize", {data: size});
      }
    };

    this.$pollSizeChanges = function() {
      if (this.$pollSizeChangesTimer)
        return this.$pollSizeChangesTimer;
      var self = this;
      return this.$pollSizeChangesTimer = setInterval(function() {
        self.checkForSizeChanges();
      }, 500);
    };

    this.setPolling = function(val) {
      if (val) {
        this.$pollSizeChanges();
      } else if (this.$pollSizeChangesTimer) {
        clearInterval(this.$pollSizeChangesTimer);
        this.$pollSizeChangesTimer = 0;
      }
    };

    this.$measureSizes = function() {
      if (CHAR_COUNT === 50) {
        var rect = null;
        try {
          rect = this.$measureNode.getBoundingClientRect();
        } catch(e) {
          rect = {width: 0, height:0 };
        }
        var size = {
          height: rect.height,
          width: rect.width / CHAR_COUNT
        };
      } else {
        var size = {
          height: this.$measureNode.clientHeight,
          width: this.$measureNode.clientWidth / CHAR_COUNT
        };
      }
      if (size.width === 0 || size.height === 0)
        return null;
      return size;
    };

    this.$measureCharWidth = function(ch) {
      this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
      var rect = this.$main.getBoundingClientRect();
      return rect.width / CHAR_COUNT;
    };

    this.getCharacterWidth = function(ch) {
      var w = this.charSizes[ch];
      if (w === undefined) {
        w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
      }
      return w;
    };

    this.destroy = function() {
      clearInterval(this.$pollSizeChangesTimer);
      if (this.el && this.el.parentNode)
        this.el.parentNode.removeChild(this.el);
    };

  }).call(FontMetrics.prototype);

});

ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/lib/useragent","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var dom = require("./lib/dom");
  var config = require("./config");
  var useragent = require("./lib/useragent");
  var GutterLayer = require("./layer/gutter").Gutter;
  var MarkerLayer = require("./layer/marker").Marker;
  var TextLayer = require("./layer/text").Text;
  var CursorLayer = require("./layer/cursor").Cursor;
  var HScrollBar = require("./scrollbar").HScrollBar;
  var VScrollBar = require("./scrollbar").VScrollBar;
  var RenderLoop = require("./renderloop").RenderLoop;
  var FontMetrics = require("./layer/font_metrics").FontMetrics;
  var EventEmitter = require("./lib/event_emitter").EventEmitter;
  var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
";

  dom.importCssString(editorCss, "ace_editor.css");

  var VirtualRenderer = function(container, theme) {
    var _self = this;

    this.container = container || dom.createElement("div");
    this.$keepTextAreaAtCursor = !useragent.isOldIE;

    dom.addCssClass(this.container, "ace_editor");

    this.setTheme(theme);

    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);

    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    this.container.appendChild(this.scroller);

    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);

    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

    this.$markerBack = new MarkerLayer(this.content);

    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;

    this.$markerFront = new MarkerLayer(this.content);

    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;

    this.scrollBar =
      this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.addEventListener("scroll", function(e) {
      if (!_self.$scrollAnimation)
        _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.addEventListener("scroll", function(e) {
      if (!_self.$scrollAnimation)
        _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });

    this.scrollTop = 0;
    this.scrollLeft = 0;

    this.cursorPos = {
      row : 0,
      column : 0
    };

    this.$fontMetrics = new FontMetrics(this.container);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
      _self.updateCharacterSize();
      _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
      _self._signal("changeCharacterSize", e);
    });

    this.$size = {
      width: 0,
      height: 0,
      scrollerHeight: 0,
      scrollerWidth: 0,
      $dirty: true
    };

    this.layerConfig = {
      width : 1,
      padding : 0,
      firstRow : 0,
      firstRowScreen: 0,
      lastRow : 0,
      lineHeight : 0,
      characterWidth : 0,
      minHeight : 1,
      maxHeight : 1,
      offset : 0,
      height : 1,
      gutterOffset: 1
    };

    this.scrollMargin = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      v: 0,
      h: 0
    };

    this.$loop = new RenderLoop(
      this.$renderChanges.bind(this),
      this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);

    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._emit("renderer", this);
  };

  (function() {

    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;

    oop.implement(this, EventEmitter);

    this.updateCharacterSize = function() {
      if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
        this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
        this.setStyle("ace_nobold", !this.$allowBoldFonts);
      }

      this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
      this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
      this.$updatePrintMargin();
    };
    this.setSession = function(session) {
      if (this.session)
        this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);

      this.session = session;
      if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
        session.setScrollTop(-this.scrollMargin.top);

      this.$cursorLayer.setSession(session);
      this.$markerBack.setSession(session);
      this.$markerFront.setSession(session);
      this.$gutterLayer.setSession(session);
      this.$textLayer.setSession(session);
      if (!session)
        return;

      this.$loop.schedule(this.CHANGE_FULL);
      this.session.$setFontMetrics(this.$fontMetrics);
      this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;

      this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
      this.onChangeNewLineMode()
      this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    };
    this.updateLines = function(firstRow, lastRow, force) {
      if (lastRow === undefined)
        lastRow = Infinity;

      if (!this.$changedLines) {
        this.$changedLines = {
          firstRow: firstRow,
          lastRow: lastRow
        };
      }
      else {
        if (this.$changedLines.firstRow > firstRow)
          this.$changedLines.firstRow = firstRow;

        if (this.$changedLines.lastRow < lastRow)
          this.$changedLines.lastRow = lastRow;
      }
      if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
        if (force)
          this.$changedLines.lastRow = this.layerConfig.lastRow;
        else
          return;
      }
      if (this.$changedLines.firstRow > this.layerConfig.lastRow)
        return;
      this.$loop.schedule(this.CHANGE_LINES);
    };

    this.onChangeNewLineMode = function() {
      this.$loop.schedule(this.CHANGE_TEXT);
      this.$textLayer.$updateEolChar();
    };

    this.onChangeTabSize = function() {
      this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
      this.$textLayer.onChangeTabSize();
    };
    this.updateText = function() {
      this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function(force) {
      if (force)
        this.$renderChanges(this.CHANGE_FULL, true);
      else
        this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function() {
      this.$textLayer.checkForSizeChanges();
    };

    this.$changes = 0;
    this.$updateSizeAsync = function() {
      if (this.$loop.pending)
        this.$size.$dirty = true;
      else
        this.onResize();
    };
    this.onResize = function(force, gutterWidth, width, height) {
      if (this.resizing > 2)
        return;
      else if (this.resizing > 0)
        this.resizing++;
      else
        this.resizing = force ? 1 : 0;
      var el = this.container;
      if (!height)
        height = el.clientHeight || el.scrollHeight;
      if (!width)
        width = el.clientWidth || el.scrollWidth;
      var changes = this.$updateCachedSize(force, gutterWidth, width, height);


      if (!this.$size.scrollerHeight || (!width && !height))
        return this.resizing = 0;

      if (force)
        this.$gutterLayer.$padding = null;

      if (force)
        this.$renderChanges(changes | this.$changes, true);
      else
        this.$loop.schedule(changes | this.$changes);

      if (this.resizing)
        this.resizing = 0;
      this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
    };

    this.$updateCachedSize = function(force, gutterWidth, width, height) {
      height -= (this.$extraHeight || 0);
      var changes = 0;
      var size = this.$size;
      var oldSize = {
        width: size.width,
        height: size.height,
        scrollerHeight: size.scrollerHeight,
        scrollerWidth: size.scrollerWidth
      };
      if (height && (force || size.height != height)) {
        size.height = height;
        changes |= this.CHANGE_SIZE;

        size.scrollerHeight = size.height;
        if (this.$horizScroll)
          size.scrollerHeight -= this.scrollBarH.getHeight();
        this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

        changes = changes | this.CHANGE_SCROLL;
      }

      if (width && (force || size.width != width)) {
        changes |= this.CHANGE_SIZE;
        size.width = width;

        if (gutterWidth == null)
          gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;

        this.gutterWidth = gutterWidth;

        this.scrollBarH.element.style.left =
          this.scroller.style.left = gutterWidth + "px";
        size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());

        this.scrollBarH.element.style.right =
          this.scroller.style.right = this.scrollBarV.getWidth() + "px";
        this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

        if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
          changes |= this.CHANGE_FULL;
      }

      size.$dirty = !width || !height;

      if (changes)
        this._signal("resize", oldSize);

      return changes;
    };

    this.onGutterResize = function() {
      var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
      if (gutterWidth != this.gutterWidth)
        this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

      if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
        this.$loop.schedule(this.CHANGE_FULL);
      } else if (this.$size.$dirty) {
        this.$loop.schedule(this.CHANGE_FULL);
      } else {
        this.$computeLayerConfig();
        this.$loop.schedule(this.CHANGE_MARKER);
      }
    };
    this.adjustWrapLimit = function() {
      var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
      var limit = Math.floor(availableWidth / this.characterWidth);
      return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };
    this.setAnimatedScroll = function(shouldAnimate){
      this.setOption("animatedScroll", shouldAnimate);
    };
    this.getAnimatedScroll = function() {
      return this.$animatedScroll;
    };
    this.setShowInvisibles = function(showInvisibles) {
      this.setOption("showInvisibles", showInvisibles);
    };
    this.getShowInvisibles = function() {
      return this.getOption("showInvisibles");
    };
    this.getDisplayIndentGuides = function() {
      return this.getOption("displayIndentGuides");
    };

    this.setDisplayIndentGuides = function(display) {
      this.setOption("displayIndentGuides", display);
    };
    this.setShowPrintMargin = function(showPrintMargin) {
      this.setOption("showPrintMargin", showPrintMargin);
    };
    this.getShowPrintMargin = function() {
      return this.getOption("showPrintMargin");
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
      this.setOption("printMarginColumn", showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
      return this.getOption("printMarginColumn");
    };
    this.getShowGutter = function(){
      return this.getOption("showGutter");
    };
    this.setShowGutter = function(show){
      return this.setOption("showGutter", show);
    };

    this.getFadeFoldWidgets = function(){
      return this.getOption("fadeFoldWidgets")
    };

    this.setFadeFoldWidgets = function(show) {
      this.setOption("fadeFoldWidgets", show);
    };

    this.setHighlightGutterLine = function(shouldHighlight) {
      this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
      return this.getOption("highlightGutterLine");
    };

    this.$updateGutterLineHighlight = function() {
      var pos = this.$cursorLayer.$pixelPos;
      var height = this.layerConfig.lineHeight;
      if (this.session.getUseWrapMode()) {
        var cursor = this.session.selection.getCursor();
        cursor.column = 0;
        pos = this.$cursorLayer.getPixelPosition(cursor, true);
        height *= this.session.getRowLength(cursor.row);
      }
      this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
      this.$gutterLineHighlight.style.height = height + "px";
    };

    this.$updatePrintMargin = function() {
      if (!this.$showPrintMargin && !this.$printMarginEl)
        return;

      if (!this.$printMarginEl) {
        var containerEl = dom.createElement("div");
        containerEl.className = "ace_layer ace_print-margin-layer";
        this.$printMarginEl = dom.createElement("div");
        this.$printMarginEl.className = "ace_print-margin";
        containerEl.appendChild(this.$printMarginEl);
        this.content.insertBefore(containerEl, this.content.firstChild);
      }

      var style = this.$printMarginEl.style;
      style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
      style.visibility = this.$showPrintMargin ? "visible" : "hidden";

      if (this.session && this.session.$wrap == -1)
        this.adjustWrapLimit();
    };
    this.getContainerElement = function() {
      return this.container;
    };
    this.getMouseEventTarget = function() {
      return this.scroller;
    };
    this.getTextAreaContainer = function() {
      return this.container;
    };
    this.$moveTextAreaToCursor = function() {
      if (!this.$keepTextAreaAtCursor)
        return;
      var config = this.layerConfig;
      var posTop = this.$cursorLayer.$pixelPos.top;
      var posLeft = this.$cursorLayer.$pixelPos.left;
      posTop -= config.offset;

      var style = this.textarea.style;
      var h = this.lineHeight;
      if (posTop < 0 || posTop > config.height - h) {
        style.top = style.left = "0";
        return;
      }

      var w = this.characterWidth;
      if (this.$composition) {
        var val = this.textarea.value.replace(/^\x01+/, "");
        w *= (this.session.$getStringScreenWidth(val)[0]+2);
        h += 2;
      }
      posLeft -= this.scrollLeft;
      if (posLeft > this.$size.scrollerWidth - w)
        posLeft = this.$size.scrollerWidth - w;

      posLeft += this.gutterWidth;
      style.height = h + "px";
      style.width = w + "px";
      style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
      style.top = Math.min(posTop, this.$size.height - h) + "px";
    };
    this.getFirstVisibleRow = function() {
      return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function() {
      return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function() {
      var config = this.layerConfig;
      var lastRow = config.lastRow
      var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
      if (top - this.session.getScrollTop() > config.height - config.lineHeight)
        return lastRow - 1;
      return lastRow;
    };
    this.getLastVisibleRow = function() {
      return this.layerConfig.lastRow;
    };

    this.$padding = null;
    this.setPadding = function(padding) {
      this.$padding = padding;
      this.$textLayer.setPadding(padding);
      this.$cursorLayer.setPadding(padding);
      this.$markerFront.setPadding(padding);
      this.$markerBack.setPadding(padding);
      this.$loop.schedule(this.CHANGE_FULL);
      this.$updatePrintMargin();
    };

    this.setScrollMargin = function(top, bottom, left, right) {
      var sm = this.scrollMargin;
      sm.top = top|0;
      sm.bottom = bottom|0;
      sm.right = right|0;
      sm.left = left|0;
      sm.v = sm.top + sm.bottom;
      sm.h = sm.left + sm.right;
      if (sm.top && this.scrollTop <= 0 && this.session)
        this.session.setScrollTop(-sm.top);
      this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function() {
      return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
      this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function() {
      return this.$vScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
      this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    };

    this.$updateScrollBarV = function() {
      var scrollHeight = this.layerConfig.maxHeight;
      var scrollerHeight = this.$size.scrollerHeight;
      if (!this.$maxLines && this.$scrollPastEnd) {
        scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
        if (this.scrollTop > scrollHeight - scrollerHeight) {
          scrollHeight = this.scrollTop + scrollerHeight;
          this.scrollBarV.scrollTop = null;
        }
      }
      this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
      this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function() {
      this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
      this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };

    this.$frozen = false;
    this.freeze = function() {
      this.$frozen = true;
    };

    this.unfreeze = function() {
      this.$frozen = false;
    };

    this.$renderChanges = function(changes, force) {
      if (this.$changes) {
        changes |= this.$changes;
        this.$changes = 0;
      }
      if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
        this.$changes |= changes;
        return;
      }
      if (this.$size.$dirty) {
        this.$changes |= changes;
        return this.onResize(true);
      }
      if (!this.lineHeight) {
        this.$textLayer.checkForSizeChanges();
      }

      this._signal("beforeRender");
      var config = this.layerConfig;
      if (changes & this.CHANGE_FULL ||
        changes & this.CHANGE_SIZE ||
        changes & this.CHANGE_TEXT ||
        changes & this.CHANGE_LINES ||
        changes & this.CHANGE_SCROLL ||
        changes & this.CHANGE_H_SCROLL
      ) {
        changes |= this.$computeLayerConfig();
        if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
          var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
          if (st > 0) {
            this.scrollTop = st;
            changes = changes | this.CHANGE_SCROLL;
            changes |= this.$computeLayerConfig();
          }
        }
        config = this.layerConfig;
        this.$updateScrollBarV();
        if (changes & this.CHANGE_H_SCROLL)
          this.$updateScrollBarH();
        this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
        this.content.style.marginTop = (-config.offset) + "px";
        this.content.style.width = config.width + 2 * this.$padding + "px";
        this.content.style.height = config.minHeight + "px";
      }
      if (changes & this.CHANGE_H_SCROLL) {
        this.content.style.marginLeft = -this.scrollLeft + "px";
        this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
      }
      if (changes & this.CHANGE_FULL) {
        this.$textLayer.update(config);
        if (this.$showGutter)
          this.$gutterLayer.update(config);
        this.$markerBack.update(config);
        this.$markerFront.update(config);
        this.$cursorLayer.update(config);
        this.$moveTextAreaToCursor();
        this.$highlightGutterLine && this.$updateGutterLineHighlight();
        this._signal("afterRender");
        return;
      }
      if (changes & this.CHANGE_SCROLL) {
        if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
          this.$textLayer.update(config);
        else
          this.$textLayer.scrollLines(config);

        if (this.$showGutter)
          this.$gutterLayer.update(config);
        this.$markerBack.update(config);
        this.$markerFront.update(config);
        this.$cursorLayer.update(config);
        this.$highlightGutterLine && this.$updateGutterLineHighlight();
        this.$moveTextAreaToCursor();
        this._signal("afterRender");
        return;
      }

      if (changes & this.CHANGE_TEXT) {
        this.$textLayer.update(config);
        if (this.$showGutter)
          this.$gutterLayer.update(config);
      }
      else if (changes & this.CHANGE_LINES) {
        if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
          this.$gutterLayer.update(config);
      }
      else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
        if (this.$showGutter)
          this.$gutterLayer.update(config);
      }

      if (changes & this.CHANGE_CURSOR) {
        this.$cursorLayer.update(config);
        this.$moveTextAreaToCursor();
        this.$highlightGutterLine && this.$updateGutterLineHighlight();
      }

      if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
        this.$markerFront.update(config);
      }

      if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
        this.$markerBack.update(config);
      }

      this._signal("afterRender");
    };


    this.$autosize = function() {
      var height = this.session.getScreenLength() * this.lineHeight;
      var maxHeight = this.$maxLines * this.lineHeight;
      var desiredHeight = Math.min(maxHeight,
          Math.max((this.$minLines || 1) * this.lineHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
      if (this.$horizScroll)
        desiredHeight += this.scrollBarH.getHeight();
      if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
        desiredHeight = this.$maxPixelHeight;
      var vScroll = height > maxHeight;

      if (desiredHeight != this.desiredHeight ||
        this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
        if (vScroll != this.$vScroll) {
          this.$vScroll = vScroll;
          this.scrollBarV.setVisible(vScroll);
        }

        var w = this.container.clientWidth;
        this.container.style.height = desiredHeight + "px";
        this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
        this.desiredHeight = desiredHeight;

        this._signal("autosize");
      }
    };

    this.$computeLayerConfig = function() {
      var session = this.session;
      var size = this.$size;

      var hideScrollbars = size.height <= 2 * this.lineHeight;
      var screenLines = this.session.getScreenLength();
      var maxHeight = screenLines * this.lineHeight;

      var longestLine = this.$getLongestLine();

      var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
        size.scrollerWidth - longestLine - 2 * this.$padding < 0);

      var hScrollChanged = this.$horizScroll !== horizScroll;
      if (hScrollChanged) {
        this.$horizScroll = horizScroll;
        this.scrollBarH.setVisible(horizScroll);
      }
      var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
      if (this.$maxLines && this.lineHeight > 1)
        this.$autosize();

      var offset = this.scrollTop % this.lineHeight;
      var minHeight = size.scrollerHeight + this.lineHeight;

      var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
        ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
        : 0;
      maxHeight += scrollPastEnd;

      var sm = this.scrollMargin;
      this.session.setScrollTop(Math.max(-sm.top,
        Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

      this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft,
        longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));

      var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
        size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
      var vScrollChanged = vScrollBefore !== vScroll;
      if (vScrollChanged) {
        this.$vScroll = vScroll;
        this.scrollBarV.setVisible(vScroll);
      }

      var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
      var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
      var lastRow = firstRow + lineCount;
      var firstRowScreen, firstRowHeight;
      var lineHeight = this.lineHeight;
      firstRow = session.screenToDocumentRow(firstRow, 0);
      var foldLine = session.getFoldLine(firstRow);
      if (foldLine) {
        firstRow = foldLine.start.row;
      }

      firstRowScreen = session.documentToScreenRow(firstRow, 0);
      firstRowHeight = session.getRowLength(firstRow) * lineHeight;

      lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
      minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
        firstRowHeight;

      offset = this.scrollTop - firstRowScreen * lineHeight;

      var changes = 0;
      if (this.layerConfig.width != longestLine)
        changes = this.CHANGE_H_SCROLL;
      if (hScrollChanged || vScrollChanged) {
        changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
        this._signal("scrollbarVisibilityChanged");
        if (vScrollChanged)
          longestLine = this.$getLongestLine();
      }

      this.layerConfig = {
        width : longestLine,
        padding : this.$padding,
        firstRow : firstRow,
        firstRowScreen: firstRowScreen,
        lastRow : lastRow,
        lineHeight : lineHeight,
        characterWidth : this.characterWidth,
        minHeight : minHeight,
        maxHeight : maxHeight,
        offset : offset,
        gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
        height : this.$size.scrollerHeight
      };

      return changes;
    };

    this.$updateLines = function() {
      var firstRow = this.$changedLines.firstRow;
      var lastRow = this.$changedLines.lastRow;
      this.$changedLines = null;

      var layerConfig = this.layerConfig;

      if (firstRow > layerConfig.lastRow + 1) { return; }
      if (lastRow < layerConfig.firstRow) { return; }
      if (lastRow === Infinity) {
        if (this.$showGutter)
          this.$gutterLayer.update(layerConfig);
        this.$textLayer.update(layerConfig);
        return;
      }
      this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
      return true;
    };

    this.$getLongestLine = function() {
      var charCount = this.session.getScreenWidth();
      if (this.showInvisibles && !this.session.$useWrapMode)
        charCount += 1;

      return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function() {
      this.$markerFront.setMarkers(this.session.getMarkers(true));
      this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function() {
      this.$markerBack.setMarkers(this.session.getMarkers());
      this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function(row, className){
      this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function(row, className){
      this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function(rows) {
      this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function(annotations) {
      this.$gutterLayer.setAnnotations(annotations);
      this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function() {
      this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function() {
      this.$cursorLayer.hideCursor();
    };
    this.showCursor = function() {
      this.$cursorLayer.showCursor();
    };

    this.scrollSelectionIntoView = function(anchor, lead, offset) {
      this.scrollCursorIntoView(anchor, offset);
      this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
      if (this.$size.scrollerHeight === 0)
        return;

      var pos = this.$cursorLayer.getPixelPosition(cursor);

      var left = pos.left;
      var top = pos.top;

      var topMargin = $viewMargin && $viewMargin.top || 0;
      var bottomMargin = $viewMargin && $viewMargin.bottom || 0;

      var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;

      if (scrollTop + topMargin > top) {
        if (offset && scrollTop + topMargin > top + this.lineHeight)
          top -= offset * this.$size.scrollerHeight;
        if (top === 0)
          top = -this.scrollMargin.top;
        this.session.setScrollTop(top);
      } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
        if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
          top += offset * this.$size.scrollerHeight;
        this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
      }

      var scrollLeft = this.scrollLeft;

      if (scrollLeft > left) {
        if (left < this.$padding + 2 * this.layerConfig.characterWidth)
          left = -this.scrollMargin.left;
        this.session.setScrollLeft(left);
      } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
        this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
      } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
        this.session.setScrollLeft(0);
      }
    };
    this.getScrollTop = function() {
      return this.session.getScrollTop();
    };
    this.getScrollLeft = function() {
      return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function() {
      return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function() {
      return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function(row) {
      this.session.setScrollTop(row * this.lineHeight);
    };

    this.alignCursor = function(cursor, alignment) {
      if (typeof cursor == "number")
        cursor = {row: cursor, column: 0};

      var pos = this.$cursorLayer.getPixelPosition(cursor);
      var h = this.$size.scrollerHeight - this.lineHeight;
      var offset = pos.top - h * (alignment || 0);

      this.session.setScrollTop(offset);
      return offset;
    };

    this.STEPS = 8;
    this.$calcSteps = function(fromValue, toValue){
      var i = 0;
      var l = this.STEPS;
      var steps = [];

      var func  = function(t, x_min, dx) {
        return dx * (Math.pow(t - 1, 3) + 1) + x_min;
      };

      for (i = 0; i < l; ++i)
        steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

      return steps;
    };
    this.scrollToLine = function(line, center, animate, callback) {
      var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
      var offset = pos.top;
      if (center)
        offset -= this.$size.scrollerHeight / 2;

      var initialScroll = this.scrollTop;
      this.session.setScrollTop(offset);
      if (animate !== false)
        this.animateScrolling(initialScroll, callback);
    };

    this.animateScrolling = function(fromValue, callback) {
      var toValue = this.scrollTop;
      if (!this.$animatedScroll)
        return;
      var _self = this;

      if (fromValue == toValue)
        return;

      if (this.$scrollAnimation) {
        var oldSteps = this.$scrollAnimation.steps;
        if (oldSteps.length) {
          fromValue = oldSteps[0];
          if (fromValue == toValue)
            return;
        }
      }

      var steps = _self.$calcSteps(fromValue, toValue);
      this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

      clearInterval(this.$timer);

      _self.session.setScrollTop(steps.shift());
      _self.session.$scrollTop = toValue;
      this.$timer = setInterval(function() {
        if (steps.length) {
          _self.session.setScrollTop(steps.shift());
          _self.session.$scrollTop = toValue;
        } else if (toValue != null) {
          _self.session.$scrollTop = -1;
          _self.session.setScrollTop(toValue);
          toValue = null;
        } else {
          _self.$timer = clearInterval(_self.$timer);
          _self.$scrollAnimation = null;
          callback && callback();
        }
      }, 10);
    };
    this.scrollToY = function(scrollTop) {
      if (this.scrollTop !== scrollTop) {
        this.$loop.schedule(this.CHANGE_SCROLL);
        this.scrollTop = scrollTop;
      }
    };
    this.scrollToX = function(scrollLeft) {
      if (this.scrollLeft !== scrollLeft)
        this.scrollLeft = scrollLeft;
      this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function(x, y) {
      this.session.setScrollTop(y);
      this.session.setScrollLeft(y);
    };
    this.scrollBy = function(deltaX, deltaY) {
      deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
      deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function(deltaX, deltaY) {
      if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
        return true;
      if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
        - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
        return true;
      if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
        return true;
      if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
        - this.layerConfig.width < -1 + this.scrollMargin.right)
        return true;
    };

    this.pixelToScreenCoordinates = function(x, y) {
      var canvasPos = this.scroller.getBoundingClientRect();

      var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
      var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
      var col = Math.round(offset);

      return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
    };

    this.screenToTextCoordinates = function(x, y) {
      var canvasPos = this.scroller.getBoundingClientRect();

      var col = Math.round(
        (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
      );

      var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

      return this.session.screenToDocumentPosition(row, Math.max(col, 0));
    };
    this.textToScreenCoordinates = function(row, column) {
      var canvasPos = this.scroller.getBoundingClientRect();
      var pos = this.session.documentToScreenPosition(row, column);

      var x = this.$padding + Math.round(pos.column * this.characterWidth);
      var y = pos.row * this.lineHeight;

      return {
        pageX: canvasPos.left + x - this.scrollLeft,
        pageY: canvasPos.top + y - this.scrollTop
      };
    };
    this.visualizeFocus = function() {
      dom.addCssClass(this.container, "ace_focus");
    };
    this.visualizeBlur = function() {
      dom.removeCssClass(this.container, "ace_focus");
    };
    this.showComposition = function(position) {
      if (!this.$composition)
        this.$composition = {
          keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
          cssText: this.textarea.style.cssText
        };

      this.$keepTextAreaAtCursor = true;
      dom.addCssClass(this.textarea, "ace_composition");
      this.textarea.style.cssText = "";
      this.$moveTextAreaToCursor();
    };
    this.setCompositionText = function(text) {
      this.$moveTextAreaToCursor();
    };
    this.hideComposition = function() {
      if (!this.$composition)
        return;

      dom.removeCssClass(this.textarea, "ace_composition");
      this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
      this.textarea.style.cssText = this.$composition.cssText;
      this.$composition = null;
    };
    this.setTheme = function(theme, cb) {
      var _self = this;
      this.$themeId = theme;
      _self._dispatchEvent('themeChange',{theme:theme});

      if (!theme || typeof theme == "string") {
        var moduleName = theme || this.$options.theme.initialValue;
        config.loadModule(["theme", moduleName], afterLoad);
      } else {
        afterLoad(theme);
      }

      function afterLoad(module) {
        if (_self.$themeId != theme)
          return cb && cb();
        if (!module || !module.cssClass)
          throw new Error("couldn't load module " + theme + " or it didn't call define");
        dom.importCssString(
          module.cssText,
          module.cssClass,
          _self.container.ownerDocument
        );

        if (_self.theme)
          dom.removeCssClass(_self.container, _self.theme.cssClass);

        var padding = "padding" in module ? module.padding
          : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
        if (_self.$padding && padding != _self.$padding)
          _self.setPadding(padding);
        _self.$theme = module.cssClass;

        _self.theme = module;
        dom.addCssClass(_self.container, module.cssClass);
        dom.setCssClass(_self.container, "ace_dark", module.isDark);
        if (_self.$size) {
          _self.$size.width = 0;
          _self.$updateSizeAsync();
        }

        _self._dispatchEvent('themeLoaded', {theme:module});
        cb && cb();
      }
    };
    this.getTheme = function() {
      return this.$themeId;
    };
    this.setStyle = function(style, include) {
      dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function(style) {
      dom.removeCssClass(this.container, style);
    };

    this.setCursorStyle = function(style) {
      if (this.scroller.style.cursor != style)
        this.scroller.style.cursor = style;
    };
    this.setMouseCursor = function(cursorStyle) {
      this.scroller.style.cursor = cursorStyle;
    };
    this.destroy = function() {
      this.$textLayer.destroy();
      this.$cursorLayer.destroy();
    };

  }).call(VirtualRenderer.prototype);


  config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: {initialValue: false},
    showInvisibles: {
      set: function(value) {
        if (this.$textLayer.setShowInvisibles(value))
          this.$loop.schedule(this.CHANGE_TEXT);
      },
      initialValue: false
    },
    showPrintMargin: {
      set: function() { this.$updatePrintMargin(); },
      initialValue: true
    },
    printMarginColumn: {
      set: function() { this.$updatePrintMargin(); },
      initialValue: 80
    },
    printMargin: {
      set: function(val) {
        if (typeof val == "number")
          this.$printMarginColumn = val;
        this.$showPrintMargin = !!val;
        this.$updatePrintMargin();
      },
      get: function() {
        return this.$showPrintMargin && this.$printMarginColumn;
      }
    },
    showGutter: {
      set: function(show){
        this.$gutter.style.display = show ? "block" : "none";
        this.$loop.schedule(this.CHANGE_FULL);
        this.onGutterResize();
      },
      initialValue: true
    },
    fadeFoldWidgets: {
      set: function(show) {
        dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
      },
      initialValue: false
    },
    showFoldWidgets: {
      set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
      initialValue: true
    },
    showLineNumbers: {
      set: function(show) {
        this.$gutterLayer.setShowLineNumbers(show);
        this.$loop.schedule(this.CHANGE_GUTTER);
      },
      initialValue: true
    },
    displayIndentGuides: {
      set: function(show) {
        if (this.$textLayer.setDisplayIndentGuides(show))
          this.$loop.schedule(this.CHANGE_TEXT);
      },
      initialValue: true
    },
    highlightGutterLine: {
      set: function(shouldHighlight) {
        if (!this.$gutterLineHighlight) {
          this.$gutterLineHighlight = dom.createElement("div");
          this.$gutterLineHighlight.className = "ace_gutter-active-line";
          this.$gutter.appendChild(this.$gutterLineHighlight);
          return;
        }

        this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
        if (this.$cursorLayer.$pixelPos)
          this.$updateGutterLineHighlight();
      },
      initialValue: false,
      value: true
    },
    hScrollBarAlwaysVisible: {
      set: function(val) {
        if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
          this.$loop.schedule(this.CHANGE_SCROLL);
      },
      initialValue: false
    },
    vScrollBarAlwaysVisible: {
      set: function(val) {
        if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
          this.$loop.schedule(this.CHANGE_SCROLL);
      },
      initialValue: false
    },
    fontSize:  {
      set: function(size) {
        if (typeof size == "number")
          size = size + "px";
        this.container.style.fontSize = size;
        this.updateFontSize();
      },
      initialValue: 12
    },
    fontFamily: {
      set: function(name) {
        this.container.style.fontFamily = name;
        this.updateFontSize();
      }
    },
    maxLines: {
      set: function(val) {
        this.updateFull();
      }
    },
    minLines: {
      set: function(val) {
        this.updateFull();
      }
    },
    maxPixelHeight: {
      set: function(val) {
        this.updateFull();
      },
      initialValue: 0
    },
    scrollPastEnd: {
      set: function(val) {
        val = +val || 0;
        if (this.$scrollPastEnd == val)
          return;
        this.$scrollPastEnd = val;
        this.$loop.schedule(this.CHANGE_SCROLL);
      },
      initialValue: 0,
      handlesSet: true
    },
    fixedWidthGutter: {
      set: function(val) {
        this.$gutterLayer.$fixedWidth = !!val;
        this.$loop.schedule(this.CHANGE_GUTTER);
      }
    },
    theme: {
      set: function(val) { this.setTheme(val) },
      get: function() { return this.$themeId || this.theme; },
      initialValue: "./theme/textmate",
      handlesSet: true
    }
  });

  exports.VirtualRenderer = VirtualRenderer;
});

ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(require, exports, module) {
  "use strict";

  var oop = require("../lib/oop");
  var net = require("../lib/net");
  var EventEmitter = require("../lib/event_emitter").EventEmitter;
  var config = require("../config");

  var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);
    if (require.nameToUrl && !require.toUrl)
      require.toUrl = require.nameToUrl;

    if (config.get("packaged") || !require.toUrl) {
      workerUrl = workerUrl || config.moduleUrl(mod, "worker");
    } else {
      var normalizePath = this.$normalizePath;
      workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

      var tlns = {};
      topLevelNamespaces.forEach(function(ns) {
        tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
      });
    }

    try {
      this.$worker = new Worker(workerUrl);
    } catch(e) {
      if (e instanceof window.DOMException) {
        var blob = this.$workerBlob(workerUrl);
        var URL = window.URL || window.webkitURL;
        var blobURL = URL.createObjectURL(blob);

        this.$worker = new Worker(blobURL);
        URL.revokeObjectURL(blobURL);
      } else {
        throw e;
      }
    }
    this.$worker.postMessage({
      init : true,
      tlns : tlns,
      module : mod,
      classname : classname
    });

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
  };

  (function(){

    oop.implement(this, EventEmitter);

    this.onMessage = function(e) {
      var msg = e.data;
      switch(msg.type) {
        case "event":
          this._signal(msg.name, {data: msg.data});
          break;
        case "call":
          var callback = this.callbacks[msg.id];
          if (callback) {
            callback(msg.data);
            delete this.callbacks[msg.id];
          }
          break;
        case "error":
          this.reportError(msg.data);
          break;
        case "log":
          window.console && console.log && console.log.apply(console, msg.data);
          break;
      }
    };

    this.reportError = function(err) {
      window.console && console.error && console.error(err);
    };

    this.$normalizePath = function(path) {
      return net.qualifyURL(path);
    };

    this.terminate = function() {
      this._signal("terminate", {});
      this.deltaQueue = null;
      this.$worker.terminate();
      this.$worker = null;
      if (this.$doc)
        this.$doc.off("change", this.changeListener);
      this.$doc = null;
    };

    this.send = function(cmd, args) {
      this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
      if (callback) {
        var id = this.callbackId++;
        this.callbacks[id] = callback;
        args.push(id);
      }
      this.send(cmd, args);
    };

    this.emit = function(event, data) {
      try {
        this.$worker.postMessage({event: event, data: {data: data.data}});
      }
      catch(ex) {
        console.error(ex.stack);
      }
    };

    this.attachToDocument = function(doc) {
      if(this.$doc)
        this.terminate();

      this.$doc = doc;
      this.call("setValue", [doc.getValue()]);
      doc.on("change", this.changeListener);
    };

    this.changeListener = function(delta) {
      if (!this.deltaQueue) {
        this.deltaQueue = [];
        setTimeout(this.$sendDeltaQueue, 0);
      }
      if (delta.action == "insert")
        this.deltaQueue.push(delta.start, delta.lines);
      else
        this.deltaQueue.push(delta.start, delta.end);
    };

    this.$sendDeltaQueue = function() {
      var q = this.deltaQueue;
      if (!q) return;
      this.deltaQueue = null;
      if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
        this.call("setValue", [this.$doc.getValue()]);
      } else
        this.emit("change", {data: q});
    };

    this.$workerBlob = function(workerUrl) {
      var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
      try {
        return new Blob([script], {"type": "application/javascript"});
      } catch (e) { // Backwards-compatibility
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        return blobBuilder.getBlob("application/javascript");
      }
    };

  }).call(WorkerClient.prototype);


  var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.callbackId = 1;
    this.callbacks = {};
    this.messageBuffer = [];

    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);
    var _self = this;

    this.$worker = {};
    this.$worker.terminate = function() {};
    this.$worker.postMessage = function(e) {
      _self.messageBuffer.push(e);
      if (main) {
        if (emitSync)
          setTimeout(processNext);
        else
          processNext();
      }
    };
    this.setEmitSync = function(val) { emitSync = val };

    var processNext = function() {
      var msg = _self.messageBuffer.shift();
      if (msg.command)
        main[msg.command].apply(main, msg.args);
      else if (msg.event)
        sender._signal(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
      _self.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
      this.postMessage({type: "call", id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
      this.postMessage({type: "event", name: name, data: data});
    };

    config.loadModule(["worker", mod], function(Main) {
      main = new Main[classname](sender);
      while (_self.messageBuffer.length)
        processNext();
    });
  };

  UIWorkerClient.prototype = WorkerClient.prototype;

  exports.UIWorkerClient = UIWorkerClient;
  exports.WorkerClient = WorkerClient;

});

ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(require, exports, module) {
  "use strict";

  var Range = require("./range").Range;
  var EventEmitter = require("./lib/event_emitter").EventEmitter;
  var oop = require("./lib/oop");

  var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate);
    this.$others = others;

    this.$onCursorChange = function() {
      setTimeout(function() {
        _self.onCursorChange();
      });
    };

    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
    this.$undoStackDepth = undoStack.length;
    this.setup();

    session.selection.on("changeCursor", this.$onCursorChange);
  };

  (function() {

    oop.implement(this, EventEmitter);
    this.setup = function() {
      var _self = this;
      var doc = this.doc;
      var session = this.session;

      this.selectionBefore = session.selection.toJSON();
      if (session.selection.inMultiSelectMode)
        session.selection.toSingleRange();

      this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
      var pos = this.pos;
      pos.$insertRight = true;
      pos.detach();
      pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
      this.others = [];
      this.$others.forEach(function(other) {
        var anchor = doc.createAnchor(other.row, other.column);
        anchor.$insertRight = true;
        anchor.detach();
        _self.others.push(anchor);
      });
      session.setUndoSelect(false);
    };
    this.showOtherMarkers = function() {
      if (this.othersActive) return;
      var session = this.session;
      var _self = this;
      this.othersActive = true;
      this.others.forEach(function(anchor) {
        anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
      });
    };
    this.hideOtherMarkers = function() {
      if (!this.othersActive) return;
      this.othersActive = false;
      for (var i = 0; i < this.others.length; i++) {
        this.session.removeMarker(this.others[i].markerId);
      }
    };
    this.onUpdate = function(delta) {
      if (this.$updating)
        return this.updateAnchors(delta);

      var range = delta;
      if (range.start.row !== range.end.row) return;
      if (range.start.row !== this.pos.row) return;
      this.$updating = true;
      var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
      var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
      var distanceFromStart = range.start.column - this.pos.column;

      this.updateAnchors(delta);

      if (inMainRange)
        this.length += lengthDiff;

      if (inMainRange && !this.session.$fromUndo) {
        if (delta.action === 'insert') {
          for (var i = this.others.length - 1; i >= 0; i--) {
            var otherPos = this.others[i];
            var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
            this.doc.insertMergedLines(newPos, delta.lines);
          }
        } else if (delta.action === 'remove') {
          for (var i = this.others.length - 1; i >= 0; i--) {
            var otherPos = this.others[i];
            var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
            this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
          }
        }
      }

      this.$updating = false;
      this.updateMarkers();
    };

    this.updateAnchors = function(delta) {
      this.pos.onChange(delta);
      for (var i = this.others.length; i--;)
        this.others[i].onChange(delta);
      this.updateMarkers();
    };

    this.updateMarkers = function() {
      if (this.$updating)
        return;
      var _self = this;
      var session = this.session;
      var updateMarker = function(pos, className) {
        session.removeMarker(pos.markerId);
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
      };
      updateMarker(this.pos, this.mainClass);
      for (var i = this.others.length; i--;)
        updateMarker(this.others[i], this.othersClass);
    };

    this.onCursorChange = function(event) {
      if (this.$updating || !this.session) return;
      var pos = this.session.selection.getCursor();
      if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
        this.showOtherMarkers();
        this._emit("cursorEnter", event);
      } else {
        this.hideOtherMarkers();
        this._emit("cursorLeave", event);
      }
    };
    this.detach = function() {
      this.session.removeMarker(this.pos && this.pos.markerId);
      this.hideOtherMarkers();
      this.doc.removeEventListener("change", this.$onUpdate);
      this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
      this.session.setUndoSelect(true);
      this.session = null;
    };
    this.cancel = function() {
      if (this.$undoStackDepth === -1)
        return;
      var undoManager = this.session.getUndoManager();
      var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
      for (var i = 0; i < undosRequired; i++) {
        undoManager.undo(true);
      }
      if (this.selectionBefore)
        this.session.selection.fromJSON(this.selectionBefore);
    };
  }).call(PlaceHolder.prototype);


  exports.PlaceHolder = PlaceHolder;
});

ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

  var event = require("../lib/event");
  var useragent = require("../lib/useragent");
  function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
  }

  function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();

    if (ctrl && useragent.isMac)
      button = ev.button;

    if (e.editor.inMultiSelectMode && button == 2) {
      e.editor.textInput.onContextMenu(e.domEvent);
      return;
    }

    if (!ctrl && !alt && !accel) {
      if (button === 0 && e.editor.inMultiSelectMode)
        e.editor.exitMultiSelectMode();
      return;
    }

    if (button !== 0)
      return;

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
      mouseX = e.clientX;
      mouseY = e.clientY;
    };

    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;

    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
      if (ctrl && alt || accel && alt)
        selectionMode = shift ? "block" : "add";
      else if (alt && editor.$blockSelectEnabled)
        selectionMode = "block";
    } else {
      if (accel && !alt) {
        selectionMode = "add";
        if (!isMultiSelect && shift)
          return;
      } else if (alt && editor.$blockSelectEnabled) {
        selectionMode = "block";
      }
    }

    if (selectionMode && useragent.isMac && ev.ctrlKey) {
      editor.$mouseHandler.cancelContextMenu();
    }

    if (selectionMode == "add") {
      if (!isMultiSelect && inSelection)
        return; // dragging

      if (!isMultiSelect) {
        var range = selection.toOrientedRange();
        editor.addSelectionMarker(range);
      }

      var oldRange = selection.rangeList.rangeAtPoint(pos);


      editor.$blockScrolling++;
      editor.inVirtualSelectionMode = true;

      if (shift) {
        oldRange = null;
        range = selection.ranges[0] || range;
        editor.removeSelectionMarker(range);
      }
      editor.once("mouseup", function() {
        var tmpSel = selection.toOrientedRange();

        if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
          selection.substractPoint(tmpSel.cursor);
        else {
          if (shift) {
            selection.substractPoint(range.cursor);
          } else if (range) {
            editor.removeSelectionMarker(range);
            selection.addRange(range);
          }
          selection.addRange(tmpSel);
        }
        editor.$blockScrolling--;
        editor.inVirtualSelectionMode = false;
      });

    } else if (selectionMode == "block") {
      e.stop();
      editor.inVirtualSelectionMode = true;
      var initialRange;
      var rectSel = [];
      var blockSelect = function() {
        var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

        if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
          return;
        screenCursor = newCursor;

        editor.$blockScrolling++;
        editor.selection.moveToPosition(cursor);
        editor.renderer.scrollCursorIntoView();

        editor.removeSelectionMarkers(rectSel);
        rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
        if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
          rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
        rectSel.forEach(editor.addSelectionMarker, editor);
        editor.updateSelectionMarkers();
        editor.$blockScrolling--;
      };
      editor.$blockScrolling++;
      if (isMultiSelect && !accel) {
        selection.toSingleRange();
      } else if (!isMultiSelect && accel) {
        initialRange = selection.toOrientedRange();
        editor.addSelectionMarker(initialRange);
      }

      if (shift)
        screenAnchor = session.documentToScreenPosition(selection.lead);
      else
        selection.moveToPosition(pos);
      editor.$blockScrolling--;

      screenCursor = {row: -1, column: -1};

      var onMouseSelectionEnd = function(e) {
        clearInterval(timerId);
        editor.removeSelectionMarkers(rectSel);
        if (!rectSel.length)
          rectSel = [selection.toOrientedRange()];
        editor.$blockScrolling++;
        if (initialRange) {
          editor.removeSelectionMarker(initialRange);
          selection.toSingleRange(initialRange);
        }
        for (var i = 0; i < rectSel.length; i++)
          selection.addRange(rectSel[i]);
        editor.inVirtualSelectionMode = false;
        editor.$mouseHandler.$clickSelection = null;
        editor.$blockScrolling--;
      };

      var onSelectionInterval = blockSelect;

      event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
      var timerId = setInterval(function() {onSelectionInterval();}, 20);

      return e.preventDefault();
    }
  }


  exports.onMouseDown = onMouseDown;

});

ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(require, exports, module) {
  exports.defaultCommands = [{
    name: "addCursorAbove",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "addCursorBelow",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "addCursorAboveSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "addCursorBelowSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectMoreBefore",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectMoreAfter",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectNextBefore",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "selectNextAfter",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    scrollIntoView: "cursor",
    readOnly: true
  }, {
    name: "splitIntoLines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readOnly: true
  }, {
    name: "alignCursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
    scrollIntoView: "cursor"
  }, {
    name: "findAll",
    exec: function(editor) { editor.findAll(); },
    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
    scrollIntoView: "cursor",
    readOnly: true
  }];
  exports.multiSelectCommands = [{
    name: "singleSelection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    scrollIntoView: "cursor",
    readOnly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
  }];

  var HashHandler = require("../keyboard/hash_handler").HashHandler;
  exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(require, exports, module) {

  var RangeList = require("./range_list").RangeList;
  var Range = require("./range").Range;
  var Selection = require("./selection").Selection;
  var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
  var event = require("./lib/event");
  var lang = require("./lib/lang");
  var commands = require("./commands/multi_select_commands");
  exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
  var Search = require("./search").Search;
  var search = new Search();

  function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
  }
  var EditSession = require("./edit_session").EditSession;
  (function() {
    this.getSelectionMarkers = function() {
      return this.$selectionMarkers;
    };
  }).call(EditSession.prototype);
  (function() {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function(range, $blockChangeEvents) {
      if (!range)
        return;

      if (!this.inMultiSelectMode && this.rangeCount === 0) {
        var oldRange = this.toOrientedRange();
        this.rangeList.add(oldRange);
        this.rangeList.add(range);
        if (this.rangeList.ranges.length != 2) {
          this.rangeList.removeAll();
          return $blockChangeEvents || this.fromOrientedRange(range);
        }
        this.rangeList.removeAll();
        this.rangeList.add(oldRange);
        this.$onAddRange(oldRange);
      }

      if (!range.cursor)
        range.cursor = range.end;

      var removed = this.rangeList.add(range);

      this.$onAddRange(range);

      if (removed.length)
        this.$onRemoveRange(removed);

      if (this.rangeCount > 1 && !this.inMultiSelectMode) {
        this._signal("multiSelect");
        this.inMultiSelectMode = true;
        this.session.$undoSelect = false;
        this.rangeList.attach(this.session);
      }

      return $blockChangeEvents || this.fromOrientedRange(range);
    };

    this.toSingleRange = function(range) {
      range = range || this.ranges[0];
      var removed = this.rangeList.removeAll();
      if (removed.length)
        this.$onRemoveRange(removed);

      range && this.fromOrientedRange(range);
    };
    this.substractPoint = function(pos) {
      var removed = this.rangeList.substractPoint(pos);
      if (removed) {
        this.$onRemoveRange(removed);
        return removed[0];
      }
    };
    this.mergeOverlappingRanges = function() {
      var removed = this.rangeList.merge();
      if (removed.length)
        this.$onRemoveRange(removed);
      else if(this.ranges[0])
        this.fromOrientedRange(this.ranges[0]);
    };

    this.$onAddRange = function(range) {
      this.rangeCount = this.rangeList.ranges.length;
      this.ranges.unshift(range);
      this._signal("addRange", {range: range});
    };

    this.$onRemoveRange = function(removed) {
      this.rangeCount = this.rangeList.ranges.length;
      if (this.rangeCount == 1 && this.inMultiSelectMode) {
        var lastRange = this.rangeList.ranges.pop();
        removed.push(lastRange);
        this.rangeCount = 0;
      }

      for (var i = removed.length; i--; ) {
        var index = this.ranges.indexOf(removed[i]);
        this.ranges.splice(index, 1);
      }

      this._signal("removeRange", {ranges: removed});

      if (this.rangeCount === 0 && this.inMultiSelectMode) {
        this.inMultiSelectMode = false;
        this._signal("singleSelect");
        this.session.$undoSelect = true;
        this.rangeList.detach(this.session);
      }

      lastRange = lastRange || this.ranges[0];
      if (lastRange && !lastRange.isEqual(this.getRange()))
        this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function() {
      if (this.rangeList)
        return;

      this.rangeList = new RangeList();
      this.ranges = [];
      this.rangeCount = 0;
    };
    this.getAllRanges = function() {
      return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };

    this.splitIntoLines = function () {
      if (this.rangeCount > 1) {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);

        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
      } else {
        var range = this.getRange();
        var isBackwards = this.isBackwards();
        var startRow = range.start.row;
        var endRow = range.end.row;
        if (startRow == endRow) {
          if (isBackwards)
            var start = range.end, end = range.start;
          else
            var start = range.start, end = range.end;

          this.addRange(Range.fromPoints(end, end));
          this.addRange(Range.fromPoints(start, start));
          return;
        }

        var rectSel = [];
        var r = this.getLineRange(startRow, true);
        r.start.column = range.start.column;
        rectSel.push(r);

        for (var i = startRow + 1; i < endRow; i++)
          rectSel.push(this.getLineRange(i, true));

        r = this.getLineRange(endRow, true);
        r.end.column = range.end.column;
        rectSel.push(r);

        rectSel.forEach(this.addRange, this);
      }
    };
    this.toggleBlockSelection = function () {
      if (this.rangeCount > 1) {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);

        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
      } else {
        var cursor = this.session.documentToScreenPosition(this.selectionLead);
        var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

        var rectSel = this.rectangularRangeBlock(cursor, anchor);
        rectSel.forEach(this.addRange, this);
      }
    };
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
      var rectSel = [];

      var xBackwards = screenCursor.column < screenAnchor.column;
      if (xBackwards) {
        var startColumn = screenCursor.column;
        var endColumn = screenAnchor.column;
      } else {
        var startColumn = screenAnchor.column;
        var endColumn = screenCursor.column;
      }

      var yBackwards = screenCursor.row < screenAnchor.row;
      if (yBackwards) {
        var startRow = screenCursor.row;
        var endRow = screenAnchor.row;
      } else {
        var startRow = screenAnchor.row;
        var endRow = screenCursor.row;
      }

      if (startColumn < 0)
        startColumn = 0;
      if (startRow < 0)
        startRow = 0;

      if (startRow == endRow)
        includeEmptyLines = true;

      for (var row = startRow; row <= endRow; row++) {
        var range = Range.fromPoints(
          this.session.screenToDocumentPosition(row, startColumn),
          this.session.screenToDocumentPosition(row, endColumn)
        );
        if (range.isEmpty()) {
          if (docEnd && isSamePoint(range.end, docEnd))
            break;
          var docEnd = range.end;
        }
        range.cursor = xBackwards ? range.start : range.end;
        rectSel.push(range);
      }

      if (yBackwards)
        rectSel.reverse();

      if (!includeEmptyLines) {
        var end = rectSel.length - 1;
        while (rectSel[end].isEmpty() && end > 0)
          end--;
        if (end > 0) {
          var start = 0;
          while (rectSel[start].isEmpty())
            start++;
        }
        for (var i = end; i >= start; i--) {
          if (rectSel[i].isEmpty())
            rectSel.splice(i, 1);
        }
      }

      return rectSel;
    };
  }).call(Selection.prototype);
  var Editor = require("./editor").Editor;
  (function() {
    this.updateSelectionMarkers = function() {
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function(orientedRange) {
      if (!orientedRange.cursor)
        orientedRange.cursor = orientedRange.end;

      var style = this.getSelectionStyle();
      orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

      this.session.$selectionMarkers.push(orientedRange);
      this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
      return orientedRange;
    };
    this.removeSelectionMarker = function(range) {
      if (!range.marker)
        return;
      this.session.removeMarker(range.marker);
      var index = this.session.$selectionMarkers.indexOf(range);
      if (index != -1)
        this.session.$selectionMarkers.splice(index, 1);
      this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    this.removeSelectionMarkers = function(ranges) {
      var markerList = this.session.$selectionMarkers;
      for (var i = ranges.length; i--; ) {
        var range = ranges[i];
        if (!range.marker)
          continue;
        this.session.removeMarker(range.marker);
        var index = markerList.indexOf(range);
        if (index != -1)
          markerList.splice(index, 1);
      }
      this.session.selectionMarkerCount = markerList.length;
    };

    this.$onAddRange = function(e) {
      this.addSelectionMarker(e.range);
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
    };

    this.$onRemoveRange = function(e) {
      this.removeSelectionMarkers(e.ranges);
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
    };

    this.$onMultiSelect = function(e) {
      if (this.inMultiSelectMode)
        return;
      this.inMultiSelectMode = true;

      this.setStyle("ace_multiselect");
      this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
      this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
    };

    this.$onSingleSelect = function(e) {
      if (this.session.multiSelect.inVirtualMode)
        return;
      this.inMultiSelectMode = false;

      this.unsetStyle("ace_multiselect");
      this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

      this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
      this._emit("changeSelection");
    };

    this.$onMultiSelectExec = function(e) {
      var command = e.command;
      var editor = e.editor;
      if (!editor.multiSelect)
        return;
      if (!command.multiSelectAction) {
        var result = command.exec(editor, e.args || {});
        editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
        editor.multiSelect.mergeOverlappingRanges();
      } else if (command.multiSelectAction == "forEach") {
        result = editor.forEachSelection(command, e.args);
      } else if (command.multiSelectAction == "forEachLine") {
        result = editor.forEachSelection(command, e.args, true);
      } else if (command.multiSelectAction == "single") {
        editor.exitMultiSelectMode();
        result = command.exec(editor, e.args || {});
      } else {
        result = command.multiSelectAction(editor, e.args || {});
      }
      return result;
    };
    this.forEachSelection = function(cmd, args, options) {
      if (this.inVirtualSelectionMode)
        return;
      var keepOrder = options && options.keepOrder;
      var $byLines = options == true || options && options.$byLines
      var session = this.session;
      var selection = this.selection;
      var rangeList = selection.rangeList;
      var ranges = (keepOrder ? selection : rangeList).ranges;
      var result;

      if (!ranges.length)
        return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});

      var reg = selection._eventRegistry;
      selection._eventRegistry = {};

      var tmpSel = new Selection(session);
      this.inVirtualSelectionMode = true;
      for (var i = ranges.length; i--;) {
        if ($byLines) {
          while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
            i--;
        }
        tmpSel.fromOrientedRange(ranges[i]);
        tmpSel.index = i;
        this.selection = session.selection = tmpSel;
        var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        if (!result && cmdResult !== undefined)
          result = cmdResult;
        tmpSel.toOrientedRange(ranges[i]);
      }
      tmpSel.detach();

      this.selection = session.selection = selection;
      this.inVirtualSelectionMode = false;
      selection._eventRegistry = reg;
      selection.mergeOverlappingRanges();

      var anim = this.renderer.$scrollAnimation;
      this.onCursorChange();
      this.onSelectionChange();
      if (anim && anim.from == anim.to)
        this.renderer.animateScrolling(anim.from);

      return result;
    };
    this.exitMultiSelectMode = function() {
      if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
        return;
      this.multiSelect.toSingleRange();
    };

    this.getSelectedText = function() {
      var text = "";
      if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
        var ranges = this.multiSelect.rangeList.ranges;
        var buf = [];
        for (var i = 0; i < ranges.length; i++) {
          buf.push(this.session.getTextRange(ranges[i]));
        }
        var nl = this.session.getDocument().getNewLineCharacter();
        text = buf.join(nl);
        if (text.length == (buf.length - 1) * nl.length)
          text = "";
      } else if (!this.selection.isEmpty()) {
        text = this.session.getTextRange(this.getSelectionRange());
      }
      return text;
    };

    this.$checkMultiselectChange = function(e, anchor) {
      if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
        var range = this.multiSelect.ranges[0];
        if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
          return;
        var pos = anchor == this.multiSelect.anchor
          ? range.cursor == range.start ? range.end : range.start
          : range.cursor;
        if (pos.row != anchor.row
          || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
          this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
      }
    };
    this.findAll = function(needle, options, additive) {
      options = options || {};
      options.needle = needle || options.needle;
      if (options.needle == undefined) {
        var range = this.selection.isEmpty()
          ? this.selection.getWordRange()
          : this.selection.getRange();
        options.needle = this.session.getTextRange(range);
      }
      this.$search.set(options);

      var ranges = this.$search.findAll(this.session);
      if (!ranges.length)
        return 0;

      this.$blockScrolling += 1;
      var selection = this.multiSelect;

      if (!additive)
        selection.toSingleRange(ranges[0]);

      for (var i = ranges.length; i--; )
        selection.addRange(ranges[i], true);
      if (range && selection.rangeList.rangeAtPoint(range.start))
        selection.addRange(range, true);

      this.$blockScrolling -= 1;

      return ranges.length;
    };
    this.selectMoreLines = function(dir, skip) {
      var range = this.selection.toOrientedRange();
      var isBackwards = range.cursor == range.end;

      var screenLead = this.session.documentToScreenPosition(range.cursor);
      if (this.selection.$desiredColumn)
        screenLead.column = this.selection.$desiredColumn;

      var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

      if (!range.isEmpty()) {
        var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
        var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
      } else {
        var anchor = lead;
      }

      if (isBackwards) {
        var newRange = Range.fromPoints(lead, anchor);
        newRange.cursor = newRange.start;
      } else {
        var newRange = Range.fromPoints(anchor, lead);
        newRange.cursor = newRange.end;
      }

      newRange.desiredColumn = screenLead.column;
      if (!this.selection.inMultiSelectMode) {
        this.selection.addRange(range);
      } else {
        if (skip)
          var toRemove = range.cursor;
      }

      this.selection.addRange(newRange);
      if (toRemove)
        this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function(dir) {
      var session = this.session;
      var sel = session.multiSelect;
      var all = sel.ranges;

      for (var i = all.length; i--; ) {
        var range = all[i];
        if (range.isEmpty()) {
          var tmp = session.getWordRange(range.start.row, range.start.column);
          range.start.row = tmp.start.row;
          range.start.column = tmp.start.column;
          range.end.row = tmp.end.row;
          range.end.column = tmp.end.column;
        }
      }
      sel.mergeOverlappingRanges();

      var words = [];
      for (var i = all.length; i--; ) {
        var range = all[i];
        words.unshift(session.getTextRange(range));
      }

      if (dir < 0)
        words.unshift(words.pop());
      else
        words.push(words.shift());

      for (var i = all.length; i--; ) {
        var range = all[i];
        var tmp = range.clone();
        session.replace(range, words[i]);
        range.start.row = tmp.start.row;
        range.start.column = tmp.start.column;
      }
    };
    this.selectMore = function(dir, skip, stopAtFirst) {
      var session = this.session;
      var sel = session.multiSelect;

      var range = sel.toOrientedRange();
      if (range.isEmpty()) {
        range = session.getWordRange(range.start.row, range.start.column);
        range.cursor = dir == -1 ? range.start : range.end;
        this.multiSelect.addRange(range);
        if (stopAtFirst)
          return;
      }
      var needle = session.getTextRange(range);

      var newRange = find(session, needle, dir);
      if (newRange) {
        newRange.cursor = dir == -1 ? newRange.start : newRange.end;
        this.$blockScrolling += 1;
        this.session.unfold(newRange);
        this.multiSelect.addRange(newRange);
        this.$blockScrolling -= 1;
        this.renderer.scrollCursorIntoView(null, 0.5);
      }
      if (skip)
        this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function() {
      var session = this.session;
      var sel = session.multiSelect;
      var ranges = sel.ranges;
      var row = -1;
      var sameRowRanges = ranges.filter(function(r) {
        if (r.cursor.row == row)
          return true;
        row = r.cursor.row;
      });

      if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
        var range = this.selection.getRange();
        var fr = range.start.row, lr = range.end.row;
        var guessRange = fr == lr;
        if (guessRange) {
          var max = this.session.getLength();
          var line;
          do {
            line = this.session.getLine(lr);
          } while (/[=:]/.test(line) && ++lr < max);
          do {
            line = this.session.getLine(fr);
          } while (/[=:]/.test(line) && --fr > 0);

          if (fr < 0) fr = 0;
          if (lr >= max) lr = max - 1;
        }
        var lines = this.session.removeFullLines(fr, lr);
        lines = this.$reAlignText(lines, guessRange);
        this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
        if (!guessRange) {
          range.start.column = 0;
          range.end.column = lines[lines.length - 1].length;
        }
        this.selection.setRange(range);
      } else {
        sameRowRanges.forEach(function(r) {
          sel.substractPoint(r.cursor);
        });

        var maxCol = 0;
        var minSpace = Infinity;
        var spaceOffsets = ranges.map(function(r) {
          var p = r.cursor;
          var line = session.getLine(p.row);
          var spaceOffset = line.substr(p.column).search(/\S/g);
          if (spaceOffset == -1)
            spaceOffset = 0;

          if (p.column > maxCol)
            maxCol = p.column;
          if (spaceOffset < minSpace)
            minSpace = spaceOffset;
          return spaceOffset;
        });
        ranges.forEach(function(r, i) {
          var p = r.cursor;
          var l = maxCol - p.column;
          var d = spaceOffsets[i] - minSpace;
          if (l > d)
            session.insert(p, lang.stringRepeat(" ", l - d));
          else
            session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

          r.start.column = r.end.column = maxCol;
          r.start.row = r.end.row = p.row;
          r.cursor = r.end;
        });
        sel.fromOrientedRange(ranges[0]);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      }
    };

    this.$reAlignText = function(lines, forceLeft) {
      var isLeftAligned = true, isRightAligned = true;
      var startW, textW, endW;

      return lines.map(function(line) {
        var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
        if (!m)
          return [line];

        if (startW == null) {
          startW = m[1].length;
          textW = m[2].length;
          endW = m[3].length;
          return m;
        }

        if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
          isRightAligned = false;
        if (startW != m[1].length)
          isLeftAligned = false;

        if (startW > m[1].length)
          startW = m[1].length;
        if (textW < m[2].length)
          textW = m[2].length;
        if (endW > m[3].length)
          endW = m[3].length;

        return m;
      }).map(forceLeft ? alignLeft :
        isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

      function spaces(n) {
        return lang.stringRepeat(" ", n);
      }

      function alignLeft(m) {
        return !m[2] ? m[0] : spaces(startW) + m[2]
          + spaces(textW - m[2].length + endW)
          + m[4].replace(/^([=:])\s+/, "$1 ");
      }
      function alignRight(m) {
        return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
          + spaces(endW, " ")
          + m[4].replace(/^([=:])\s+/, "$1 ");
      }
      function unAlign(m) {
        return !m[2] ? m[0] : spaces(startW) + m[2]
          + spaces(endW)
          + m[4].replace(/^([=:])\s+/, "$1 ");
      }
    };
  }).call(Editor.prototype);


  function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
  }
  exports.onSessionChange = function(e) {
    var session = e.session;
    if (session && !session.multiSelect) {
      session.$selectionMarkers = [];
      session.selection.$initRangeList();
      session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
      oldSession.multiSelect.off("addRange", this.$onAddRange);
      oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
      oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
      oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
      oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
      oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
    }

    if (session) {
      session.multiSelect.on("addRange", this.$onAddRange);
      session.multiSelect.on("removeRange", this.$onRemoveRange);
      session.multiSelect.on("multiSelect", this.$onMultiSelect);
      session.multiSelect.on("singleSelect", this.$onSingleSelect);
      session.multiSelect.lead.on("change", this.$checkMultiselectChange);
      session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
    }

    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
      if (session.selection.inMultiSelectMode)
        this.$onMultiSelect();
      else
        this.$onSingleSelect();
    }
  };
  function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
      return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
  }

  function addAltCursorListeners(editor){
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
      var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
      if (editor.$blockSelectEnabled && altDown) {
        if (!altCursor) {
          editor.renderer.setMouseCursor("crosshair");
          altCursor = true;
        }
      } else if (altCursor) {
        reset();
      }
    });

    event.addListener(el, "keyup", reset);
    event.addListener(el, "blur", reset);
    function reset(e) {
      if (altCursor) {
        editor.renderer.setMouseCursor("");
        altCursor = false;
      }
    }
  }

  exports.MultiSelect = MultiSelect;


  require("./config").defineOptions(Editor.prototype, "editor", {
    enableMultiselect: {
      set: function(val) {
        MultiSelect(this);
        if (val) {
          this.on("changeSession", this.$multiselectOnSessionChange);
          this.on("mousedown", onMouseDown);
        } else {
          this.off("changeSession", this.$multiselectOnSessionChange);
          this.off("mousedown", onMouseDown);
        }
      },
      value: true
    },
    enableBlockSelect: {
      set: function(val) {
        this.$blockSelectEnabled = val;
      },
      value: true
    }
  });



});

ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(require, exports, module) {
  "use strict";

  var Range = require("../../range").Range;

  var FoldMode = exports.FoldMode = function() {};

  (function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function(session, foldStyle, row) {
      var line = session.getLine(row);
      if (this.foldingStartMarker.test(line))
        return "start";
      if (foldStyle == "markbeginend"
        && this.foldingStopMarker
        && this.foldingStopMarker.test(line))
        return "end";
      return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
      return null;
    };

    this.indentationBlock = function(session, row, column) {
      var re = /\S/;
      var line = session.getLine(row);
      var startLevel = line.search(re);
      if (startLevel == -1)
        return;

      var startColumn = column || line.length;
      var maxRow = session.getLength();
      var startRow = row;
      var endRow = row;

      while (++row < maxRow) {
        var level = session.getLine(row).search(re);

        if (level == -1)
          continue;

        if (level <= startLevel)
          break;

        endRow = row;
      }

      if (endRow > startRow) {
        var endColumn = session.getLine(endRow).length;
        return new Range(startRow, startColumn, endRow, endColumn);
      }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
      var start = {row: row, column: column + 1};
      var end = session.$findClosingBracket(bracket, start, typeRe);
      if (!end)
        return;

      var fw = session.foldWidgets[end.row];
      if (fw == null)
        fw = session.getFoldWidget(end.row);

      if (fw == "start" && end.row > start.row) {
        end.row --;
        end.column = session.getLine(end.row).length;
      }
      return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
      var end = {row: row, column: column};
      var start = session.$findOpeningBracket(bracket, end);

      if (!start)
        return;

      start.column++;
      end.column--;

      return  Range.fromPoints(start, end);
    };
  }).call(FoldMode.prototype);

});

ace.define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
  "use strict";

  exports.isDark = false;
  exports.cssClass = "ace-tm";
  exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

  var dom = require("../lib/dom");
  dom.importCssString(exports.cssText, exports.cssClass);
});

ace.define("ace/line_widgets",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/range"], function(require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");
  var dom = require("./lib/dom");
  var Range = require("./range").Range;


  function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.$onChangeEditor = this.$onChangeEditor.bind(this);

    this.session.on("change", this.updateOnChange);
    this.session.on("changeFold", this.updateOnFold);
    this.session.on("changeEditor", this.$onChangeEditor);
  }

  (function() {
    this.getRowLength = function(row) {
      var h;
      if (this.lineWidgets)
        h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
      else
        h = 0;
      if (!this.$useWrapMode || !this.$wrapData[row]) {
        return 1 + h;
      } else {
        return this.$wrapData[row].length + 1 + h;
      }
    };

    this.$getWidgetScreenLength = function() {
      var screenRows = 0;
      this.lineWidgets.forEach(function(w){
        if (w && w.rowCount && !w.hidden)
          screenRows += w.rowCount;
      });
      return screenRows;
    };

    this.$onChangeEditor = function(e) {
      this.attach(e.editor);
    };

    this.attach = function(editor) {
      if (editor  && editor.widgetManager && editor.widgetManager != this)
        editor.widgetManager.detach();

      if (this.editor == editor)
        return;

      this.detach();
      this.editor = editor;

      if (editor) {
        editor.widgetManager = this;
        editor.renderer.on("beforeRender", this.measureWidgets);
        editor.renderer.on("afterRender", this.renderWidgets);
      }
    };
    this.detach = function(e) {
      var editor = this.editor;
      if (!editor)
        return;

      this.editor = null;
      editor.widgetManager = null;

      editor.renderer.off("beforeRender", this.measureWidgets);
      editor.renderer.off("afterRender", this.renderWidgets);
      var lineWidgets = this.session.lineWidgets;
      lineWidgets && lineWidgets.forEach(function(w) {
        if (w && w.el && w.el.parentNode) {
          w._inDocument = false;
          w.el.parentNode.removeChild(w.el);
        }
      });
    };

    this.updateOnFold = function(e, session) {
      var lineWidgets = session.lineWidgets;
      if (!lineWidgets || !e.action)
        return;
      var fold = e.data;
      var start = fold.start.row;
      var end = fold.end.row;
      var hide = e.action == "add";
      for (var i = start + 1; i < end; i++) {
        if (lineWidgets[i])
          lineWidgets[i].hidden = hide;
      }
      if (lineWidgets[end]) {
        if (hide) {
          if (!lineWidgets[start])
            lineWidgets[start] = lineWidgets[end];
          else
            lineWidgets[end].hidden = hide;
        } else {
          if (lineWidgets[start] == lineWidgets[end])
            lineWidgets[start] = undefined;
          lineWidgets[end].hidden = hide;
        }
      }
    };

    this.updateOnChange = function(delta) {
      var lineWidgets = this.session.lineWidgets;
      if (!lineWidgets) return;

      var startRow = delta.start.row;
      var len = delta.end.row - startRow;

      if (len === 0) {
      } else if (delta.action == 'remove') {
        var removed = lineWidgets.splice(startRow + 1, len);
        removed.forEach(function(w) {
          w && this.removeLineWidget(w);
        }, this);
        this.$updateRows();
      } else {
        var args = new Array(len);
        args.unshift(startRow, 0);
        lineWidgets.splice.apply(lineWidgets, args);
        this.$updateRows();
      }
    };

    this.$updateRows = function() {
      var lineWidgets = this.session.lineWidgets;
      if (!lineWidgets) return;
      var noWidgets = true;
      lineWidgets.forEach(function(w, i) {
        if (w) {
          noWidgets = false;
          w.row = i;
          while (w.$oldWidget) {
            w.$oldWidget.row = i;
            w = w.$oldWidget;
          }
        }
      });
      if (noWidgets)
        this.session.lineWidgets = null;
    };

    this.addLineWidget = function(w) {
      if (!this.session.lineWidgets)
        this.session.lineWidgets = new Array(this.session.getLength());

      var old = this.session.lineWidgets[w.row];
      if (old) {
        w.$oldWidget = old;
        if (old.el && old.el.parentNode) {
          old.el.parentNode.removeChild(old.el);
          old._inDocument = false;
        }
      }

      this.session.lineWidgets[w.row] = w;

      w.session = this.session;

      var renderer = this.editor.renderer;
      if (w.html && !w.el) {
        w.el = dom.createElement("div");
        w.el.innerHTML = w.html;
      }
      if (w.el) {
        dom.addCssClass(w.el, "ace_lineWidgetContainer");
        w.el.style.position = "absolute";
        w.el.style.zIndex = 5;
        renderer.container.appendChild(w.el);
        w._inDocument = true;
      }

      if (!w.coverGutter) {
        w.el.style.zIndex = 3;
      }
      if (w.pixelHeight == null) {
        w.pixelHeight = w.el.offsetHeight;
      }
      if (w.rowCount == null) {
        w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
      }

      var fold = this.session.getFoldAt(w.row, 0);
      w.$fold = fold;
      if (fold) {
        var lineWidgets = this.session.lineWidgets;
        if (w.row == fold.end.row && !lineWidgets[fold.start.row])
          lineWidgets[fold.start.row] = w;
        else
          w.hidden = true;
      }

      this.session._emit("changeFold", {data:{start:{row: w.row}}});

      this.$updateRows();
      this.renderWidgets(null, renderer);
      this.onWidgetChanged(w);
      return w;
    };

    this.removeLineWidget = function(w) {
      w._inDocument = false;
      w.session = null;
      if (w.el && w.el.parentNode)
        w.el.parentNode.removeChild(w.el);
      if (w.editor && w.editor.destroy) try {
        w.editor.destroy();
      } catch(e){}
      if (this.session.lineWidgets) {
        var w1 = this.session.lineWidgets[w.row]
        if (w1 == w) {
          this.session.lineWidgets[w.row] = w.$oldWidget;
          if (w.$oldWidget)
            this.onWidgetChanged(w.$oldWidget);
        } else {
          while (w1) {
            if (w1.$oldWidget == w) {
              w1.$oldWidget = w.$oldWidget;
              break;
            }
            w1 = w1.$oldWidget;
          }
        }
      }
      this.session._emit("changeFold", {data:{start:{row: w.row}}});
      this.$updateRows();
    };

    this.getWidgetsAtRow = function(row) {
      var lineWidgets = this.session.lineWidgets;
      var w = lineWidgets && lineWidgets[row];
      var list = [];
      while (w) {
        list.push(w);
        w = w.$oldWidget;
      }
      return list;
    };

    this.onWidgetChanged = function(w) {
      this.session._changedWidgets.push(w);
      this.editor && this.editor.renderer.updateFull();
    };

    this.measureWidgets = function(e, renderer) {
      var changedWidgets = this.session._changedWidgets;
      var config = renderer.layerConfig;

      if (!changedWidgets || !changedWidgets.length) return;
      var min = Infinity;
      for (var i = 0; i < changedWidgets.length; i++) {
        var w = changedWidgets[i];
        if (!w || !w.el) continue;
        if (w.session != this.session) continue;
        if (!w._inDocument) {
          if (this.session.lineWidgets[w.row] != w)
            continue;
          w._inDocument = true;
          renderer.container.appendChild(w.el);
        }

        w.h = w.el.offsetHeight;

        if (!w.fixedWidth) {
          w.w = w.el.offsetWidth;
          w.screenWidth = Math.ceil(w.w / config.characterWidth);
        }

        var rowCount = w.h / config.lineHeight;
        if (w.coverLine) {
          rowCount -= this.session.getRowLineCount(w.row);
          if (rowCount < 0)
            rowCount = 0;
        }
        if (w.rowCount != rowCount) {
          w.rowCount = rowCount;
          if (w.row < min)
            min = w.row;
        }
      }
      if (min != Infinity) {
        this.session._emit("changeFold", {data:{start:{row: min}}});
        this.session.lineWidgetWidth = null;
      }
      this.session._changedWidgets = [];
    };

    this.renderWidgets = function(e, renderer) {
      var config = renderer.layerConfig;
      var lineWidgets = this.session.lineWidgets;
      if (!lineWidgets)
        return;
      var first = Math.min(this.firstRow, config.firstRow);
      var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);

      while (first > 0 && !lineWidgets[first])
        first--;

      this.firstRow = config.firstRow;
      this.lastRow = config.lastRow;

      renderer.$cursorLayer.config = config;
      for (var i = first; i <= last; i++) {
        var w = lineWidgets[i];
        if (!w || !w.el) continue;
        if (w.hidden) {
          w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
          continue;
        }
        if (!w._inDocument) {
          w._inDocument = true;
          renderer.container.appendChild(w.el);
        }
        var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
        if (!w.coverLine)
          top += config.lineHeight * this.session.getRowLineCount(w.row);
        w.el.style.top = top - config.offset + "px";

        var left = w.coverGutter ? 0 : renderer.gutterWidth;
        if (!w.fixedWidth)
          left -= renderer.scrollLeft;
        w.el.style.left = left + "px";

        if (w.fullWidth && w.screenWidth) {
          w.el.style.minWidth = config.width + 2 * config.padding + "px";
        }

        if (w.fixedWidth) {
          w.el.style.right = renderer.scrollBar.getWidth() + "px";
        } else {
          w.el.style.right = "";
        }
      }
    };

  }).call(LineWidgets.prototype);


  exports.LineWidgets = LineWidgets;

});

ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(require, exports, module) {
  "use strict";
  var LineWidgets = require("../line_widgets").LineWidgets;
  var dom = require("../lib/dom");
  var Range = require("../range").Range;

  function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
      var mid = (first + last) >> 1;
      var c = comparator(needle, array[mid]);
      if (c > 0)
        first = mid + 1;
      else if (c < 0)
        last = mid - 1;
      else
        return mid;
    }
    return -(first + 1);
  }

  function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
      return;

    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
      i = -i - 1;

    if (i >= annotations.length)
      i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
      i = annotations.length - 1;

    var annotation = annotations[i];
    if (!annotation || !dir)
      return;

    if (annotation.row === row) {
      do {
        annotation = annotations[i += dir];
      } while (annotation && annotation.row === row);
      if (!annotation)
        return annotations.slice();
    }


    var matched = [];
    row = annotation.row;
    do {
      matched[dir < 0 ? "unshift" : "push"](annotation);
      annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
  }

  exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
      session.widgetManager = new LineWidgets(session);
      session.widgetManager.attach(editor);
    }

    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
      return w.type == "errorMarker";
    })[0];
    if (oldWidget) {
      oldWidget.destroy();
    } else {
      row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
      var annotation = annotations[0];
      pos.column = (annotation.pos && typeof annotation.column != "number"
          ? annotation.pos.sc
          : annotation.column) || 0;
      pos.row = annotation.row;
      gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
      return;
    } else {
      gutterAnno = {
        text: ["Looks good!"],
        className: "ace_ok"
      };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);

    var w = {
      row: pos.row,
      fixedWidth: true,
      coverGutter: true,
      el: dom.createElement("div"),
      type: "errorMarker"
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;

    var left = editor.renderer.$cursorLayer
      .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";

    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join("<br>");

    el.appendChild(dom.createElement("div"));

    var kb = function(_, hashId, keyString) {
      if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
        w.destroy();
        return {command: "null"};
      }
    };

    w.destroy = function() {
      if (editor.$mouseHandler.isMousePressed)
        return;
      editor.keyBinding.removeKeyboardHandler(kb);
      session.widgetManager.removeLineWidget(w);
      editor.off("changeSelection", w.destroy);
      editor.off("changeSession", w.destroy);
      editor.off("mouseup", w.destroy);
      editor.off("change", w.destroy);
    };

    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);

    editor.session.widgetManager.addLineWidget(w);

    w.el.onmousedown = editor.focus.bind(editor);

    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
  };


  dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

});

ace.define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(require, exports, module) {
  "use strict";

  require("./lib/fixoldbrowsers");

  var dom = require("./lib/dom");
  var event = require("./lib/event");

  var Editor = require("./editor").Editor;
  var EditSession = require("./edit_session").EditSession;
  var UndoManager = require("./undomanager").UndoManager;
  var Renderer = require("./virtual_renderer").VirtualRenderer;
  require("./worker/worker_client");
  require("./keyboard/hash_handler");
  require("./placeholder");
  require("./multi_select");
  require("./mode/folding/fold_mode");
  require("./theme/textmate");
  require("./ext/error_marker");

  exports.config = require("./config");
  exports.require = require;

  if (typeof define === "function")
    exports.define = define;
  exports.edit = function(el) {
    if (typeof el == "string") {
      var _id = el;
      el = document.getElementById(_id);
      if (!el)
        throw new Error("ace.edit can't find div #" + _id);
    }

    if (el && el.env && el.env.editor instanceof Editor)
      return el.env.editor;

    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
      var oldNode = el;
      value = oldNode.value;
      el = dom.createElement("pre");
      oldNode.parentNode.replaceChild(el, oldNode);
    } else if (el) {
      value = dom.getInnerText(el);
      el.innerHTML = "";
    }

    var doc = exports.createEditSession(value);

    var editor = new Editor(new Renderer(el));
    editor.setSession(doc);

    var env = {
      document: doc,
      editor: editor,
      onResize: editor.resize.bind(editor, null)
    };
    if (oldNode) env.textarea = oldNode;
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function() {
      event.removeListener(window, "resize", env.onResize);
      env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
  };
  exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
  }
  exports.EditSession = EditSession;
  exports.UndoManager = UndoManager;
  exports.version = "1.2.6";
});
(function() {
  ace.require(["ace/ace"], function(a) {
    if (a) {
      a.config.init(true);
      a.define = ace.define;
    }
    if (!window.ace)
      window.ace = a;
    for (var key in a) if (a.hasOwnProperty(key))
      window.ace[key] = a[key];
  });
})();

ace.define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
  "use strict";

  var oop = require("../lib/oop");
  var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

  var DocCommentHighlightRules = function() {
    this.$rules = {
      "start" : [ {
        token : "comment.doc.tag",
        regex : "@[\\w\\d_]+" // TODO: fix email addresses
      },
        DocCommentHighlightRules.getTagRule(),
        {
          defaultToken : "comment.doc",
          caseInsensitive: true
        }]
    };
  };

  oop.inherits(DocCommentHighlightRules, TextHighlightRules);

  DocCommentHighlightRules.getTagRule = function(start) {
    return {
      token : "comment.doc.tag.storage.type",
      regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
    };
  }

  DocCommentHighlightRules.getStartRule = function(start) {
    return {
      token : "comment.doc", // doc comment
      regex : "\\/\\*(?=\\*)",
      next  : start
    };
  };

  DocCommentHighlightRules.getEndRule = function (start) {
    return {
      token : "comment.doc", // closing comment
      regex : "\\*\\/",
      next  : start
    };
  };


  exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

ace.define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(require, exports, module) {
  "use strict";

  var oop = require("../lib/oop");
  var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
  var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
  var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

  var JavaScriptHighlightRules = function(options) {
    var keywordMapper = this.createKeywordMapper({
      "variable.language":
      "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
      "Namespace|QName|XML|XMLList|"                                             + // E4X
      "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
      "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
      "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
      "SyntaxError|TypeError|URIError|"                                          +
      "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
      "isNaN|parseFloat|parseInt|"                                               +
      "JSON|Math|"                                                               + // Other
      "this|arguments|prototype|window|document"                                 , // Pseudo
      "keyword":
      "const|yield|import|get|set|async|await|" +
      "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
      "if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
      "__parent__|__count__|escape|unescape|with|__proto__|" +
      "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
      "storage.type":
        "const|let|var|function",
      "constant.language":
        "null|Infinity|NaN|undefined",
      "support.function":
        "alert",
      "constant.language.boolean": "true|false"
    }, "identifier");
    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
      "u[0-9a-fA-F]{4}|" + // unicode
      "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
      "[0-2][0-7]{0,2}|" + // oct
      "3[0-7][0-7]?|" + // oct
      "[4-7][0-7]?|" + //oct
      ".)";

    this.$rules = {
      "no_regex" : [
        DocCommentHighlightRules.getStartRule("doc-start"),
        comments("no_regex"),
        {
          token : "string",
          regex : "'(?=.)",
          next  : "qstring"
        }, {
          token : "string",
          regex : '"(?=.)',
          next  : "qqstring"
        }, {
          token : "constant.numeric", // hex
          regex : /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
        }, {
          token : "constant.numeric", // float
          regex : /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
        }, {
          token : [
            "storage.type", "punctuation.operator", "support.function",
            "punctuation.operator", "entity.name.function", "text","keyword.operator"
          ],
          regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
          next: "function_arguments"
        }, {
          token : [
            "storage.type", "punctuation.operator", "entity.name.function", "text",
            "keyword.operator", "text", "storage.type", "text", "paren.lparen"
          ],
          regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token : [
            "entity.name.function", "text", "keyword.operator", "text", "storage.type",
            "text", "paren.lparen"
          ],
          regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token : [
            "storage.type", "punctuation.operator", "entity.name.function", "text",
            "keyword.operator", "text",
            "storage.type", "text", "entity.name.function", "text", "paren.lparen"
          ],
          regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token : [
            "storage.type", "text", "entity.name.function", "text", "paren.lparen"
          ],
          regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token : [
            "entity.name.function", "text", "punctuation.operator",
            "text", "storage.type", "text", "paren.lparen"
          ],
          regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token : [
            "text", "text", "storage.type", "text", "paren.lparen"
          ],
          regex : "(:)(\\s*)(function)(\\s*)(\\()",
          next: "function_arguments"
        }, {
          token : "keyword",
          regex : "(?:" + kwBeforeRe + ")\\b",
          next : "start"
        }, {
          token : ["support.constant"],
          regex : /that\b/
        }, {
          token : ["storage.type", "punctuation.operator", "support.function.firebug"],
          regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
        }, {
          token : keywordMapper,
          regex : identifierRe
        }, {
          token : "punctuation.operator",
          regex : /[.](?![.])/,
          next  : "property"
        }, {
          token : "keyword.operator",
          regex : /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
          next  : "start"
        }, {
          token : "punctuation.operator",
          regex : /[?:,;.]/,
          next  : "start"
        }, {
          token : "paren.lparen",
          regex : /[\[({]/,
          next  : "start"
        }, {
          token : "paren.rparen",
          regex : /[\])}]/
        }, {
          token: "comment",
          regex: /^#!.*$/
        }
      ],
      property: [{
        token : "text",
        regex : "\\s+"
      }, {
        token : [
          "storage.type", "punctuation.operator", "entity.name.function", "text",
          "keyword.operator", "text",
          "storage.type", "text", "entity.name.function", "text", "paren.lparen"
        ],
        regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
        next: "function_arguments"
      }, {
        token : "punctuation.operator",
        regex : /[.](?![.])/
      }, {
        token : "support.function",
        regex : /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
      }, {
        token : "support.function.dom",
        regex : /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
      }, {
        token :  "support.constant",
        regex : /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
      }, {
        token : "identifier",
        regex : identifierRe
      }, {
        regex: "",
        token: "empty",
        next: "no_regex"
      }
      ],
      "start": [
        DocCommentHighlightRules.getStartRule("doc-start"),
        comments("start"),
        {
          token: "string.regexp",
          regex: "\\/",
          next: "regex"
        }, {
          token : "text",
          regex : "\\s+|^$",
          next : "start"
        }, {
          token: "empty",
          regex: "",
          next: "no_regex"
        }
      ],
      "regex": [
        {
          token: "regexp.keyword.operator",
          regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
        }, {
          token: "string.regexp",
          regex: "/[sxngimy]*",
          next: "no_regex"
        }, {
          token : "invalid",
          regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
        }, {
          token : "constant.language.escape",
          regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
        }, {
          token : "constant.language.delimiter",
          regex: /\|/
        }, {
          token: "constant.language.escape",
          regex: /\[\^?/,
          next: "regex_character_class"
        }, {
          token: "empty",
          regex: "$",
          next: "no_regex"
        }, {
          defaultToken: "string.regexp"
        }
      ],
      "regex_character_class": [
        {
          token: "regexp.charclass.keyword.operator",
          regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
        }, {
          token: "constant.language.escape",
          regex: "]",
          next: "regex"
        }, {
          token: "constant.language.escape",
          regex: "-"
        }, {
          token: "empty",
          regex: "$",
          next: "no_regex"
        }, {
          defaultToken: "string.regexp.charachterclass"
        }
      ],
      "function_arguments": [
        {
          token: "variable.parameter",
          regex: identifierRe
        }, {
          token: "punctuation.operator",
          regex: "[, ]+"
        }, {
          token: "punctuation.operator",
          regex: "$"
        }, {
          token: "empty",
          regex: "",
          next: "no_regex"
        }
      ],
      "qqstring" : [
        {
          token : "constant.language.escape",
          regex : escapedRe
        }, {
          token : "string",
          regex : "\\\\$",
          next  : "qqstring"
        }, {
          token : "string",
          regex : '"|$',
          next  : "no_regex"
        }, {
          defaultToken: "string"
        }
      ],
      "qstring" : [
        {
          token : "constant.language.escape",
          regex : escapedRe
        }, {
          token : "string",
          regex : "\\\\$",
          next  : "qstring"
        }, {
          token : "string",
          regex : "'|$",
          next  : "no_regex"
        }, {
          defaultToken: "string"
        }
      ]
    };


    if (!options || !options.noES6) {
      this.$rules.no_regex.unshift({
        regex: "[{}]", onMatch: function(val, state, stack) {
          this.next = val == "{" ? this.nextState : "";
          if (val == "{" && stack.length) {
            stack.unshift("start", state);
          }
          else if (val == "}" && stack.length) {
            stack.shift();
            this.next = stack.shift();
            if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
              return "paren.quasi.end";
          }
          return val == "{" ? "paren.lparen" : "paren.rparen";
        },
        nextState: "start"
      }, {
        token : "string.quasi.start",
        regex : /`/,
        push  : [{
          token : "constant.language.escape",
          regex : escapedRe
        }, {
          token : "paren.quasi.start",
          regex : /\${/,
          push  : "start"
        }, {
          token : "string.quasi.end",
          regex : /`/,
          next  : "pop"
        }, {
          defaultToken: "string.quasi"
        }]
      });

      if (!options || options.jsx != false)
        JSX.call(this);
    }

    this.embedRules(DocCommentHighlightRules, "doc-",
      [ DocCommentHighlightRules.getEndRule("no_regex") ]);

    this.normalizeRules();
  };

  oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

  function JSX() {
    var tagRegex = identifierRe.replace("\\d", "\\d\\-");
    var jsxTag = {
      onMatch : function(val, state, stack) {
        var offset = val.charAt(1) == "/" ? 2 : 1;
        if (offset == 1) {
          if (state != this.nextState)
            stack.unshift(this.next, this.nextState, 0);
          else
            stack.unshift(this.next);
          stack[2]++;
        } else if (offset == 2) {
          if (state == this.nextState) {
            stack[1]--;
            if (!stack[1] || stack[1] < 0) {
              stack.shift();
              stack.shift();
            }
          }
        }
        return [{
          type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
          value: val.slice(0, offset)
        }, {
          type: "meta.tag.tag-name.xml",
          value: val.substr(offset)
        }];
      },
      regex : "</?" + tagRegex + "",
      next: "jsxAttributes",
      nextState: "jsx"
    };
    this.$rules.start.unshift(jsxTag);
    var jsxJsRule = {
      regex: "{",
      token: "paren.quasi.start",
      push: "start"
    };
    this.$rules.jsx = [
      jsxJsRule,
      jsxTag,
      {include : "reference"},
      {defaultToken: "string"}
    ];
    this.$rules.jsxAttributes = [{
      token : "meta.tag.punctuation.tag-close.xml",
      regex : "/?>",
      onMatch : function(value, currentState, stack) {
        if (currentState == stack[0])
          stack.shift();
        if (value.length == 2) {
          if (stack[0] == this.nextState)
            stack[1]--;
          if (!stack[1] || stack[1] < 0) {
            stack.splice(0, 2);
          }
        }
        this.next = stack[0] || "start";
        return [{type: this.token, value: value}];
      },
      nextState: "jsx"
    },
      jsxJsRule,
      comments("jsxAttributes"),
      {
        token : "entity.other.attribute-name.xml",
        regex : tagRegex
      }, {
        token : "keyword.operator.attribute-equals.xml",
        regex : "="
      }, {
        token : "text.tag-whitespace.xml",
        regex : "\\s+"
      }, {
        token : "string.attribute-value.xml",
        regex : "'",
        stateName : "jsx_attr_q",
        push : [
          {token : "string.attribute-value.xml", regex: "'", next: "pop"},
          {include : "reference"},
          {defaultToken : "string.attribute-value.xml"}
        ]
      }, {
        token : "string.attribute-value.xml",
        regex : '"',
        stateName : "jsx_attr_qq",
        push : [
          {token : "string.attribute-value.xml", regex: '"', next: "pop"},
          {include : "reference"},
          {defaultToken : "string.attribute-value.xml"}
        ]
      },
      jsxTag
    ];
    this.$rules.reference = [{
      token : "constant.language.escape.reference.xml",
      regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
    }];
  }

  function comments(next) {
    return [
      {
        token : "comment", // multi line comment
        regex : /\/\*/,
        next: [
          DocCommentHighlightRules.getTagRule(),
          {token : "comment", regex : "\\*\\/", next : next || "pop"},
          {defaultToken : "comment", caseInsensitive: true}
        ]
      }, {
        token : "comment",
        regex : "\\/\\/",
        next: [
          DocCommentHighlightRules.getTagRule(),
          {token : "comment", regex : "$|^", next : next || "pop"},
          {defaultToken : "comment", caseInsensitive: true}
        ]
      }
    ];
  }
  exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
});

ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module) {
  "use strict";

  var Range = require("../range").Range;

  var MatchingBraceOutdent = function() {};

  (function() {

    this.checkOutdent = function(line, input) {
      if (! /^\s+$/.test(line))
        return false;

      return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
      var line = doc.getLine(row);
      var match = line.match(/^(\s*\})/);

      if (!match) return 0;

      var column = match[1].length;
      var openBracePos = doc.findMatchingBracket({row: row, column: column});

      if (!openBracePos || openBracePos.row == row) return 0;

      var indent = this.$getIndent(doc.getLine(openBracePos.row));
      doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
      return line.match(/^\s*/)[0];
    };

  }).call(MatchingBraceOutdent.prototype);

  exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {
  "use strict";

  var oop = require("../../lib/oop");
  var Range = require("../../range").Range;
  var BaseFoldMode = require("./fold_mode").FoldMode;

  var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
      this.foldingStartMarker = new RegExp(
        this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
      );
      this.foldingStopMarker = new RegExp(
        this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
      );
    }
  };
  oop.inherits(FoldMode, BaseFoldMode);

  (function() {

    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function(session, foldStyle, row) {
      var line = session.getLine(row);

      if (this.singleLineBlockCommentRe.test(line)) {
        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
          return "";
      }

      var fw = this._getFoldWidgetBase(session, foldStyle, row);

      if (!fw && this.startRegionRe.test(line))
        return "start"; // lineCommentRegionStart

      return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
      var line = session.getLine(row);

      if (this.startRegionRe.test(line))
        return this.getCommentRegionBlock(session, line, row);

      var match = line.match(this.foldingStartMarker);
      if (match) {
        var i = match.index;

        if (match[1])
          return this.openingBracketBlock(session, match[1], row, i);

        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

        if (range && !range.isMultiLine()) {
          if (forceMultiline) {
            range = this.getSectionRange(session, row);
          } else if (foldStyle != "all")
            range = null;
        }

        return range;
      }

      if (foldStyle === "markbegin")
        return;

      var match = line.match(this.foldingStopMarker);
      if (match) {
        var i = match.index + match[0].length;

        if (match[1])
          return this.closingBracketBlock(session, match[1], row, i);

        return session.getCommentFoldRange(row, i, -1);
      }
    };

    this.getSectionRange = function(session, row) {
      var line = session.getLine(row);
      var startIndent = line.search(/\S/);
      var startRow = row;
      var startColumn = line.length;
      row = row + 1;
      var endRow = row;
      var maxRow = session.getLength();
      while (++row < maxRow) {
        line = session.getLine(row);
        var indent = line.search(/\S/);
        if (indent === -1)
          continue;
        if  (startIndent > indent)
          break;
        var subRange = this.getFoldWidgetRange(session, "all", row);

        if (subRange) {
          if (subRange.start.row <= startRow) {
            break;
          } else if (subRange.isMultiLine()) {
            row = subRange.end.row;
          } else if (startIndent == indent) {
            break;
          }
        }
        endRow = row;
      }

      return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function(session, line, row) {
      var startColumn = line.search(/\s*$/);
      var maxRow = session.getLength();
      var startRow = row;

      var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
      var depth = 1;
      while (++row < maxRow) {
        line = session.getLine(row);
        var m = re.exec(line);
        if (!m) continue;
        if (m[1]) depth--;
        else depth++;

        if (!depth) break;
      }

      var endRow = row;
      if (endRow > startRow) {
        return new Range(startRow, startColumn, endRow, line.length);
      }
    };

  }).call(FoldMode.prototype);

});

ace.define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module) {
  "use strict";

  var oop = require("../lib/oop");
  var TextMode = require("./text").Mode;
  var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
  var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
  var WorkerClient = require("../worker/worker_client").WorkerClient;
  var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
  var CStyleFoldMode = require("./folding/cstyle").FoldMode;

  var Mode = function() {
    this.HighlightRules = JavaScriptHighlightRules;

    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
  };
  oop.inherits(Mode, TextMode);

  (function() {

    this.lineCommentStart = "//";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
      var indent = this.$getIndent(line);

      var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
      var tokens = tokenizedLine.tokens;
      var endState = tokenizedLine.state;

      if (tokens.length && tokens[tokens.length-1].type == "comment") {
        return indent;
      }

      if (state == "start" || state == "no_regex") {
        var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
        if (match) {
          indent += tab;
        }
      } else if (state == "doc-start") {
        if (endState == "start" || endState == "no_regex") {
          return "";
        }
        var match = line.match(/^\s*(\/?)\*/);
        if (match) {
          if (match[1]) {
            indent += " ";
          }
          indent += "* ";
        }
      }

      return indent;
    };

    this.checkOutdent = function(state, line, input) {
      return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
      this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
      var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
      worker.attachToDocument(session.getDocument());

      worker.on("annotate", function(results) {
        session.setAnnotations(results.data);
      });

      worker.on("terminate", function() {
        session.clearAnnotations();
      });

      return worker;
    };

    this.$id = "ace/mode/javascript";
  }).call(Mode.prototype);

  exports.Mode = Mode;
});

ace.define("ace/theme/chrome",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

  exports.isDark = false;
  exports.cssClass = "ace-chrome";
  exports.cssText = ".ace-chrome .ace_gutter {\
background: #ebebeb;\
color: #333;\
overflow : hidden;\
}\
.ace-chrome .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-chrome {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-chrome .ace_cursor {\
color: black;\
}\
.ace-chrome .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-chrome .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-chrome .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-chrome .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-chrome .ace_invalid {\
background-color: rgb(153, 0, 0);\
color: white;\
}\
.ace-chrome .ace_fold {\
}\
.ace-chrome .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-chrome .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-chrome .ace_support.ace_type,\
.ace-chrome .ace_support.ace_class\
.ace-chrome .ace_support.ace_other {\
color: rgb(109, 121, 222);\
}\
.ace-chrome .ace_variable.ace_parameter {\
font-style:italic;\
color:#FD971F;\
}\
.ace-chrome .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-chrome .ace_comment {\
color: #236e24;\
}\
.ace-chrome .ace_comment.ace_doc {\
color: #236e24;\
}\
.ace-chrome .ace_comment.ace_doc.ace_tag {\
color: #236e24;\
}\
.ace-chrome .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-chrome .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-chrome .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-chrome .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-chrome .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-chrome .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-chrome .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-chrome .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-chrome .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-chrome .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-chrome .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-chrome .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-chrome .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-chrome .ace_storage,\
.ace-chrome .ace_keyword,\
.ace-chrome .ace_meta.ace_tag {\
color: rgb(147, 15, 128);\
}\
.ace-chrome .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-chrome .ace_string {\
color: #1A1AA6;\
}\
.ace-chrome .ace_entity.ace_other.ace_attribute-name {\
color: #994409;\
}\
.ace-chrome .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

  var dom = require("../lib/dom");
  dom.importCssString(exports.cssText, exports.cssClass);
});

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

 The MIT License (MIT)

 Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation files
 (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge,
 publish, distribute, sublicense, and/or sell copies of the Software,
 and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

 JS Beautifier
 ---------------


 Written by Einar Lielmanis, <einar@jsbeautifier.org>
 http://jsbeautifier.org/

 Originally converted to javascript by Vital, <vital76@gmail.com>
 "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
 Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


 Usage:
 js_beautify(js_source_text);
 js_beautify(js_source_text, options);

 The options are:
 indent_size (default 4)          - indentation size,
 indent_char (default space)      - character to indent with,
 preserve_newlines (default true) - whether existing line breaks should be preserved,
 max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

 jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

 jslint_happy        !jslint_happy
 ---------------------------------
 function ()         function()

 switch () {         switch() {
 case 1:               case 1:
 break;                break;
 }                   }

 space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
 NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

 brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none" | any of the former + ",preserve-inline"
 put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
 preserve-inline will try to preserve inline blocks of curly braces

 space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

 unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

 wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
 NOTE: This is not a hard limit. Lines will continue until a point where a newline would
 be preserved if it were present.

 end_with_newline (default false)  - end output with a newline


 e.g

 js_beautify(js_source_text, {
 'indent_size': 1,
 'indent_char': '\t'
 });

 */

// Object.values polyfill found here:
// http://tokenposts.blogspot.com.au/2012/04/javascript-objectkeys-browser.html
if (!Object.values) {
  Object.values = function(o) {
    if (o !== Object(o)) {
      throw new TypeError('Object.values called on a non-object');
    }
    var k = [],
      p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) {
        k.push(o[p]);
      }
    }
    return k;
  };
}

(function() {

  function mergeOpts(allOptions, targetType) {
    var finalOpts = {};
    var name;

    for (name in allOptions) {
      if (name !== targetType) {
        finalOpts[name] = allOptions[name];
      }
    }

    //merge in the per type settings for the targetType
    if (targetType in allOptions) {
      for (name in allOptions[targetType]) {
        finalOpts[name] = allOptions[targetType][name];
      }
    }
    return finalOpts;
  }

  function js_beautify(js_source_text, options) {

    var acorn = {};
    (function(exports) {
      /* jshint curly: false */
      // This section of code is taken from acorn.
      //
      // Acorn was written by Marijn Haverbeke and released under an MIT
      // license. The Unicode regexps (for identifiers and whitespace) were
      // taken from [Esprima](http://esprima.org) by Ariya Hidayat.
      //
      // Git repositories for Acorn are available at
      //
      //     http://marijnhaverbeke.nl/git/acorn
      //     https://github.com/marijnh/acorn.git

      // ## Character categories

      // Big ugly regular expressions that match characters in the
      // whitespace, identifier, and identifier-start categories. These
      // are only applied when a character is found to actually have a
      // code point above 128.

      var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
      var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
      var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

      // Whether a single character denotes a newline.

      exports.newline = /[\n\r\u2028\u2029]/;

      // Matches a whole line break (where CRLF is considered a single
      // line break). Used to count lines.

      // in javascript, these two differ
      // in python they are the same, different methods are called on them
      exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
      exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


      // Test whether a given character code starts an identifier.

      exports.isIdentifierStart = function(code) {
        // permit $ (36) and @ (64). @ is used in ES7 decorators.
        if (code < 65) return code === 36 || code === 64;
        // 65 through 91 are uppercase letters.
        if (code < 91) return true;
        // permit _ (95).
        if (code < 97) return code === 95;
        // 97 through 123 are lowercase letters.
        if (code < 123) return true;
        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
      };

      // Test whether a given character is part of an identifier.

      exports.isIdentifierChar = function(code) {
        if (code < 48) return code === 36;
        if (code < 58) return true;
        if (code < 65) return false;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123) return true;
        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
      };
    })(acorn);
    /* jshint curly: true */

    function in_array(what, arr) {
      for (var i = 0; i < arr.length; i += 1) {
        if (arr[i] === what) {
          return true;
        }
      }
      return false;
    }

    function trim(s) {
      return s.replace(/^\s+|\s+$/g, '');
    }

    function ltrim(s) {
      return s.replace(/^\s+/g, '');
    }

    // function rtrim(s) {
    //     return s.replace(/\s+$/g, '');
    // }

    function sanitizeOperatorPosition(opPosition) {
      opPosition = opPosition || OPERATOR_POSITION.before_newline;

      var validPositionValues = Object.values(OPERATOR_POSITION);

      if (!in_array(opPosition, validPositionValues)) {
        throw new Error("Invalid Option Value: The option 'operator_position' must be one of the following values\n" +
          validPositionValues +
          "\nYou passed in: '" + opPosition + "'");
      }

      return opPosition;
    }

    var OPERATOR_POSITION = {
      before_newline: 'before-newline',
      after_newline: 'after-newline',
      preserve_newline: 'preserve-newline',
    };

    var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

    var MODE = {
      BlockStatement: 'BlockStatement', // 'BLOCK'
      Statement: 'Statement', // 'STATEMENT'
      ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
      ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
      ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
      Conditional: 'Conditional', //'(COND-EXPRESSION)',
      Expression: 'Expression' //'(EXPRESSION)'
    };

    function Beautifier(js_source_text, options) {
      "use strict";
      var output;
      var tokens = [],
        token_pos;
      var Tokenizer;
      var current_token;
      var last_type, last_last_text, indent_string;
      var flags, previous_flags, flag_store;
      var prefix;

      var handlers, opt;
      var baseIndentString = '';

      handlers = {
        'TK_START_EXPR': handle_start_expr,
        'TK_END_EXPR': handle_end_expr,
        'TK_START_BLOCK': handle_start_block,
        'TK_END_BLOCK': handle_end_block,
        'TK_WORD': handle_word,
        'TK_RESERVED': handle_word,
        'TK_SEMICOLON': handle_semicolon,
        'TK_STRING': handle_string,
        'TK_EQUALS': handle_equals,
        'TK_OPERATOR': handle_operator,
        'TK_COMMA': handle_comma,
        'TK_BLOCK_COMMENT': handle_block_comment,
        'TK_COMMENT': handle_comment,
        'TK_DOT': handle_dot,
        'TK_UNKNOWN': handle_unknown,
        'TK_EOF': handle_eof
      };

      function create_flags(flags_base, mode) {
        var next_indent_level = 0;
        if (flags_base) {
          next_indent_level = flags_base.indentation_level;
          if (!output.just_added_newline() &&
            flags_base.line_indent_level > next_indent_level) {
            next_indent_level = flags_base.line_indent_level;
          }
        }

        var next_flags = {
          mode: mode,
          parent: flags_base,
          last_text: flags_base ? flags_base.last_text : '', // last token text
          last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
          declaration_statement: false,
          declaration_assignment: false,
          multiline_frame: false,
          inline_frame: false,
          if_block: false,
          else_block: false,
          do_block: false,
          do_while: false,
          import_block: false,
          in_case_statement: false, // switch(..){ INSIDE HERE }
          in_case: false, // we're on the exact line with "case 0:"
          case_body: false, // the indented case-action block
          indentation_level: next_indent_level,
          line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
          start_line_index: output.get_line_number(),
          ternary_depth: 0
        };
        return next_flags;
      }

      // Some interpreters have unexpected results with foo = baz || bar;
      options = options ? options : {};

      // Allow the setting of language/file-type specific options
      // with inheritance of overall settings
      options = mergeOpts(options, 'js');

      opt = {};

      // compatibility, re
      if (options.brace_style === "expand-strict") { //graceful handling of deprecated option
        options.brace_style = "expand";
      } else if (options.brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
        options.brace_style = "collapse,preserve-inline";
      } else if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
        options.brace_style = options.braces_on_own_line ? "expand" : "collapse";
      } else if (!options.brace_style) //Nothing exists to set it
      {
        options.brace_style = "collapse";
      }


      var brace_style_split = options.brace_style.split(/[^a-zA-Z0-9_\-]+/);
      opt.brace_style = brace_style_split[0];
      opt.brace_preserve_inline = brace_style_split[1] ? brace_style_split[1] : false;

      opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
      opt.indent_char = options.indent_char ? options.indent_char : ' ';
      opt.eol = options.eol ? options.eol : 'auto';
      opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
      opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
      opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
      opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
      opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
      opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
      opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;
      opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
      opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
      opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
      opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
      opt.e4x = (options.e4x === undefined) ? false : options.e4x;
      opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
      opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first;
      opt.operator_position = sanitizeOperatorPosition(options.operator_position);

      // For testing of beautify ignore:start directive
      opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw;

      // force opt.space_after_anon_function to true if opt.jslint_happy
      if (opt.jslint_happy) {
        opt.space_after_anon_function = true;
      }

      if (options.indent_with_tabs) {
        opt.indent_char = '\t';
        opt.indent_size = 1;
      }

      if (opt.eol === 'auto') {
        opt.eol = '\n';
        if (js_source_text && acorn.lineBreak.test(js_source_text || '')) {
          opt.eol = js_source_text.match(acorn.lineBreak)[0];
        }
      }

      opt.eol = opt.eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

      //----------------------------------
      indent_string = '';
      while (opt.indent_size > 0) {
        indent_string += opt.indent_char;
        opt.indent_size -= 1;
      }

      var preindent_index = 0;
      if (js_source_text && js_source_text.length) {
        while ((js_source_text.charAt(preindent_index) === ' ' ||
        js_source_text.charAt(preindent_index) === '\t')) {
          baseIndentString += js_source_text.charAt(preindent_index);
          preindent_index += 1;
        }
        js_source_text = js_source_text.substring(preindent_index);
      }

      last_type = 'TK_START_BLOCK'; // last token type
      last_last_text = ''; // pre-last token text
      output = new Output(indent_string, baseIndentString);

      // If testing the ignore directive, start with output disable set to true
      output.raw = opt.test_output_raw;


      // Stack of parsing/formatting states, including MODE.
      // We tokenize, parse, and output in an almost purely a forward-only stream of token input
      // and formatted output.  This makes the beautifier less accurate than full parsers
      // but also far more tolerant of syntax errors.
      //
      // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
      // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
      // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
      // most full parsers would die, but the beautifier gracefully falls back to
      // MODE.BlockStatement and continues on.
      flag_store = [];
      set_mode(MODE.BlockStatement);

      this.beautify = function() {

        /*jshint onevar:true */
        var sweet_code;
        Tokenizer = new tokenizer(js_source_text, opt, indent_string);
        tokens = Tokenizer.tokenize();
        token_pos = 0;

        current_token = get_token();
        while (current_token) {
          handlers[current_token.type]();

          last_last_text = flags.last_text;
          last_type = current_token.type;
          flags.last_text = current_token.text;

          token_pos += 1;
          current_token = get_token();
        }

        sweet_code = output.get_code();
        if (opt.end_with_newline) {
          sweet_code += '\n';
        }

        if (opt.eol !== '\n') {
          sweet_code = sweet_code.replace(/[\n]/g, opt.eol);
        }

        return sweet_code;
      };

      function handle_whitespace_and_comments(local_token, preserve_statement_flags) {
        var newlines = local_token.newlines;
        var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
        var temp_token = current_token;

        for (var h = 0; h < local_token.comments_before.length; h++) {
          // The cleanest handling of inline comments is to treat them as though they aren't there.
          // Just continue formatting and the behavior should be logical.
          // Also ignore unknown tokens.  Again, this should result in better behavior.
          current_token = local_token.comments_before[h];
          handle_whitespace_and_comments(current_token, preserve_statement_flags);
          handlers[current_token.type](preserve_statement_flags);
        }
        current_token = temp_token;

        if (keep_whitespace) {
          for (var i = 0; i < newlines; i += 1) {
            print_newline(i > 0, preserve_statement_flags);
          }
        } else {
          if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {
            newlines = opt.max_preserve_newlines;
          }

          if (opt.preserve_newlines) {
            if (local_token.newlines > 1) {
              print_newline(false, preserve_statement_flags);
              for (var j = 1; j < newlines; j += 1) {
                print_newline(true, preserve_statement_flags);
              }
            }
          }
        }

      }

      // we could use just string.split, but
      // IE doesn't like returning empty strings
      function split_linebreaks(s) {
        //return s.split(/\x0d\x0a|\x0a/);

        s = s.replace(acorn.allLineBreaks, '\n');
        var out = [],
          idx = s.indexOf("\n");
        while (idx !== -1) {
          out.push(s.substring(0, idx));
          s = s.substring(idx + 1);
          idx = s.indexOf("\n");
        }
        if (s.length) {
          out.push(s);
        }
        return out;
      }

      var newline_restricted_tokens = ['break', 'continue', 'return', 'throw'];

      function allow_wrap_or_preserved_newline(force_linewrap) {
        force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

        // Never wrap the first token on a line
        if (output.just_added_newline()) {
          return;
        }

        var shouldPreserveOrForce = (opt.preserve_newlines && current_token.wanted_newline) || force_linewrap;
        var operatorLogicApplies = in_array(flags.last_text, Tokenizer.positionable_operators) || in_array(current_token.text, Tokenizer.positionable_operators);

        if (operatorLogicApplies) {
          var shouldPrintOperatorNewline = (
              in_array(flags.last_text, Tokenizer.positionable_operators) &&
              in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
            ) ||
            in_array(current_token.text, Tokenizer.positionable_operators);
          shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
        }

        if (shouldPreserveOrForce) {
          print_newline(false, true);
        } else if (opt.wrap_line_length) {
          if (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens)) {
            // These tokens should never have a newline inserted
            // between them and the following expression.
            return;
          }
          var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +
            (output.space_before_token ? 1 : 0);
          if (proposed_line_length >= opt.wrap_line_length) {
            print_newline(false, true);
          }
        }
      }

      function print_newline(force_newline, preserve_statement_flags) {
        if (!preserve_statement_flags) {
          if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
            var next_token = get_token(1);
            while (flags.mode === MODE.Statement &&
            !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
            !flags.do_block) {
              restore_mode();
            }
          }
        }

        if (output.add_new_line(force_newline)) {
          flags.multiline_frame = true;
        }
      }

      function print_token_line_indentation() {
        if (output.just_added_newline()) {
          if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {
            output.current_line.push(current_token.whitespace_before);
            output.space_before_token = false;
          } else if (output.set_indent(flags.indentation_level)) {
            flags.line_indent_level = flags.indentation_level;
          }
        }
      }

      function print_token(printable_token) {
        if (output.raw) {
          output.add_raw_token(current_token);
          return;
        }

        if (opt.comma_first && last_type === 'TK_COMMA' &&
          output.just_added_newline()) {
          if (output.previous_line.last() === ',') {
            var popped = output.previous_line.pop();
            // if the comma was already at the start of the line,
            // pull back onto that line and reprint the indentation
            if (output.previous_line.is_empty()) {
              output.previous_line.push(popped);
              output.trim(true);
              output.current_line.pop();
              output.trim();
            }

            // add the comma in front of the next token
            print_token_line_indentation();
            output.add_token(',');
            output.space_before_token = true;
          }
        }

        printable_token = printable_token || current_token.text;
        print_token_line_indentation();
        output.add_token(printable_token);
      }

      function indent() {
        flags.indentation_level += 1;
      }

      function deindent() {
        if (flags.indentation_level > 0 &&
          ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level)) {
          flags.indentation_level -= 1;

        }
      }

      function set_mode(mode) {
        if (flags) {
          flag_store.push(flags);
          previous_flags = flags;
        } else {
          previous_flags = create_flags(null, mode);
        }

        flags = create_flags(previous_flags, mode);
      }

      function is_array(mode) {
        return mode === MODE.ArrayLiteral;
      }

      function is_expression(mode) {
        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
      }

      function restore_mode() {
        if (flag_store.length > 0) {
          previous_flags = flags;
          flags = flag_store.pop();
          if (previous_flags.mode === MODE.Statement) {
            output.remove_redundant_indentation(previous_flags);
          }
        }
      }

      function start_of_object_property() {
        return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (
          (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));
      }

      function start_of_statement() {
        if (
          (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||
          (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
          (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw']) && !current_token.wanted_newline) ||
          (last_type === 'TK_RESERVED' && flags.last_text === 'else' &&
          !(current_token.type === 'TK_RESERVED' && current_token.text === 'if' && !current_token.comments_before.length)) ||
          (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
          (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement &&
          !flags.in_case &&
          !(current_token.text === '--' || current_token.text === '++') &&
          last_last_text !== 'function' &&
          current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||
          (flags.mode === MODE.ObjectLiteral && (
          (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))
        ) {

          set_mode(MODE.Statement);
          indent();

          handle_whitespace_and_comments(current_token, true);

          // Issue #276:
          // If starting a new statement with [if, for, while, do], push to a new line.
          // if (a) if (b) if(c) d(); else e(); else f();
          if (!start_of_object_property()) {
            allow_wrap_or_preserved_newline(
              current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));
          }

          return true;
        }
        return false;
      }

      function all_lines_start_with(lines, c) {
        for (var i = 0; i < lines.length; i++) {
          var line = trim(lines[i]);
          if (line.charAt(0) !== c) {
            return false;
          }
        }
        return true;
      }

      function each_line_matches_indent(lines, indent) {
        var i = 0,
          len = lines.length,
          line;
        for (; i < len; i++) {
          line = lines[i];
          // allow empty lines to pass through
          if (line && line.indexOf(indent) !== 0) {
            return false;
          }
        }
        return true;
      }

      function is_special_word(word) {
        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
      }

      function get_token(offset) {
        var index = token_pos + (offset || 0);
        return (index < 0 || index >= tokens.length) ? null : tokens[index];
      }

      function handle_start_expr() {
        // The conditional starts the statement if appropriate.
        if (!start_of_statement()) {
          handle_whitespace_and_comments(current_token);
        }

        var next_mode = MODE.Expression;
        if (current_token.text === '[') {

          if (last_type === 'TK_WORD' || flags.last_text === ')') {
            // this is array index specifier, break immediately
            // a[x], fn()[x]
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {
              output.space_before_token = true;
            }
            set_mode(next_mode);
            print_token();
            indent();
            if (opt.space_in_paren) {
              output.space_before_token = true;
            }
            return;
          }

          next_mode = MODE.ArrayLiteral;
          if (is_array(flags.mode)) {
            if (flags.last_text === '[' ||
              (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
              // ], [ goes to new line
              // }, [ goes to new line
              if (!opt.keep_array_indentation) {
                print_newline();
              }
            }
          }

        } else {
          if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
            next_mode = MODE.ForInitializer;
          } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
            next_mode = MODE.Conditional;
          } else {
            // next_mode = MODE.Expression;
          }
        }

        if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
          print_newline();
        } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
          // TODO: Consider whether forcing this is required.  Review failing tests when removed.
          allow_wrap_or_preserved_newline(current_token.wanted_newline);
          // do nothing on (( and )( and ][ and ]( and .(
        } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
          output.space_before_token = true;
        } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
          (flags.last_text === '*' &&
          (in_array(last_last_text, ['function', 'yield']) ||
          (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
          // function() vs function ()
          // yield*() vs yield* ()
          // function*() vs function* ()
          if (opt.space_after_anon_function) {
            output.space_before_token = true;
          }
        } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {
          if (opt.space_before_conditional) {
            output.space_before_token = true;
          }
        }

        // Should be a space between await and an IIFE
        if (current_token.text === '(' && last_type === 'TK_RESERVED' && flags.last_word === 'await') {
          output.space_before_token = true;
        }

        // Support of this kind of newline preservation.
        // a = (b &&
        //     (c || d));
        if (current_token.text === '(') {
          if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
            if (!start_of_object_property()) {
              allow_wrap_or_preserved_newline();
            }
          }
        }

        // Support preserving wrapped arrow function expressions
        // a.b('c',
        //     () => d.e
        // )
        if (current_token.text === '(' && last_type !== 'TK_WORD' && last_type !== 'TK_RESERVED') {
          allow_wrap_or_preserved_newline();
        }

        set_mode(next_mode);
        print_token();
        if (opt.space_in_paren) {
          output.space_before_token = true;
        }

        // In all cases, if we newline while inside an expression it should be indented.
        indent();
      }

      function handle_end_expr() {
        // statements inside expressions are not valid syntax, but...
        // statements must all be closed when their container closes
        while (flags.mode === MODE.Statement) {
          restore_mode();
        }

        handle_whitespace_and_comments(current_token);

        if (flags.multiline_frame) {
          allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
        }

        if (opt.space_in_paren) {
          if (last_type === 'TK_START_EXPR' && !opt.space_in_empty_paren) {
            // () [] no inner space in empty parens like these, ever, ref #320
            output.trim();
            output.space_before_token = false;
          } else {
            output.space_before_token = true;
          }
        }
        if (current_token.text === ']' && opt.keep_array_indentation) {
          print_token();
          restore_mode();
        } else {
          restore_mode();
          print_token();
        }
        output.remove_redundant_indentation(previous_flags);

        // do {} while () // no statement required after
        if (flags.do_while && previous_flags.mode === MODE.Conditional) {
          previous_flags.mode = MODE.Expression;
          flags.do_block = false;
          flags.do_while = false;

        }
      }

      function handle_start_block() {
        handle_whitespace_and_comments(current_token);

        // Check if this is should be treated as a ObjectLiteral
        var next_token = get_token(1);
        var second_token = get_token(2);
        if (second_token && (
            (in_array(second_token.text, [':', ',']) && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED'])) ||
            (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))
          )) {
          // We don't support TypeScript,but we didn't break it for a very long time.
          // We'll try to keep not breaking it.
          if (!in_array(last_last_text, ['class', 'interface'])) {
            set_mode(MODE.ObjectLiteral);
          } else {
            set_mode(MODE.BlockStatement);
          }
        } else if (last_type === 'TK_OPERATOR' && flags.last_text === '=>') {
          // arrow function: (param1, paramN) => { statements }
          set_mode(MODE.BlockStatement);
        } else if (in_array(last_type, ['TK_EQUALS', 'TK_START_EXPR', 'TK_COMMA', 'TK_OPERATOR']) ||
          (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw', 'import', 'default']))
        ) {
          // Detecting shorthand function syntax is difficult by scanning forward,
          //     so check the surrounding context.
          // If the block is being returned, imported, export default, passed as arg,
          //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
          set_mode(MODE.ObjectLiteral);
        } else {
          set_mode(MODE.BlockStatement);
        }

        var empty_braces = !next_token.comments_before.length && next_token.text === '}';
        var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
          last_type === 'TK_END_EXPR';

        if (opt.brace_preserve_inline) // check for inline, set inline_frame if so
        {
          // search forward for a newline wanted inside this block
          var index = 0;
          var check_token = null;
          flags.inline_frame = true;
          do {
            index += 1;
            check_token = get_token(index);
            if (check_token.wanted_newline) {
              flags.inline_frame = false;
              break;
            }
          } while (check_token.type !== 'TK_EOF' &&
          !(check_token.type === 'TK_END_BLOCK' && check_token.opened === current_token));
        }

        if ((opt.brace_style === "expand" ||
          (opt.brace_style === "none" && current_token.wanted_newline)) &&
          !flags.inline_frame) {
          if (last_type !== 'TK_OPERATOR' &&
            (empty_anonymous_function ||
            last_type === 'TK_EQUALS' ||
            (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
            output.space_before_token = true;
          } else {
            print_newline(false, true);
          }
        } else { // collapse || inline_frame
          if (is_array(previous_flags.mode) && (last_type === 'TK_START_EXPR' || last_type === 'TK_COMMA')) {
            if (last_type === 'TK_COMMA' || opt.space_in_paren) {
              output.space_before_token = true;
            }

            if (last_type === 'TK_COMMA' || (last_type === 'TK_START_EXPR' && flags.inline_frame)) {
              allow_wrap_or_preserved_newline();
              previous_flags.multiline_frame = previous_flags.multiline_frame || flags.multiline_frame;
              flags.multiline_frame = false;
            }
          }
          if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
            if (last_type === 'TK_START_BLOCK' && !flags.inline_frame) {
              print_newline();
            } else {
              output.space_before_token = true;
            }
          }
        }
        print_token();
        indent();
      }

      function handle_end_block() {
        // statements must all be closed when their container closes
        handle_whitespace_and_comments(current_token);

        while (flags.mode === MODE.Statement) {
          restore_mode();
        }

        var empty_braces = last_type === 'TK_START_BLOCK';

        if (flags.inline_frame && !empty_braces) { // try inline_frame (only set if opt.braces-preserve-inline) first
          output.space_before_token = true;
        } else if (opt.brace_style === "expand") {
          if (!empty_braces) {
            print_newline();
          }
        } else {
          // skip {}
          if (!empty_braces) {
            if (is_array(flags.mode) && opt.keep_array_indentation) {
              // we REALLY need a newline here, but newliner would skip that
              opt.keep_array_indentation = false;
              print_newline();
              opt.keep_array_indentation = true;

            } else {
              print_newline();
            }
          }
        }
        restore_mode();
        print_token();
      }

      function handle_word() {
        if (current_token.type === 'TK_RESERVED') {
          if (in_array(current_token.text, ['set', 'get']) && flags.mode !== MODE.ObjectLiteral) {
            current_token.type = 'TK_WORD';
          } else if (in_array(current_token.text, ['as', 'from']) && !flags.import_block) {
            current_token.type = 'TK_WORD';
          } else if (flags.mode === MODE.ObjectLiteral) {
            var next_token = get_token(1);
            if (next_token.text === ':') {
              current_token.type = 'TK_WORD';
            }
          }
        }

        if (start_of_statement()) {
          // The conditional starts the statement if appropriate.
          if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {
            flags.declaration_statement = true;
          }
        } else if (current_token.wanted_newline && !is_expression(flags.mode) &&
          (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
          last_type !== 'TK_EQUALS' &&
          (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {
          handle_whitespace_and_comments(current_token);
          print_newline();
        } else {
          handle_whitespace_and_comments(current_token);
        }

        if (flags.do_block && !flags.do_while) {
          if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {
            // do {} ## while ()
            output.space_before_token = true;
            print_token();
            output.space_before_token = true;
            flags.do_while = true;
            return;
          } else {
            // do {} should always have while as the next word.
            // if we don't see the expected while, recover
            print_newline();
            flags.do_block = false;
          }
        }

        // if may be followed by else, or not
        // Bare/inline ifs are tricky
        // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
        if (flags.if_block) {
          if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {
            flags.else_block = true;
          } else {
            while (flags.mode === MODE.Statement) {
              restore_mode();
            }
            flags.if_block = false;
            flags.else_block = false;
          }
        }

        if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {
          print_newline();
          if (flags.case_body || opt.jslint_happy) {
            // switch cases following one another
            deindent();
            flags.case_body = false;
          }
          print_token();
          flags.in_case = true;
          flags.in_case_statement = true;
          return;
        }

        if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
          if (!start_of_object_property()) {
            allow_wrap_or_preserved_newline();
          }
        }

        if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {
          if (in_array(flags.last_text, ['}', ';']) ||
            (output.just_added_newline() && !(in_array(flags.last_text, ['(', '[', '{', ':', '=', ',']) || last_type === 'TK_OPERATOR'))) {
            // make sure there is a nice clean space of at least one blank line
            // before a new function definition
            if (!output.just_added_blankline() && !current_token.comments_before.length) {
              print_newline();
              print_newline(true);
            }
          }
          if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export', 'async'])) {
              output.space_before_token = true;
            } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {
              output.space_before_token = true;
            } else {
              print_newline();
            }
          } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
            // foo = function
            output.space_before_token = true;
          } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {
            // (function
          } else {
            print_newline();
          }

          print_token();
          flags.last_word = current_token.text;
          return;
        }

        prefix = 'NONE';

        if (last_type === 'TK_END_BLOCK') {

          if (previous_flags.inline_frame) {
            prefix = 'SPACE';
          } else if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally', 'from']))) {
            prefix = 'NEWLINE';
          } else {
            if (opt.brace_style === "expand" ||
              opt.brace_style === "end-expand" ||
              (opt.brace_style === "none" && current_token.wanted_newline)) {
              prefix = 'NEWLINE';
            } else {
              prefix = 'SPACE';
              output.space_before_token = true;
            }
          }
        } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
          // TODO: Should this be for STATEMENT as well?
          prefix = 'NEWLINE';
        } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
          prefix = 'SPACE';
        } else if (last_type === 'TK_STRING') {
          prefix = 'NEWLINE';
        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
          (flags.last_text === '*' &&
          (in_array(last_last_text, ['function', 'yield']) ||
          (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
          prefix = 'SPACE';
        } else if (last_type === 'TK_START_BLOCK') {
          if (flags.inline_frame) {
            prefix = 'SPACE';
          } else {
            prefix = 'NEWLINE';
          }
        } else if (last_type === 'TK_END_EXPR') {
          output.space_before_token = true;
          prefix = 'NEWLINE';
        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {
          if (flags.inline_frame || flags.last_text === 'else' || flags.last_text === 'export') {
            prefix = 'SPACE';
          } else {
            prefix = 'NEWLINE';
          }

        }

        if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {
          if ((!(last_type === 'TK_END_BLOCK' && previous_flags.mode === MODE.BlockStatement) ||
            opt.brace_style === "expand" ||
            opt.brace_style === "end-expand" ||
            (opt.brace_style === "none" && current_token.wanted_newline)) &&
            !flags.inline_frame) {
            print_newline();
          } else {
            output.trim(true);
            var line = output.current_line;
            // If we trimmed and there's something other than a close block before us
            // put a newline back in.  Handles '} // comment' scenario.
            if (line.last() !== '}') {
              print_newline();
            }
            output.space_before_token = true;
          }
        } else if (prefix === 'NEWLINE') {
          if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
            // no newline between 'return nnn'
            output.space_before_token = true;
          } else if (last_type !== 'TK_END_EXPR') {
            if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
              // no need to force newline on 'var': for (var x = 0...)
              if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {
                // no newline for } else if {
                output.space_before_token = true;
              } else {
                print_newline();
              }
            }
          } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {
            print_newline();
          }
        } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
          print_newline(); // }, in lists get a newline treatment
        } else if (prefix === 'SPACE') {
          output.space_before_token = true;
        }
        print_token();
        flags.last_word = current_token.text;

        if (current_token.type === 'TK_RESERVED') {
          if (current_token.text === 'do') {
            flags.do_block = true;
          } else if (current_token.text === 'if') {
            flags.if_block = true;
          } else if (current_token.text === 'import') {
            flags.import_block = true;
          } else if (flags.import_block && current_token.type === 'TK_RESERVED' && current_token.text === 'from') {
            flags.import_block = false;
          }
        }
      }

      function handle_semicolon() {
        if (start_of_statement()) {
          // The conditional starts the statement if appropriate.
          // Semicolon can be the start (and end) of a statement
          output.space_before_token = false;
        } else {
          handle_whitespace_and_comments(current_token);
        }

        var next_token = get_token(1);
        while (flags.mode === MODE.Statement &&
        !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
        !flags.do_block) {
          restore_mode();
        }

        // hacky but effective for the moment
        if (flags.import_block) {
          flags.import_block = false;
        }
        print_token();
      }

      function handle_string() {
        if (start_of_statement()) {
          // The conditional starts the statement if appropriate.
          // One difference - strings want at least a space before
          output.space_before_token = true;
        } else {
          handle_whitespace_and_comments(current_token);
          if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' || flags.inline_frame) {
            output.space_before_token = true;
          } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
            if (!start_of_object_property()) {
              allow_wrap_or_preserved_newline();
            }
          } else {
            print_newline();
          }
        }
        print_token();
      }

      function handle_equals() {
        if (start_of_statement()) {
          // The conditional starts the statement if appropriate.
        } else {
          handle_whitespace_and_comments(current_token);
        }

        if (flags.declaration_statement) {
          // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
          flags.declaration_assignment = true;
        }
        output.space_before_token = true;
        print_token();
        output.space_before_token = true;
      }

      function handle_comma() {
        handle_whitespace_and_comments(current_token, true);

        print_token();
        output.space_before_token = true;
        if (flags.declaration_statement) {
          if (is_expression(flags.parent.mode)) {
            // do not break on comma, for(var a = 1, b = 2)
            flags.declaration_assignment = false;
          }

          if (flags.declaration_assignment) {
            flags.declaration_assignment = false;
            print_newline(false, true);
          } else if (opt.comma_first) {
            // for comma-first, we want to allow a newline before the comma
            // to turn into a newline after the comma, which we will fixup later
            allow_wrap_or_preserved_newline();
          }
        } else if (flags.mode === MODE.ObjectLiteral ||
          (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
          if (flags.mode === MODE.Statement) {
            restore_mode();
          }

          if (!flags.inline_frame) {
            print_newline();
          }
        } else if (opt.comma_first) {
          // EXPR or DO_BLOCK
          // for comma-first, we want to allow a newline before the comma
          // to turn into a newline after the comma, which we will fixup later
          allow_wrap_or_preserved_newline();
        }
      }

      function handle_operator() {
        var isGeneratorAsterisk = current_token.text === '*' &&
          ((last_type === 'TK_RESERVED' && in_array(flags.last_text, ['function', 'yield'])) ||
            (in_array(last_type, ['TK_START_BLOCK', 'TK_COMMA', 'TK_END_BLOCK', 'TK_SEMICOLON']))
          );
        var isUnary = in_array(current_token.text, ['-', '+']) && (
            in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) ||
            in_array(flags.last_text, Tokenizer.line_starters) ||
            flags.last_text === ','
          );

        if (start_of_statement()) {
          // The conditional starts the statement if appropriate.
        } else {
          var preserve_statement_flags = !isGeneratorAsterisk;
          handle_whitespace_and_comments(current_token, preserve_statement_flags);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
          // "return" had a special handling in TK_WORD. Now we need to return the favor
          output.space_before_token = true;
          print_token();
          return;
        }

        // hack for actionscript's import .*;
        if (current_token.text === '*' && last_type === 'TK_DOT') {
          print_token();
          return;
        }

        if (current_token.text === '::') {
          // no spaces around exotic namespacing syntax operator
          print_token();
          return;
        }

        // Allow line wrapping between operators when operator_position is
        //   set to before or preserve
        if (last_type === 'TK_OPERATOR' && in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
          allow_wrap_or_preserved_newline();
        }

        if (current_token.text === ':' && flags.in_case) {
          flags.case_body = true;
          indent();
          print_token();
          print_newline();
          flags.in_case = false;
          return;
        }

        var space_before = true;
        var space_after = true;
        var in_ternary = false;
        if (current_token.text === ':') {
          if (flags.ternary_depth === 0) {
            // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
            space_before = false;
          } else {
            flags.ternary_depth -= 1;
            in_ternary = true;
          }
        } else if (current_token.text === '?') {
          flags.ternary_depth += 1;
        }

        // let's handle the operator_position option prior to any conflicting logic
        if (!isUnary && !isGeneratorAsterisk && opt.preserve_newlines && in_array(current_token.text, Tokenizer.positionable_operators)) {
          var isColon = current_token.text === ':';
          var isTernaryColon = (isColon && in_ternary);
          var isOtherColon = (isColon && !in_ternary);

          switch (opt.operator_position) {
            case OPERATOR_POSITION.before_newline:
              // if the current token is : and it's not a ternary statement then we set space_before to false
              output.space_before_token = !isOtherColon;

              print_token();

              if (!isColon || isTernaryColon) {
                allow_wrap_or_preserved_newline();
              }

              output.space_before_token = true;
              return;

            case OPERATOR_POSITION.after_newline:
              // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
              //   then print a newline.

              output.space_before_token = true;

              if (!isColon || isTernaryColon) {
                if (get_token(1).wanted_newline) {
                  print_newline(false, true);
                } else {
                  allow_wrap_or_preserved_newline();
                }
              } else {
                output.space_before_token = false;
              }

              print_token();

              output.space_before_token = true;
              return;

            case OPERATOR_POSITION.preserve_newline:
              if (!isOtherColon) {
                allow_wrap_or_preserved_newline();
              }

              // if we just added a newline, or the current token is : and it's not a ternary statement,
              //   then we set space_before to false
              space_before = !(output.just_added_newline() || isOtherColon);

              output.space_before_token = space_before;
              print_token();
              output.space_before_token = true;
              return;
          }
        }

        if (isGeneratorAsterisk) {
          allow_wrap_or_preserved_newline();
          space_before = false;
          var next_token = get_token(1);
          space_after = next_token && in_array(next_token.type, ['TK_WORD', 'TK_RESERVED']);
        } else if (current_token.text === '...') {
          allow_wrap_or_preserved_newline();
          space_before = last_type === 'TK_START_BLOCK';
          space_after = false;
        } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
          // unary operators (and binary +/- pretending to be unary) special cases

          space_before = false;
          space_after = false;

          // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
          // if there is a newline between -- or ++ and anything else we should preserve it.
          if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {
            print_newline(false, true);
          }

          if (flags.last_text === ';' && is_expression(flags.mode)) {
            // for (;; ++i)
            //        ^^^
            space_before = true;
          }

          if (last_type === 'TK_RESERVED') {
            space_before = true;
          } else if (last_type === 'TK_END_EXPR') {
            space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++'));
          } else if (last_type === 'TK_OPERATOR') {
            // a++ + ++b;
            // a - -b
            space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']);
            // + and - are not unary when preceeded by -- or ++ operator
            // a-- + b
            // a * +b
            // a - -b
            if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {
              space_after = true;
            }
          }


          if (((flags.mode === MODE.BlockStatement && !flags.inline_frame) || flags.mode === MODE.Statement) &&
            (flags.last_text === '{' || flags.last_text === ';')) {
            // { foo; --i }
            // foo(); --bar;
            print_newline();
          }
        }

        output.space_before_token = output.space_before_token || space_before;
        print_token();
        output.space_before_token = space_after;
      }

      function handle_block_comment(preserve_statement_flags) {
        if (output.raw) {
          output.add_raw_token(current_token);
          if (current_token.directives && current_token.directives.preserve === 'end') {
            // If we're testing the raw output behavior, do not allow a directive to turn it off.
            output.raw = opt.test_output_raw;
          }
          return;
        }

        if (current_token.directives) {
          print_newline(false, preserve_statement_flags);
          print_token();
          if (current_token.directives.preserve === 'start') {
            output.raw = true;
          }
          print_newline(false, true);
          return;
        }

        // inline block
        if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {
          output.space_before_token = true;
          print_token();
          output.space_before_token = true;
          return;
        }

        var lines = split_linebreaks(current_token.text);
        var j; // iterator for this case
        var javadoc = false;
        var starless = false;
        var lastIndent = current_token.whitespace_before;
        var lastIndentLength = lastIndent.length;

        // block comment starts with a new line
        print_newline(false, preserve_statement_flags);
        if (lines.length > 1) {
          javadoc = all_lines_start_with(lines.slice(1), '*');
          starless = each_line_matches_indent(lines.slice(1), lastIndent);
        }

        // first line always indented
        print_token(lines[0]);
        for (j = 1; j < lines.length; j++) {
          print_newline(false, true);
          if (javadoc) {
            // javadoc: reformat and re-indent
            print_token(' ' + ltrim(lines[j]));
          } else if (starless && lines[j].length > lastIndentLength) {
            // starless: re-indent non-empty content, avoiding trim
            print_token(lines[j].substring(lastIndentLength));
          } else {
            // normal comments output raw
            output.add_token(lines[j]);
          }
        }

        // for comments of more than one line, make sure there's a new line after
        print_newline(false, preserve_statement_flags);
      }

      function handle_comment(preserve_statement_flags) {
        if (current_token.wanted_newline) {
          print_newline(false, preserve_statement_flags);
        } else {
          output.trim(true);
        }

        output.space_before_token = true;
        print_token();
        print_newline(false, preserve_statement_flags);
      }

      function handle_dot() {
        if (start_of_statement()) {
          // The conditional starts the statement if appropriate.
        } else {
          handle_whitespace_and_comments(current_token, true);
        }

        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
          output.space_before_token = true;
        } else {
          // allow preserved newlines before dots in general
          // force newlines on dots after close paren when break_chained - for bar().baz()
          allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
        }

        print_token();
      }

      function handle_unknown(preserve_statement_flags) {
        print_token();

        if (current_token.text[current_token.text.length - 1] === '\n') {
          print_newline(false, preserve_statement_flags);
        }
      }

      function handle_eof() {
        // Unwind any open statements
        while (flags.mode === MODE.Statement) {
          restore_mode();
        }
        handle_whitespace_and_comments(current_token);
      }
    }


    function OutputLine(parent) {
      var _character_count = 0;
      // use indent_count as a marker for lines that have preserved indentation
      var _indent_count = -1;

      var _items = [];
      var _empty = true;

      this.set_indent = function(level) {
        _character_count = parent.baseIndentLength + level * parent.indent_length;
        _indent_count = level;
      };

      this.get_character_count = function() {
        return _character_count;
      };

      this.is_empty = function() {
        return _empty;
      };

      this.last = function() {
        if (!this._empty) {
          return _items[_items.length - 1];
        } else {
          return null;
        }
      };

      this.push = function(input) {
        _items.push(input);
        _character_count += input.length;
        _empty = false;
      };

      this.pop = function() {
        var item = null;
        if (!_empty) {
          item = _items.pop();
          _character_count -= item.length;
          _empty = _items.length === 0;
        }
        return item;
      };

      this.remove_indent = function() {
        if (_indent_count > 0) {
          _indent_count -= 1;
          _character_count -= parent.indent_length;
        }
      };

      this.trim = function() {
        while (this.last() === ' ') {
          _items.pop();
          _character_count -= 1;
        }
        _empty = _items.length === 0;
      };

      this.toString = function() {
        var result = '';
        if (!this._empty) {
          if (_indent_count >= 0) {
            result = parent.indent_cache[_indent_count];
          }
          result += _items.join('');
        }
        return result;
      };
    }

    function Output(indent_string, baseIndentString) {
      baseIndentString = baseIndentString || '';
      this.indent_cache = [baseIndentString];
      this.baseIndentLength = baseIndentString.length;
      this.indent_length = indent_string.length;
      this.raw = false;

      var lines = [];
      this.baseIndentString = baseIndentString;
      this.indent_string = indent_string;
      this.previous_line = null;
      this.current_line = null;
      this.space_before_token = false;

      this.add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = new OutputLine(this);
        lines.push(this.current_line);
      };

      // initialize
      this.add_outputline();


      this.get_line_number = function() {
        return lines.length;
      };

      // Using object instead of string to allow for later expansion of info about each line
      this.add_new_line = function(force_newline) {
        if (this.get_line_number() === 1 && this.just_added_newline()) {
          return false; // no newline on start of file
        }

        if (force_newline || !this.just_added_newline()) {
          if (!this.raw) {
            this.add_outputline();
          }
          return true;
        }

        return false;
      };

      this.get_code = function() {
        var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');
        return sweet_code;
      };

      this.set_indent = function(level) {
        // Never indent your first output indent at the start of the file
        if (lines.length > 1) {
          while (level >= this.indent_cache.length) {
            this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
          }

          this.current_line.set_indent(level);
          return true;
        }
        this.current_line.set_indent(0);
        return false;
      };

      this.add_raw_token = function(token) {
        for (var x = 0; x < token.newlines; x++) {
          this.add_outputline();
        }
        this.current_line.push(token.whitespace_before);
        this.current_line.push(token.text);
        this.space_before_token = false;
      };

      this.add_token = function(printable_token) {
        this.add_space_before_token();
        this.current_line.push(printable_token);
      };

      this.add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
          this.current_line.push(' ');
        }
        this.space_before_token = false;
      };

      this.remove_redundant_indentation = function(frame) {
        // This implementation is effective but has some issues:
        //     - can cause line wrap to happen too soon due to indent removal
        //           after wrap points are calculated
        // These issues are minor compared to ugly indentation.

        if (frame.multiline_frame ||
          frame.mode === MODE.ForInitializer ||
          frame.mode === MODE.Conditional) {
          return;
        }

        // remove one indent from each line inside this section
        var index = frame.start_line_index;

        var output_length = lines.length;
        while (index < output_length) {
          lines[index].remove_indent();
          index++;
        }
      };

      this.trim = function(eat_newlines) {
        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

        this.current_line.trim(indent_string, baseIndentString);

        while (eat_newlines && lines.length > 1 &&
        this.current_line.is_empty()) {
          lines.pop();
          this.current_line = lines[lines.length - 1];
          this.current_line.trim();
        }

        this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
      };

      this.just_added_newline = function() {
        return this.current_line.is_empty();
      };

      this.just_added_blankline = function() {
        if (this.just_added_newline()) {
          if (lines.length === 1) {
            return true; // start of the file and newline = blank
          }

          var line = lines[lines.length - 2];
          return line.is_empty();
        }
        return false;
      };
    }

    var InputScanner = function(input) {
      var _input = input;
      var _input_length = _input.length;
      var _position = 0;

      this.back = function() {
        _position -= 1;
      };

      this.hasNext = function() {
        return _position < _input_length;
      };

      this.next = function() {
        var val = null;
        if (this.hasNext()) {
          val = _input.charAt(_position);
          _position += 1;
        }
        return val;
      };

      this.peek = function(index) {
        var val = null;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
          val = _input.charAt(index);
        }
        return val;
      };

      this.peekCharCode = function(index) {
        var val = 0;
        index = index || 0;
        index += _position;
        if (index >= 0 && index < _input_length) {
          val = _input.charCodeAt(index);
        }
        return val;
      };

      this.test = function(pattern, index) {
        index = index || 0;
        pattern.lastIndex = _position + index;
        return pattern.test(_input);
      };

      this.testChar = function(pattern, index) {
        var val = this.peek(index);
        return val !== null && pattern.test(val);
      };

      this.match = function(pattern) {
        pattern.lastIndex = _position;
        var pattern_match = pattern.exec(_input);
        if (pattern_match && pattern_match.index === _position) {
          _position += pattern_match[0].length;
        } else {
          pattern_match = null;
        }
        return pattern_match;
      };
    };

    var Token = function(type, text, newlines, whitespace_before, parent) {
      this.type = type;
      this.text = text;

      // comments_before are
      // comments that have a new line before them
      // and may or may not have a newline after
      // this is a set of comments before
      this.comments_before = /* inline comment*/ [];


      this.comments_after = []; // no new line before and newline after
      this.newlines = newlines || 0;
      this.wanted_newline = newlines > 0;
      this.whitespace_before = whitespace_before || '';
      this.parent = parent || null;
      this.opened = null;
      this.directives = null;
    };

    function tokenizer(input_string, opts) {

      var whitespace = "\n\r\t ".split('');
      var digit = /[0-9]/;
      var digit_bin = /[01]/;
      var digit_oct = /[01234567]/;
      var digit_hex = /[0123456789abcdefABCDEF]/;

      this.positionable_operators = '!= !== % & && * ** + - / : < << <= == === > >= >> >>> ? ^ | ||'.split(' ');
      var punct = this.positionable_operators.concat(
        // non-positionable operators - these do not follow operator position settings
        '! %= &= *= **= ++ += , -- -= /= :: <<= = => >>= >>>= ^= |= ~ ...'.split(' '));

      // words which should always start on new line.
      this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
      var reserved_words = this.line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);

      //  /* ... */ comment ends with nearest */ or end of file
      var block_comment_pattern = /([\s\S]*?)((?:\*\/)|$)/g;

      // comment ends just before nearest linefeed or end of file
      var comment_pattern = /([^\n\r\u2028\u2029]*)/g;

      var directives_block_pattern = /\/\* beautify( \w+[:]\w+)+ \*\//g;
      var directive_pattern = / (\w+)[:](\w+)/g;
      var directives_end_ignore_pattern = /([\s\S]*?)((?:\/\*\sbeautify\signore:end\s\*\/)|$)/g;

      var template_pattern = /((<\?php|<\?=)[\s\S]*?\?>)|(<%[\s\S]*?%>)/g;

      var n_newlines, whitespace_before_token, in_html_comment, tokens;
      var input;

      this.tokenize = function() {
        input = new InputScanner(input_string);
        in_html_comment = false;
        tokens = [];

        var next, last;
        var token_values;
        var open = null;
        var open_stack = [];
        var comments = [];

        while (!(last && last.type === 'TK_EOF')) {
          token_values = tokenize_next();
          next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
          while (next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {
            if (next.type === 'TK_BLOCK_COMMENT') {
              next.directives = token_values[2];
            }
            comments.push(next);
            token_values = tokenize_next();
            next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
          }

          if (comments.length) {
            next.comments_before = comments;
            comments = [];
          }

          if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {
            next.parent = last;
            open_stack.push(open);
            open = next;
          } else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&
            (open && (
            (next.text === ']' && open.text === '[') ||
            (next.text === ')' && open.text === '(') ||
            (next.text === '}' && open.text === '{')))) {
            next.parent = open.parent;
            next.opened = open;

            open = open_stack.pop();
          }

          tokens.push(next);
          last = next;
        }

        return tokens;
      };

      function get_directives(text) {
        if (!text.match(directives_block_pattern)) {
          return null;
        }

        var directives = {};
        directive_pattern.lastIndex = 0;
        var directive_match = directive_pattern.exec(text);

        while (directive_match) {
          directives[directive_match[1]] = directive_match[2];
          directive_match = directive_pattern.exec(text);
        }

        return directives;
      }

      function tokenize_next() {
        var resulting_string;
        var whitespace_on_this_line = [];

        n_newlines = 0;
        whitespace_before_token = '';

        var c = input.next();

        if (c === null) {
          return ['', 'TK_EOF'];
        }

        var last_token;
        if (tokens.length) {
          last_token = tokens[tokens.length - 1];
        } else {
          // For the sake of tokenizing we can pretend that there was on open brace to start
          last_token = new Token('TK_START_BLOCK', '{');
        }

        while (in_array(c, whitespace)) {

          if (acorn.newline.test(c)) {
            if (!(c === '\n' && input.peek(-2) === '\r')) {
              n_newlines += 1;
              whitespace_on_this_line = [];
            }
          } else {
            whitespace_on_this_line.push(c);
          }

          c = input.next();

          if (c === null) {
            return ['', 'TK_EOF'];
          }
        }

        if (whitespace_on_this_line.length) {
          whitespace_before_token = whitespace_on_this_line.join('');
        }

        if (digit.test(c) || (c === '.' && input.testChar(digit))) {
          var allow_decimal = true;
          var allow_e = true;
          var local_digit = digit;

          if (c === '0' && input.testChar(/[XxOoBb]/)) {
            // switch to hex/oct/bin number, no decimal or e, just hex/oct/bin digits
            allow_decimal = false;
            allow_e = false;
            if (input.testChar(/[Bb]/)) {
              local_digit = digit_bin;
            } else if (input.testChar(/[Oo]/)) {
              local_digit = digit_oct;
            } else {
              local_digit = digit_hex;
            }
            c += input.next();
          } else if (c === '.') {
            // Already have a decimal for this literal, don't allow another
            allow_decimal = false;
          } else {
            // we know this first loop will run.  It keeps the logic simpler.
            c = '';
            input.back();
          }

          // Add the digits
          while (input.testChar(local_digit)) {
            c += input.next();

            if (allow_decimal && input.peek() === '.') {
              c += input.next();
              allow_decimal = false;
            }

            // a = 1.e-7 is valid, so we test for . then e in one loop
            if (allow_e && input.testChar(/[Ee]/)) {
              c += input.next();

              if (input.testChar(/[+-]/)) {
                c += input.next();
              }

              allow_e = false;
              allow_decimal = false;
            }
          }

          return [c, 'TK_WORD'];
        }

        if (acorn.isIdentifierStart(input.peekCharCode(-1))) {
          if (input.hasNext()) {
            while (acorn.isIdentifierChar(input.peekCharCode())) {
              c += input.next();
              if (!input.hasNext()) {
                break;
              }
            }
          }

          if (!(last_token.type === 'TK_DOT' ||
            (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get']))) &&
            in_array(c, reserved_words)) {
            if (c === 'in' || c === 'of') { // hack for 'in' and 'of' operators
              return [c, 'TK_OPERATOR'];
            }
            return [c, 'TK_RESERVED'];
          }

          return [c, 'TK_WORD'];
        }

        if (c === '(' || c === '[') {
          return [c, 'TK_START_EXPR'];
        }

        if (c === ')' || c === ']') {
          return [c, 'TK_END_EXPR'];
        }

        if (c === '{') {
          return [c, 'TK_START_BLOCK'];
        }

        if (c === '}') {
          return [c, 'TK_END_BLOCK'];
        }

        if (c === ';') {
          return [c, 'TK_SEMICOLON'];
        }

        if (c === '/') {
          var comment = '';
          var comment_match;
          // peek for comment /* ... */
          if (input.peek() === '*') {
            input.next();
            comment_match = input.match(block_comment_pattern);
            comment = '/*' + comment_match[0];
            var directives = get_directives(comment);
            if (directives && directives.ignore === 'start') {
              comment_match = input.match(directives_end_ignore_pattern);
              comment += comment_match[0];
            }
            comment = comment.replace(acorn.allLineBreaks, '\n');
            return [comment, 'TK_BLOCK_COMMENT', directives];
          }
          // peek for comment // ...
          if (input.peek() === '/') {
            input.next();
            comment_match = input.match(comment_pattern);
            comment = '//' + comment_match[0];
            return [comment, 'TK_COMMENT'];
          }

        }

        var startXmlRegExp = /<()([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;

        if (c === '`' || c === "'" || c === '"' || // string
          (
            (c === '/') || // regexp
            (opts.e4x && c === "<" && input.test(startXmlRegExp, -1)) // xml
          ) && ( // regex and xml can only appear in specific locations during parsing
            (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
            (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&
            last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||
            (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
              'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
            ]))
          )) {

          var sep = c,
            esc = false,
            has_char_escapes = false;

          resulting_string = c;

          if (sep === '/') {
            //
            // handle regexp
            //
            var in_char_class = false;
            while (input.hasNext() &&
            ((esc || in_char_class || input.peek() !== sep) &&
            !input.testChar(acorn.newline))) {
              resulting_string += input.peek();
              if (!esc) {
                esc = input.peek() === '\\';
                if (input.peek() === '[') {
                  in_char_class = true;
                } else if (input.peek() === ']') {
                  in_char_class = false;
                }
              } else {
                esc = false;
              }
              input.next();
            }
          } else if (opts.e4x && sep === '<') {
            //
            // handle e4x xml literals
            //

            var xmlRegExp = /[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;
            input.back();
            var xmlStr = '';
            var match = input.match(startXmlRegExp);
            if (match) {
              // Trim root tag to attempt to
              var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
              var isCurlyRoot = rootTag.indexOf('{') === 0;
              var depth = 0;
              while (match) {
                var isEndTag = !!match[1];
                var tagName = match[2];
                var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
                if (!isSingletonTag &&
                  (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
                  if (isEndTag) {
                    --depth;
                  } else {
                    ++depth;
                  }
                }
                xmlStr += match[0];
                if (depth <= 0) {
                  break;
                }
                match = input.match(xmlRegExp);
              }
              // if we didn't close correctly, keep unformatted.
              if (!match) {
                xmlStr += input.match(/[\s\S]*/g)[0];
              }
              xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
              return [xmlStr, "TK_STRING"];
            }
          } else {
            //
            // handle string
            //
            var parse_string = function(delimiter, allow_unescaped_newlines, start_sub) {
              // Template strings can travers lines without escape characters.
              // Other strings cannot
              var current_char;
              while (input.hasNext()) {
                current_char = input.peek();
                if (!(esc || (current_char !== delimiter &&
                  (allow_unescaped_newlines || !acorn.newline.test(current_char))))) {
                  break;
                }

                // Handle \r\n linebreaks after escapes or in template strings
                if ((esc || allow_unescaped_newlines) && acorn.newline.test(current_char)) {
                  if (current_char === '\r' && input.peek(1) === '\n') {
                    input.next();
                    current_char = input.peek();
                  }
                  resulting_string += '\n';
                } else {
                  resulting_string += current_char;
                }

                if (esc) {
                  if (current_char === 'x' || current_char === 'u') {
                    has_char_escapes = true;
                  }
                  esc = false;
                } else {
                  esc = current_char === '\\';
                }

                input.next();

                if (start_sub && resulting_string.indexOf(start_sub, resulting_string.length - start_sub.length) !== -1) {
                  if (delimiter === '`') {
                    parse_string('}', allow_unescaped_newlines, '`');
                  } else {
                    parse_string('`', allow_unescaped_newlines, '${');
                  }

                  if (input.hasNext()) {
                    resulting_string += input.next();
                  }
                }
              }
            };

            if (sep === '`') {
              parse_string('`', true, '${');
            } else {
              parse_string(sep);
            }
          }

          if (has_char_escapes && opts.unescape_strings) {
            resulting_string = unescape_string(resulting_string);
          }

          if (input.peek() === sep) {
            resulting_string += sep;
            input.next();

            if (sep === '/') {
              // regexps may have modifiers /regexp/MOD , so fetch those, too
              // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
              while (input.hasNext() && acorn.isIdentifierStart(input.peekCharCode())) {
                resulting_string += input.next();
              }
            }
          }
          return [resulting_string, 'TK_STRING'];
        }

        if (c === '#') {

          if (tokens.length === 0 && input.peek() === '!') {
            // shebang
            resulting_string = c;
            while (input.hasNext() && c !== '\n') {
              c = input.next();
              resulting_string += c;
            }
            return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
          }



          // Spidermonkey-specific sharp variables for circular references
          // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
          // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
          var sharp = '#';
          if (input.hasNext() && input.testChar(digit)) {
            do {
              c = input.next();
              sharp += c;
            } while (input.hasNext() && c !== '#' && c !== '=');
            if (c === '#') {
              //
            } else if (input.peek() === '[' && input.peek(1) === ']') {
              sharp += '[]';
              input.next();
              input.next();
            } else if (input.peek() === '{' && input.peek(1) === '}') {
              sharp += '{}';
              input.next();
              input.next();
            }
            return [sharp, 'TK_WORD'];
          }
        }

        if (c === '<' && (input.peek() === '?' || input.peek() === '%')) {
          input.back();
          var template_match = input.match(template_pattern);
          if (template_match) {
            c = template_match[0];
            c = c.replace(acorn.allLineBreaks, '\n');
            return [c, 'TK_STRING'];
          }
        }

        if (c === '<' && input.match(/\!--/g)) {
          c = '<!--';
          while (input.hasNext() && !input.testChar(acorn.newline)) {
            c += input.next();
          }
          in_html_comment = true;
          return [c, 'TK_COMMENT'];
        }

        if (c === '-' && in_html_comment && input.match(/->/g)) {
          in_html_comment = false;
          return ['-->', 'TK_COMMENT'];
        }

        if (c === '.') {
          if (input.peek() === '.' && input.peek(1) === '.') {
            c += input.next() + input.next();
            return [c, 'TK_OPERATOR'];
          }
          return [c, 'TK_DOT'];
        }

        if (in_array(c, punct)) {
          while (input.hasNext() && in_array(c + input.peek(), punct)) {
            c += input.next();
            if (!input.hasNext()) {
              break;
            }
          }

          if (c === ',') {
            return [c, 'TK_COMMA'];
          } else if (c === '=') {
            return [c, 'TK_EQUALS'];
          } else {
            return [c, 'TK_OPERATOR'];
          }
        }

        return [c, 'TK_UNKNOWN'];
      }


      function unescape_string(s) {
        // You think that a regex would work for this
        // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
        //         return String.fromCharCode(parseInt(val, 16));
        //     })
        // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
        var out = '',
          escaped = 0;

        var input_scan = new InputScanner(s);
        var matched = null;

        while (input_scan.hasNext()) {
          // Keep any whitespace, non-slash characters
          // also keep slash pairs.
          matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

          if (matched) {
            out += matched[0];
          }

          if (input_scan.peek() === '\\') {
            input_scan.next();
            if (input_scan.peek() === 'x') {
              matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
            } else if (input_scan.peek() === 'u') {
              matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
            } else {
              out += '\\';
              if (input_scan.hasNext()) {
                out += input_scan.next();
              }
              continue;
            }

            // If there's some error decoding, return the original string
            if (!matched) {
              return s;
            }

            escaped = parseInt(matched[1], 16);

            if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
              // we bail out on \x7f..\xff,
              // leaving whole string escaped,
              // as it's probably completely binary
              return s;
            } else if (escaped >= 0x00 && escaped < 0x20) {
              // leave 0x00...0x1f escaped
              out += '\\' + matched[0];
              continue;
            } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
              // single-quote, apostrophe, backslash - escape these
              out += '\\' + String.fromCharCode(escaped);
            } else {
              out += String.fromCharCode(escaped);
            }
          }
        }

        return out;
      }
    }

    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();

  }

  if (typeof define === "function" && define.amd) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    define([], function() {
      return { js_beautify: js_beautify };
    });
  } else if (typeof exports !== "undefined") {
    // Add support for CommonJS. Just put this file somewhere on your require.paths
    // and you will be able to `var js_beautify = require("beautify").js_beautify`.
    exports.js_beautify = js_beautify;
  } else if (typeof window !== "undefined") {
    // If we're running a web page and don't have either of the above, add our one global
    window.js_beautify = js_beautify;
  } else if (typeof global !== "undefined") {
    // If we don't even have window, try global.
    global.js_beautify = js_beautify;
  }

}());
/**
 * Sinon.JS 1.17.2, 2015/10/21
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @author Contributors: https://github.com/cjohansen/Sinon.JS/blob/master/AUTHORS
 *
 * (The BSD License)
 *
 * Copyright (c) 2010-2014, Christian Johansen, christian@cjohansen.no
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice,
 *       this list of conditions and the following disclaimer in the documentation
 *       and/or other materials provided with the distribution.
 *     * Neither the name of Christian Johansen nor the names of his contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Sinon core utilities. For internal use only.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
var sinon = (function () {
  "use strict";
  // eslint-disable-line no-unused-vars

  var sinonModule;
  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  function loadDependencies(require, exports, module) {
    sinonModule = module.exports = require("./sinon/util/core");
    require("./sinon/extend");
    require("./sinon/walk");
    require("./sinon/typeOf");
    require("./sinon/times_in_words");
    require("./sinon/spy");
    require("./sinon/call");
    require("./sinon/behavior");
    require("./sinon/stub");
    require("./sinon/mock");
    require("./sinon/collection");
    require("./sinon/assert");
    require("./sinon/sandbox");
    require("./sinon/test");
    require("./sinon/test_case");
    require("./sinon/match");
    require("./sinon/format");
    require("./sinon/log_error");
  }

  if (isAMD) {
    define(loadDependencies);
  } else if (isNode) {
    loadDependencies(require, module.exports, module);
    sinonModule = module.exports;
  } else {
    sinonModule = {};
  }

  return sinonModule;
}());

/**
 * @depend ../../sinon.js
 */
/**
 * Sinon core utilities. For internal use only.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {

  var div = typeof document !== "undefined" && document.createElement("div");
  var hasOwn = Object.prototype.hasOwnProperty;

  function isDOMNode(obj) {
    var success = false;

    try {
      obj.appendChild(div);
      success = div.parentNode === obj;
    } catch (e) {
      return false;
    } finally {
      try {
        obj.removeChild(div);
      } catch (e) {
        // Remove failed, not much we can do about that
      }
    }

    return success;
  }

  function isElement(obj) {
    return div && obj && obj.nodeType === 1 && isDOMNode(obj);
  }

  function isFunction(obj) {
    return typeof obj === "function" || !!(obj && obj.constructor && obj.call && obj.apply);
  }

  function isReallyNaN(val) {
    return typeof val === "number" && isNaN(val);
  }

  function mirrorProperties(target, source) {
    for (var prop in source) {
      if (!hasOwn.call(target, prop)) {
        target[prop] = source[prop];
      }
    }
  }

  function isRestorable(obj) {
    return typeof obj === "function" && typeof obj.restore === "function" && obj.restore.sinon;
  }

  // Cheap way to detect if we have ES5 support.
  var hasES5Support = "keys" in Object;

  function makeApi(sinon) {
    sinon.wrapMethod = function wrapMethod(object, property, method) {
      if (!object) {
        throw new TypeError("Should wrap property of object");
      }

      if (typeof method !== "function" && typeof method !== "object") {
        throw new TypeError("Method wrapper should be a function or a property descriptor");
      }

      function checkWrappedMethod(wrappedMethod) {
        var error;

        if (!isFunction(wrappedMethod)) {
          error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +
            property + " as function");
        } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {
          error = new TypeError("Attempted to wrap " + property + " which is already wrapped");
        } else if (wrappedMethod.calledBefore) {
          var verb = wrappedMethod.returns ? "stubbed" : "spied on";
          error = new TypeError("Attempted to wrap " + property + " which is already " + verb);
        }

        if (error) {
          if (wrappedMethod && wrappedMethod.stackTrace) {
            error.stack += "\n--------------\n" + wrappedMethod.stackTrace;
          }
          throw error;
        }
      }

      var error, wrappedMethod, i;

      // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem
      // when using hasOwn.call on objects from other frames.
      var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);

      if (hasES5Support) {
        var methodDesc = (typeof method === "function") ? {value: method} : method;
        var wrappedMethodDesc = sinon.getPropertyDescriptor(object, property);

        if (!wrappedMethodDesc) {
          error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +
            property + " as function");
        } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {
          error = new TypeError("Attempted to wrap " + property + " which is already wrapped");
        }
        if (error) {
          if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {
            error.stack += "\n--------------\n" + wrappedMethodDesc.stackTrace;
          }
          throw error;
        }

        var types = sinon.objectKeys(methodDesc);
        for (i = 0; i < types.length; i++) {
          wrappedMethod = wrappedMethodDesc[types[i]];
          checkWrappedMethod(wrappedMethod);
        }

        mirrorProperties(methodDesc, wrappedMethodDesc);
        for (i = 0; i < types.length; i++) {
          mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);
        }
        Object.defineProperty(object, property, methodDesc);
      } else {
        wrappedMethod = object[property];
        checkWrappedMethod(wrappedMethod);
        object[property] = method;
        method.displayName = property;
      }

      method.displayName = property;

      // Set up a stack trace which can be used later to find what line of
      // code the original method was created on.
      method.stackTrace = (new Error("Stack Trace for original")).stack;

      method.restore = function () {
        // For prototype properties try to reset by delete first.
        // If this fails (ex: localStorage on mobile safari) then force a reset
        // via direct assignment.
        if (!owned) {
          // In some cases `delete` may throw an error
          try {
            delete object[property];
          } catch (e) {
          } // eslint-disable-line no-empty
          // For native code functions `delete` fails without throwing an error
          // on Chrome < 43, PhantomJS, etc.
        } else if (hasES5Support) {
          Object.defineProperty(object, property, wrappedMethodDesc);
        }

        // Use strict equality comparison to check failures then force a reset
        // via direct assignment.
        if (object[property] === method) {
          object[property] = wrappedMethod;
        }
      };

      method.restore.sinon = true;

      if (!hasES5Support) {
        mirrorProperties(method, wrappedMethod);
      }

      return method;
    };

    sinon.create = function create(proto) {
      var F = function () {
      };
      F.prototype = proto;
      return new F();
    };

    sinon.deepEqual = function deepEqual(a, b) {
      if (sinon.match && sinon.match.isMatcher(a)) {
        return a.test(b);
      }

      if (typeof a !== "object" || typeof b !== "object") {
        return isReallyNaN(a) && isReallyNaN(b) || a === b;
      }

      if (isElement(a) || isElement(b)) {
        return a === b;
      }

      if (a === b) {
        return true;
      }

      if ((a === null && b !== null) || (a !== null && b === null)) {
        return false;
      }

      if (a instanceof RegExp && b instanceof RegExp) {
        return (a.source === b.source) && (a.global === b.global) &&
          (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);
      }

      var aString = Object.prototype.toString.call(a);
      if (aString !== Object.prototype.toString.call(b)) {
        return false;
      }

      if (aString === "[object Date]") {
        return a.valueOf() === b.valueOf();
      }

      var prop;
      var aLength = 0;
      var bLength = 0;

      if (aString === "[object Array]" && a.length !== b.length) {
        return false;
      }

      for (prop in a) {
        if (a.hasOwnProperty(prop)) {
          aLength += 1;

          if (!(prop in b)) {
            return false;
          }

          if (!deepEqual(a[prop], b[prop])) {
            return false;
          }
        }
      }

      for (prop in b) {
        if (b.hasOwnProperty(prop)) {
          bLength += 1;
        }
      }

      return aLength === bLength;
    };

    sinon.functionName = function functionName(func) {
      var name = func.displayName || func.name;

      // Use function decomposition as a last resort to get function
      // name. Does not rely on function decomposition to work - if it
      // doesn't debugging will be slightly less informative
      // (i.e. toString will say 'spy' rather than 'myFunc').
      if (!name) {
        var matches = func.toString().match(/function ([^\s\(]+)/);
        name = matches && matches[1];
      }

      return name;
    };

    sinon.functionToString = function toString() {
      if (this.getCall && this.callCount) {
        var thisValue,
          prop;
        var i = this.callCount;

        while (i--) {
          thisValue = this.getCall(i).thisValue;

          for (prop in thisValue) {
            if (thisValue[prop] === this) {
              return prop;
            }
          }
        }
      }

      return this.displayName || "sinon fake";
    };

    sinon.objectKeys = function objectKeys(obj) {
      if (obj !== Object(obj)) {
        throw new TypeError("sinon.objectKeys called on a non-object");
      }

      var keys = [];
      var key;
      for (key in obj) {
        if (hasOwn.call(obj, key)) {
          keys.push(key);
        }
      }

      return keys;
    };

    sinon.getPropertyDescriptor = function getPropertyDescriptor(object, property) {
      var proto = object;
      var descriptor;

      while (proto && !(descriptor = Object.getOwnPropertyDescriptor(proto, property))) {
        proto = Object.getPrototypeOf(proto);
      }
      return descriptor;
    };

    sinon.getConfig = function (custom) {
      var config = {};
      custom = custom || {};
      var defaults = sinon.defaultConfig;

      for (var prop in defaults) {
        if (defaults.hasOwnProperty(prop)) {
          config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];
        }
      }

      return config;
    };

    sinon.defaultConfig = {
      injectIntoThis: true,
      injectInto: null,
      properties: ["spy", "stub", "mock", "clock", "server", "requests"],
      useFakeTimers: true,
      useFakeServer: true
    };

    sinon.timesInWords = function timesInWords(count) {
      return count === 1 && "once" ||
        count === 2 && "twice" ||
        count === 3 && "thrice" ||
        (count || 0) + " times";
    };

    sinon.calledInOrder = function (spies) {
      for (var i = 1, l = spies.length; i < l; i++) {
        if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {
          return false;
        }
      }

      return true;
    };

    sinon.orderByFirstCall = function (spies) {
      return spies.sort(function (a, b) {
        // uuid, won't ever be equal
        var aCall = a.getCall(0);
        var bCall = b.getCall(0);
        var aId = aCall && aCall.callId || -1;
        var bId = bCall && bCall.callId || -1;

        return aId < bId ? -1 : 1;
      });
    };

    sinon.createStubInstance = function (constructor) {
      if (typeof constructor !== "function") {
        throw new TypeError("The constructor should be a function.");
      }
      return sinon.stub(sinon.create(constructor.prototype));
    };

    sinon.restore = function (object) {
      if (object !== null && typeof object === "object") {
        for (var prop in object) {
          if (isRestorable(object[prop])) {
            object[prop].restore();
          }
        }
      } else if (isRestorable(object)) {
        object.restore();
      }
    };

    return sinon;
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  function loadDependencies(require, exports) {
    makeApi(exports);
  }

  if (isAMD) {
    define(loadDependencies);
    return;
  }

  if (isNode) {
    loadDependencies(require, module.exports, module);
    return;
  }

  if (sinonGlobal) {
    makeApi(sinonGlobal);
  }
}(
  typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

/**
 * @depend util/core.js
 */
(function (sinonGlobal) {

  function makeApi(sinon) {

    // Adapted from https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
    var hasDontEnumBug = (function () {
      var obj = {
        constructor: function () {
          return "0";
        },
        toString: function () {
          return "1";
        },
        valueOf: function () {
          return "2";
        },
        toLocaleString: function () {
          return "3";
        },
        prototype: function () {
          return "4";
        },
        isPrototypeOf: function () {
          return "5";
        },
        propertyIsEnumerable: function () {
          return "6";
        },
        hasOwnProperty: function () {
          return "7";
        },
        length: function () {
          return "8";
        },
        unique: function () {
          return "9";
        }
      };

      var result = [];
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          result.push(obj[prop]());
        }
      }
      return result.join("") !== "0123456789";
    })();

    /* Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will
     *         override properties in previous sources.
     *
     * target - The Object to extend
     * sources - Objects to copy properties from.
     *
     * Returns the extended target
     */
    function extend(target /*, sources */) {
      var sources = Array.prototype.slice.call(arguments, 1);
      var source, i, prop;

      for (i = 0; i < sources.length; i++) {
        source = sources[i];

        for (prop in source) {
          if (source.hasOwnProperty(prop)) {
            target[prop] = source[prop];
          }
        }

        // Make sure we copy (own) toString method even when in JScript with DontEnum bug
        // See https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
        if (hasDontEnumBug && source.hasOwnProperty("toString") && source.toString !== target.toString) {
          target.toString = source.toString;
        }
      }

      return target;
    }

    sinon.extend = extend;
    return sinon.extend;
  }

  function loadDependencies(require, exports, module) {
    var sinon = require("./util/core");
    module.exports = makeApi(sinon);
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  if (isAMD) {
    define(loadDependencies);
    return;
  }

  if (isNode) {
    loadDependencies(require, module.exports, module);
    return;
  }

  if (sinonGlobal) {
    makeApi(sinonGlobal);
  }
}(
  typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

/**
 * Minimal Event interface implementation
 *
 * Original implementation by Sven Fuchs: https://gist.github.com/995028
 * Modifications and tests by Christian Johansen.
 *
 * @author Sven Fuchs (svenfuchs@artweb-design.de)
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2011 Sven Fuchs, Christian Johansen
 */
if (typeof sinon === "undefined") {
  this.sinon = {};
}

(function () {

  var push = [].push;

  function makeApi(sinon) {
    sinon.Event = function Event(type, bubbles, cancelable, target) {
      this.initEvent(type, bubbles, cancelable, target);
    };

    sinon.Event.prototype = {
      initEvent: function (type, bubbles, cancelable, target) {
        this.type = type;
        this.bubbles = bubbles;
        this.cancelable = cancelable;
        this.target = target;
      },

      stopPropagation: function () {
      },

      preventDefault: function () {
        this.defaultPrevented = true;
      }
    };

    sinon.ProgressEvent = function ProgressEvent(type, progressEventRaw, target) {
      this.initEvent(type, false, false, target);
      this.loaded = progressEventRaw.loaded || null;
      this.total = progressEventRaw.total || null;
      this.lengthComputable = !!progressEventRaw.total;
    };

    sinon.ProgressEvent.prototype = new sinon.Event();

    sinon.ProgressEvent.prototype.constructor = sinon.ProgressEvent;

    sinon.CustomEvent = function CustomEvent(type, customData, target) {
      this.initEvent(type, false, false, target);
      this.detail = customData.detail || null;
    };

    sinon.CustomEvent.prototype = new sinon.Event();

    sinon.CustomEvent.prototype.constructor = sinon.CustomEvent;

    sinon.EventTarget = {
      addEventListener: function addEventListener(event, listener) {
        this.eventListeners = this.eventListeners || {};
        this.eventListeners[event] = this.eventListeners[event] || [];
        push.call(this.eventListeners[event], listener);
      },

      removeEventListener: function removeEventListener(event, listener) {
        var listeners = this.eventListeners && this.eventListeners[event] || [];

        for (var i = 0, l = listeners.length; i < l; ++i) {
          if (listeners[i] === listener) {
            return listeners.splice(i, 1);
          }
        }
      },

      dispatchEvent: function dispatchEvent(event) {
        var type = event.type;
        var listeners = this.eventListeners && this.eventListeners[type] || [];

        for (var i = 0; i < listeners.length; i++) {
          if (typeof listeners[i] === "function") {
            listeners[i].call(this, event);
          } else {
            listeners[i].handleEvent(event);
          }
        }

        return !!event.defaultPrevented;
      }
    };
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  function loadDependencies(require) {
    var sinon = require("./core");
    makeApi(sinon);
  }

  if (isAMD) {
    define(loadDependencies);
  } else if (isNode) {
    loadDependencies(require);
  } else {
    makeApi(sinon); // eslint-disable-line no-undef
  }
}());

/**
 * @depend util/core.js
 */
/**
 * Logs errors
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */
(function (sinonGlobal) {

  // cache a reference to setTimeout, so that our reference won't be stubbed out
  // when using fake timers and errors will still get logged
  // https://github.com/cjohansen/Sinon.JS/issues/381
  var realSetTimeout = setTimeout;

  function makeApi(sinon) {

    function log() {
    }

    function logError(label, err) {
      var msg = label + " threw exception: ";

      function throwLoggedError() {
        err.message = msg + err.message;
        throw err;
      }

      sinon.log(msg + "[" + err.name + "] " + err.message);

      if (err.stack) {
        sinon.log(err.stack);
      }

      if (logError.useImmediateExceptions) {
        throwLoggedError();
      } else {
        logError.setTimeout(throwLoggedError, 0);
      }
    }

    // When set to true, any errors logged will be thrown immediately;
    // If set to false, the errors will be thrown in separate execution frame.
    logError.useImmediateExceptions = false;

    // wrap realSetTimeout with something we can stub in tests
    logError.setTimeout = function (func, timeout) {
      realSetTimeout(func, timeout);
    };

    var exports = {};
    exports.log = sinon.log = log;
    exports.logError = sinon.logError = logError;

    return exports;
  }

  function loadDependencies(require, exports, module) {
    var sinon = require("./util/core");
    module.exports = makeApi(sinon);
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  if (isAMD) {
    define(loadDependencies);
    return;
  }

  if (isNode) {
    loadDependencies(require, module.exports, module);
    return;
  }

  if (sinonGlobal) {
    makeApi(sinonGlobal);
  }
}(
  typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

/**
 * @depend core.js
 * @depend ../extend.js
 * @depend event.js
 * @depend ../log_error.js
 */
/**
 * Fake XDomainRequest object
 */
if (typeof sinon === "undefined") {
  this.sinon = {};
}

// wrapper for global
(function (global) {

  var xdr = {XDomainRequest: global.XDomainRequest};
  xdr.GlobalXDomainRequest = global.XDomainRequest;
  xdr.supportsXDR = typeof xdr.GlobalXDomainRequest !== "undefined";
  xdr.workingXDR = xdr.supportsXDR ? xdr.GlobalXDomainRequest : false;

  function makeApi(sinon) {
    sinon.xdr = xdr;

    function FakeXDomainRequest() {
      this.readyState = FakeXDomainRequest.UNSENT;
      this.requestBody = null;
      this.requestHeaders = {};
      this.status = 0;
      this.timeout = null;

      if (typeof FakeXDomainRequest.onCreate === "function") {
        FakeXDomainRequest.onCreate(this);
      }
    }

    function verifyState(x) {
      if (x.readyState !== FakeXDomainRequest.OPENED) {
        throw new Error("INVALID_STATE_ERR");
      }

      if (x.sendFlag) {
        throw new Error("INVALID_STATE_ERR");
      }
    }

    function verifyRequestSent(x) {
      if (x.readyState === FakeXDomainRequest.UNSENT) {
        throw new Error("Request not sent");
      }
      if (x.readyState === FakeXDomainRequest.DONE) {
        throw new Error("Request done");
      }
    }

    function verifyResponseBodyType(body) {
      if (typeof body !== "string") {
        var error = new Error("Attempted to respond to fake XDomainRequest with " +
          body + ", which is not a string.");
        error.name = "InvalidBodyException";
        throw error;
      }
    }

    sinon.extend(FakeXDomainRequest.prototype, sinon.EventTarget, {
      open: function open(method, url) {
        this.method = method;
        this.url = url;

        this.responseText = null;
        this.sendFlag = false;

        this.readyStateChange(FakeXDomainRequest.OPENED);
      },

      readyStateChange: function readyStateChange(state) {
        this.readyState = state;
        var eventName = "";
        switch (this.readyState) {
          case FakeXDomainRequest.UNSENT:
            break;
          case FakeXDomainRequest.OPENED:
            break;
          case FakeXDomainRequest.LOADING:
            if (this.sendFlag) {
              //raise the progress event
              eventName = "onprogress";
            }
            break;
          case FakeXDomainRequest.DONE:
            if (this.isTimeout) {
              eventName = "ontimeout";
            } else if (this.errorFlag || (this.status < 200 || this.status > 299)) {
              eventName = "onerror";
            } else {
              eventName = "onload";
            }
            break;
        }

        // raising event (if defined)
        if (eventName) {
          if (typeof this[eventName] === "function") {
            try {
              this[eventName]();
            } catch (e) {
              sinon.logError("Fake XHR " + eventName + " handler", e);
            }
          }
        }
      },

      send: function send(data) {
        verifyState(this);

        if (!/^(get|head)$/i.test(this.method)) {
          this.requestBody = data;
        }
        this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";

        this.errorFlag = false;
        this.sendFlag = true;
        this.readyStateChange(FakeXDomainRequest.OPENED);

        if (typeof this.onSend === "function") {
          this.onSend(this);
        }
      },

      abort: function abort() {
        this.aborted = true;
        this.responseText = null;
        this.errorFlag = true;

        if (this.readyState > sinon.FakeXDomainRequest.UNSENT && this.sendFlag) {
          this.readyStateChange(sinon.FakeXDomainRequest.DONE);
          this.sendFlag = false;
        }
      },

      setResponseBody: function setResponseBody(body) {
        verifyRequestSent(this);
        verifyResponseBodyType(body);

        var chunkSize = this.chunkSize || 10;
        var index = 0;
        this.responseText = "";

        do {
          this.readyStateChange(FakeXDomainRequest.LOADING);
          this.responseText += body.substring(index, index + chunkSize);
          index += chunkSize;
        } while (index < body.length);

        this.readyStateChange(FakeXDomainRequest.DONE);
      },

      respond: function respond(status, contentType, body) {
        // content-type ignored, since XDomainRequest does not carry this
        // we keep the same syntax for respond(...) as for FakeXMLHttpRequest to ease
        // test integration across browsers
        this.status = typeof status === "number" ? status : 200;
        this.setResponseBody(body || "");
      },

      simulatetimeout: function simulatetimeout() {
        this.status = 0;
        this.isTimeout = true;
        // Access to this should actually throw an error
        this.responseText = undefined;
        this.readyStateChange(FakeXDomainRequest.DONE);
      }
    });

    sinon.extend(FakeXDomainRequest, {
      UNSENT: 0,
      OPENED: 1,
      LOADING: 3,
      DONE: 4
    });

    sinon.useFakeXDomainRequest = function useFakeXDomainRequest() {
      sinon.FakeXDomainRequest.restore = function restore(keepOnCreate) {
        if (xdr.supportsXDR) {
          global.XDomainRequest = xdr.GlobalXDomainRequest;
        }

        delete sinon.FakeXDomainRequest.restore;

        if (keepOnCreate !== true) {
          delete sinon.FakeXDomainRequest.onCreate;
        }
      };
      if (xdr.supportsXDR) {
        global.XDomainRequest = sinon.FakeXDomainRequest;
      }
      return sinon.FakeXDomainRequest;
    };

    sinon.FakeXDomainRequest = FakeXDomainRequest;
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  function loadDependencies(require, exports, module) {
    var sinon = require("./core");
    require("../extend");
    require("./event");
    require("../log_error");
    makeApi(sinon);
    module.exports = sinon;
  }

  if (isAMD) {
    define(loadDependencies);
  } else if (isNode) {
    loadDependencies(require, module.exports, module);
  } else {
    makeApi(sinon); // eslint-disable-line no-undef
  }
})(typeof global !== "undefined" ? global : self);

/**
 * @depend core.js
 * @depend ../extend.js
 * @depend event.js
 * @depend ../log_error.js
 */
/**
 * Fake XMLHttpRequest object
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal, global) {

  function getWorkingXHR(globalScope) {
    var supportsXHR = typeof globalScope.XMLHttpRequest !== "undefined";
    if (supportsXHR) {
      return globalScope.XMLHttpRequest;
    }

    var supportsActiveX = typeof globalScope.ActiveXObject !== "undefined";
    if (supportsActiveX) {
      return function () {
        return new globalScope.ActiveXObject("MSXML2.XMLHTTP.3.0");
      };
    }

    return false;
  }

  var supportsProgress = typeof ProgressEvent !== "undefined";
  var supportsCustomEvent = typeof CustomEvent !== "undefined";
  var supportsFormData = typeof FormData !== "undefined";
  var supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
  var supportsBlob = typeof Blob === "function";
  var sinonXhr = {XMLHttpRequest: global.XMLHttpRequest};
  sinonXhr.GlobalXMLHttpRequest = global.XMLHttpRequest;
  sinonXhr.GlobalActiveXObject = global.ActiveXObject;
  sinonXhr.supportsActiveX = typeof sinonXhr.GlobalActiveXObject !== "undefined";
  sinonXhr.supportsXHR = typeof sinonXhr.GlobalXMLHttpRequest !== "undefined";
  sinonXhr.workingXHR = getWorkingXHR(global);
  sinonXhr.supportsCORS = sinonXhr.supportsXHR && "withCredentials" in (new sinonXhr.GlobalXMLHttpRequest());

  var unsafeHeaders = {
    "Accept-Charset": true,
    "Accept-Encoding": true,
    Connection: true,
    "Content-Length": true,
    Cookie: true,
    Cookie2: true,
    "Content-Transfer-Encoding": true,
    Date: true,
    Expect: true,
    Host: true,
    "Keep-Alive": true,
    Referer: true,
    TE: true,
    Trailer: true,
    "Transfer-Encoding": true,
    Upgrade: true,
    "User-Agent": true,
    Via: true
  };

  // An upload object is created for each
  // FakeXMLHttpRequest and allows upload
  // events to be simulated using uploadProgress
  // and uploadError.
  function UploadProgress() {
    this.eventListeners = {
      progress: [],
      load: [],
      abort: [],
      error: []
    };
  }

  UploadProgress.prototype.addEventListener = function addEventListener(event, listener) {
    this.eventListeners[event].push(listener);
  };

  UploadProgress.prototype.removeEventListener = function removeEventListener(event, listener) {
    var listeners = this.eventListeners[event] || [];

    for (var i = 0, l = listeners.length; i < l; ++i) {
      if (listeners[i] === listener) {
        return listeners.splice(i, 1);
      }
    }
  };

  UploadProgress.prototype.dispatchEvent = function dispatchEvent(event) {
    var listeners = this.eventListeners[event.type] || [];

    for (var i = 0, listener; (listener = listeners[i]) != null; i++) {
      listener(event);
    }
  };

  // Note that for FakeXMLHttpRequest to work pre ES5
  // we lose some of the alignment with the spec.
  // To ensure as close a match as possible,
  // set responseType before calling open, send or respond;
  function FakeXMLHttpRequest() {
    this.readyState = FakeXMLHttpRequest.UNSENT;
    this.requestHeaders = {};
    this.requestBody = null;
    this.status = 0;
    this.statusText = "";
    this.upload = new UploadProgress();
    this.responseType = "";
    this.response = "";
    if (sinonXhr.supportsCORS) {
      this.withCredentials = false;
    }

    var xhr = this;
    var events = ["loadstart", "load", "abort", "loadend"];

    function addEventListener(eventName) {
      xhr.addEventListener(eventName, function (event) {
        var listener = xhr["on" + eventName];

        if (listener && typeof listener === "function") {
          listener.call(this, event);
        }
      });
    }

    for (var i = events.length - 1; i >= 0; i--) {
      addEventListener(events[i]);
    }

    if (typeof FakeXMLHttpRequest.onCreate === "function") {
      FakeXMLHttpRequest.onCreate(this);
    }
  }

  function verifyState(xhr) {
    if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {
      throw new Error("INVALID_STATE_ERR");
    }

    if (xhr.sendFlag) {
      throw new Error("INVALID_STATE_ERR");
    }
  }

  function getHeader(headers, header) {
    header = header.toLowerCase();

    for (var h in headers) {
      if (h.toLowerCase() === header) {
        return h;
      }
    }

    return null;
  }

  // filtering to enable a white-list version of Sinon FakeXhr,
  // where whitelisted requests are passed through to real XHR
  function each(collection, callback) {
    if (!collection) {
      return;
    }

    for (var i = 0, l = collection.length; i < l; i += 1) {
      callback(collection[i]);
    }
  }

  function some(collection, callback) {
    for (var index = 0; index < collection.length; index++) {
      if (callback(collection[index]) === true) {
        return true;
      }
    }
    return false;
  }

  // largest arity in XHR is 5 - XHR#open
  var apply = function (obj, method, args) {
    switch (args.length) {
      case 0:
        return obj[method]();
      case 1:
        return obj[method](args[0]);
      case 2:
        return obj[method](args[0], args[1]);
      case 3:
        return obj[method](args[0], args[1], args[2]);
      case 4:
        return obj[method](args[0], args[1], args[2], args[3]);
      case 5:
        return obj[method](args[0], args[1], args[2], args[3], args[4]);
    }
  };

  FakeXMLHttpRequest.filters = [];
  FakeXMLHttpRequest.addFilter = function addFilter(fn) {
    this.filters.push(fn);
  };
  var IE6Re = /MSIE 6/;
  FakeXMLHttpRequest.onResponseEnd = function () {
  };
  FakeXMLHttpRequest.defake = function defake(fakeXhr, xhrArgs) {
    var xhr = new sinonXhr.workingXHR(); // eslint-disable-line new-cap

    each([
      "open",
      "setRequestHeader",
      "send",
      "abort",
      "getResponseHeader",
      "getAllResponseHeaders",
      "addEventListener",
      "overrideMimeType",
      "removeEventListener"
    ], function (method) {
      fakeXhr[method] = function () {
        return apply(xhr, method, arguments);
      };
    });

    var copyAttrs = function (args) {
      each(args, function (attr) {
        try {
          fakeXhr[attr] = xhr[attr];
        } catch (e) {
          if (!IE6Re.test(navigator.userAgent)) {
            throw e;
          }
        }
      });
    };

    var stateChange = function stateChange() {
      fakeXhr.readyState = xhr.readyState;
      if (xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {
        copyAttrs(["status", "statusText"]);
      }
      if (xhr.readyState >= FakeXMLHttpRequest.LOADING) {
        copyAttrs(["responseText", "response"]);
      }
      if (xhr.readyState === FakeXMLHttpRequest.DONE) {
        copyAttrs(["responseXML"]);
        FakeXMLHttpRequest.onResponseEnd(fakeXhr);
      }
      if (fakeXhr.onreadystatechange) {
        fakeXhr.onreadystatechange.call(fakeXhr, {target: fakeXhr});
      }
    };

    if (xhr.addEventListener) {
      for (var event in fakeXhr.eventListeners) {
        if (fakeXhr.eventListeners.hasOwnProperty(event)) {

          /*eslint-disable no-loop-func*/
          each(fakeXhr.eventListeners[event], function (handler) {
            xhr.addEventListener(event, handler);
          });
          /*eslint-enable no-loop-func*/
        }
      }
      xhr.addEventListener("readystatechange", stateChange);
    } else {
      xhr.onreadystatechange = stateChange;
    }
    apply(xhr, "open", xhrArgs);
  };
  FakeXMLHttpRequest.useFilters = false;

  function verifyRequestOpened(xhr) {
    if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {
      throw new Error("INVALID_STATE_ERR - " + xhr.readyState);
    }
  }

  function verifyRequestSent(xhr) {
    if (xhr.readyState === FakeXMLHttpRequest.DONE) {
      throw new Error("Request done");
    }
  }

  function verifyHeadersReceived(xhr) {
    if (xhr.async && xhr.readyState !== FakeXMLHttpRequest.HEADERS_RECEIVED) {
      throw new Error("No headers received");
    }
  }

  function verifyResponseBodyType(body) {
    if (typeof body !== "string") {
      var error = new Error("Attempted to respond to fake XMLHttpRequest with " +
        body + ", which is not a string.");
      error.name = "InvalidBodyException";
      throw error;
    }
  }

  function convertToArrayBuffer(body) {
    var buffer = new ArrayBuffer(body.length);
    var view = new Uint8Array(buffer);
    for (var i = 0; i < body.length; i++) {
      var charCode = body.charCodeAt(i);
      if (charCode >= 256) {
        throw new TypeError("arraybuffer or blob responseTypes require binary string, " +
          "invalid character " + body[i] + " found.");
      }
      view[i] = charCode;
    }
    return buffer;
  }

  function isXmlContentType(contentType) {
    return !contentType || /(text\/xml)|(application\/xml)|(\+xml)/.test(contentType);
  }

  function convertResponseBody(responseType, contentType, body) {
    if (responseType === "" || responseType === "text") {
      return body;
    } else if (supportsArrayBuffer && responseType === "arraybuffer") {
      return convertToArrayBuffer(body);
    } else if (responseType === "json") {
      try {
        return JSON.parse(body);
      } catch (e) {
        // Return parsing failure as null
        return null;
      }
    } else if (supportsBlob && responseType === "blob") {
      var blobOptions = {};
      if (contentType) {
        blobOptions.type = contentType;
      }
      return new Blob([convertToArrayBuffer(body)], blobOptions);
    } else if (responseType === "document") {
      if (isXmlContentType(contentType)) {
        return FakeXMLHttpRequest.parseXML(body);
      }
      return null;
    }
    throw new Error("Invalid responseType " + responseType);
  }

  function clearResponse(xhr) {
    if (xhr.responseType === "" || xhr.responseType === "text") {
      xhr.response = xhr.responseText = "";
    } else {
      xhr.response = xhr.responseText = null;
    }
    xhr.responseXML = null;
  }

  FakeXMLHttpRequest.parseXML = function parseXML(text) {
    // Treat empty string as parsing failure
    if (text !== "") {
      try {
        if (typeof DOMParser !== "undefined") {
          var parser = new DOMParser();
          return parser.parseFromString(text, "text/xml");
        }
        var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async = "false";
        xmlDoc.loadXML(text);
        return xmlDoc;
      } catch (e) {
        // Unable to parse XML - no biggie
      }
    }

    return null;
  };

  FakeXMLHttpRequest.statusCodes = {
    100: "Continue",
    101: "Switching Protocols",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    300: "Multiple Choice",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Request Entity Too Large",
    414: "Request-URI Too Long",
    415: "Unsupported Media Type",
    416: "Requested Range Not Satisfiable",
    417: "Expectation Failed",
    422: "Unprocessable Entity",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported"
  };

  function makeApi(sinon) {
    sinon.xhr = sinonXhr;

    sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {
      async: true,

      open: function open(method, url, async, username, password) {
        this.method = method;
        this.url = url;
        this.async = typeof async === "boolean" ? async : true;
        this.username = username;
        this.password = password;
        clearResponse(this);
        this.requestHeaders = {};
        this.sendFlag = false;

        if (FakeXMLHttpRequest.useFilters === true) {
          var xhrArgs = arguments;
          var defake = some(FakeXMLHttpRequest.filters, function (filter) {
            return filter.apply(this, xhrArgs);
          });
          if (defake) {
            return FakeXMLHttpRequest.defake(this, arguments);
          }
        }
        this.readyStateChange(FakeXMLHttpRequest.OPENED);
      },

      readyStateChange: function readyStateChange(state) {
        this.readyState = state;

        var readyStateChangeEvent = new sinon.Event("readystatechange", false, false, this);

        if (typeof this.onreadystatechange === "function") {
          try {
            this.onreadystatechange(readyStateChangeEvent);
          } catch (e) {
            sinon.logError("Fake XHR onreadystatechange handler", e);
          }
        }

        switch (this.readyState) {
          case FakeXMLHttpRequest.DONE:
            if (supportsProgress) {
              this.upload.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));
              this.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));
            }
            this.upload.dispatchEvent(new sinon.Event("load", false, false, this));
            this.dispatchEvent(new sinon.Event("load", false, false, this));
            this.dispatchEvent(new sinon.Event("loadend", false, false, this));
            break;
        }

        this.dispatchEvent(readyStateChangeEvent);
      },

      setRequestHeader: function setRequestHeader(header, value) {
        verifyState(this);

        if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {
          throw new Error("Refused to set unsafe header \"" + header + "\"");
        }

        if (this.requestHeaders[header]) {
          this.requestHeaders[header] += "," + value;
        } else {
          this.requestHeaders[header] = value;
        }
      },

      // Helps testing
      setResponseHeaders: function setResponseHeaders(headers) {
        verifyRequestOpened(this);
        this.responseHeaders = {};

        for (var header in headers) {
          if (headers.hasOwnProperty(header)) {
            this.responseHeaders[header] = headers[header];
          }
        }

        if (this.async) {
          this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);
        } else {
          this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;
        }
      },

      // Currently treats ALL data as a DOMString (i.e. no Document)
      send: function send(data) {
        verifyState(this);

        if (!/^(get|head)$/i.test(this.method)) {
          var contentType = getHeader(this.requestHeaders, "Content-Type");
          if (this.requestHeaders[contentType]) {
            var value = this.requestHeaders[contentType].split(";");
            this.requestHeaders[contentType] = value[0] + ";charset=utf-8";
          } else if (supportsFormData && !(data instanceof FormData)) {
            this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";
          }

          this.requestBody = data;
        }

        this.errorFlag = false;
        this.sendFlag = this.async;
        clearResponse(this);
        this.readyStateChange(FakeXMLHttpRequest.OPENED);

        if (typeof this.onSend === "function") {
          this.onSend(this);
        }

        this.dispatchEvent(new sinon.Event("loadstart", false, false, this));
      },

      abort: function abort() {
        this.aborted = true;
        clearResponse(this);
        this.errorFlag = true;
        this.requestHeaders = {};
        this.responseHeaders = {};

        if (this.readyState > FakeXMLHttpRequest.UNSENT && this.sendFlag) {
          this.readyStateChange(FakeXMLHttpRequest.DONE);
          this.sendFlag = false;
        }

        this.readyState = FakeXMLHttpRequest.UNSENT;

        this.dispatchEvent(new sinon.Event("abort", false, false, this));

        this.upload.dispatchEvent(new sinon.Event("abort", false, false, this));

        if (typeof this.onerror === "function") {
          this.onerror();
        }
      },

      getResponseHeader: function getResponseHeader(header) {
        if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {
          return null;
        }

        if (/^Set-Cookie2?$/i.test(header)) {
          return null;
        }

        header = getHeader(this.responseHeaders, header);

        return this.responseHeaders[header] || null;
      },

      getAllResponseHeaders: function getAllResponseHeaders() {
        if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {
          return "";
        }

        var headers = "";

        for (var header in this.responseHeaders) {
          if (this.responseHeaders.hasOwnProperty(header) && !/^Set-Cookie2?$/i.test(header)) {
            headers += header + ": " + this.responseHeaders[header] + "\r\n";
          }
        }

        return headers;
      },

      setResponseBody: function setResponseBody(body) {
        verifyRequestSent(this);
        verifyHeadersReceived(this);
        verifyResponseBodyType(body);
        var contentType = this.getResponseHeader("Content-Type");

        var isTextResponse = this.responseType === "" || this.responseType === "text";
        clearResponse(this);
        if (this.async) {
          var chunkSize = this.chunkSize || 10;
          var index = 0;

          do {
            this.readyStateChange(FakeXMLHttpRequest.LOADING);

            if (isTextResponse) {
              this.responseText = this.response += body.substring(index, index + chunkSize);
            }
            index += chunkSize;
          } while (index < body.length);
        }

        this.response = convertResponseBody(this.responseType, contentType, body);
        if (isTextResponse) {
          this.responseText = this.response;
        }

        if (this.responseType === "document") {
          this.responseXML = this.response;
        } else if (this.responseType === "" && isXmlContentType(contentType)) {
          this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);
        }
        this.readyStateChange(FakeXMLHttpRequest.DONE);
      },

      respond: function respond(status, headers, body) {
        this.status = typeof status === "number" ? status : 200;
        this.statusText = FakeXMLHttpRequest.statusCodes[this.status];
        this.setResponseHeaders(headers || {});
        this.setResponseBody(body || "");
      },

      uploadProgress: function uploadProgress(progressEventRaw) {
        if (supportsProgress) {
          this.upload.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));
        }
      },

      downloadProgress: function downloadProgress(progressEventRaw) {
        if (supportsProgress) {
          this.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));
        }
      },

      uploadError: function uploadError(error) {
        if (supportsCustomEvent) {
          this.upload.dispatchEvent(new sinon.CustomEvent("error", {detail: error}));
        }
      }
    });

    sinon.extend(FakeXMLHttpRequest, {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    });

    sinon.useFakeXMLHttpRequest = function () {
      FakeXMLHttpRequest.restore = function restore(keepOnCreate) {
        if (sinonXhr.supportsXHR) {
          global.XMLHttpRequest = sinonXhr.GlobalXMLHttpRequest;
        }

        if (sinonXhr.supportsActiveX) {
          global.ActiveXObject = sinonXhr.GlobalActiveXObject;
        }

        delete FakeXMLHttpRequest.restore;

        if (keepOnCreate !== true) {
          delete FakeXMLHttpRequest.onCreate;
        }
      };
      if (sinonXhr.supportsXHR) {
        global.XMLHttpRequest = FakeXMLHttpRequest;
      }

      if (sinonXhr.supportsActiveX) {
        global.ActiveXObject = function ActiveXObject(objId) {
          if (objId === "Microsoft.XMLHTTP" || /^Msxml2\.XMLHTTP/i.test(objId)) {

            return new FakeXMLHttpRequest();
          }

          return new sinonXhr.GlobalActiveXObject(objId);
        };
      }

      return FakeXMLHttpRequest;
    };

    sinon.FakeXMLHttpRequest = FakeXMLHttpRequest;
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  function loadDependencies(require, exports, module) {
    var sinon = require("./core");
    require("../extend");
    require("./event");
    require("../log_error");
    makeApi(sinon);
    module.exports = sinon;
  }

  if (isAMD) {
    define(loadDependencies);
    return;
  }

  if (isNode) {
    loadDependencies(require, module.exports, module);
    return;
  }

  if (sinonGlobal) {
    makeApi(sinonGlobal);
  }
}(
  typeof sinon === "object" && sinon, // eslint-disable-line no-undef
  typeof global !== "undefined" ? global : self
));

/**
 * @depend util/core.js
 */
/**
 * Format functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */
(function (sinonGlobal, formatio) {

  function makeApi(sinon) {
    function valueFormatter(value) {
      return "" + value;
    }

    function getFormatioFormatter() {
      var formatter = formatio.configure({
        quoteStrings: false,
        limitChildrenCount: 250
      });

      function format() {
        return formatter.ascii.apply(formatter, arguments);
      }

      return format;
    }

    function getNodeFormatter() {
      try {
        var util = require("util");
      } catch (e) {
        /* Node, but no util module - would be very old, but better safe than sorry */
      }

      function format(v) {
        var isObjectWithNativeToString = typeof v === "object" && v.toString === Object.prototype.toString;
        return isObjectWithNativeToString ? util.inspect(v) : v;
      }

      return util ? format : valueFormatter;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var formatter;

    if (isNode) {
      try {
        formatio = require("formatio");
      }
      catch (e) {
      } // eslint-disable-line no-empty
    }

    if (formatio) {
      formatter = getFormatioFormatter();
    } else if (isNode) {
      formatter = getNodeFormatter();
    } else {
      formatter = valueFormatter;
    }

    sinon.format = formatter;
    return sinon.format;
  }

  function loadDependencies(require, exports, module) {
    var sinon = require("./util/core");
    module.exports = makeApi(sinon);
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  if (isAMD) {
    define(loadDependencies);
    return;
  }

  if (isNode) {
    loadDependencies(require, module.exports, module);
    return;
  }

  if (sinonGlobal) {
    makeApi(sinonGlobal);
  }
}(
  typeof sinon === "object" && sinon, // eslint-disable-line no-undef
  typeof formatio === "object" && formatio // eslint-disable-line no-undef
));

/**
 * @depend fake_xdomain_request.js
 * @depend fake_xml_http_request.js
 * @depend ../format.js
 * @depend ../log_error.js
 */
/**
 * The Sinon "server" mimics a web server that receives requests from
 * sinon.FakeXMLHttpRequest and provides an API to respond to those requests,
 * both synchronously and asynchronously. To respond synchronuously, canned
 * answers have to be provided upfront.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {

  var push = [].push;

  function responseArray(handler) {
    var response = handler;

    if (Object.prototype.toString.call(handler) !== "[object Array]") {
      response = [200, {}, handler];
    }

    if (typeof response[2] !== "string") {
      throw new TypeError("Fake server response body should be string, but was " + typeof response[2]);
    }

    return response;
  }

  var wloc = typeof window !== "undefined" ? window.location : {};
  var rCurrLoc = new RegExp("^" + wloc.protocol + "//" + wloc.host);

  function matchOne(response, reqMethod, reqUrl) {
    var rmeth = response.method;
    var matchMethod = !rmeth || rmeth.toLowerCase() === reqMethod.toLowerCase();
    var url = response.url;
    var matchUrl = !url || url === reqUrl || (typeof url.test === "function" && url.test(reqUrl));

    return matchMethod && matchUrl;
  }

  function match(response, request) {
    var requestUrl = request.url;

    if (!/^https?:\/\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {
      requestUrl = requestUrl.replace(rCurrLoc, "");
    }

    if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {
      if (typeof response.response === "function") {
        var ru = response.url;
        var args = [request].concat(ru && typeof ru.exec === "function" ? ru.exec(requestUrl).slice(1) : []);
        return response.response.apply(response, args);
      }

      return true;
    }

    return false;
  }

  function makeApi(sinon) {
    sinon.fakeServer = {
      create: function (config) {
        var server = sinon.create(this);
        server.configure(config);
        if (!sinon.xhr.supportsCORS) {
          this.xhr = sinon.useFakeXDomainRequest();
        } else {
          this.xhr = sinon.useFakeXMLHttpRequest();
        }
        server.requests = [];

        this.xhr.onCreate = function (xhrObj) {
          server.addRequest(xhrObj);
        };

        return server;
      },
      configure: function (config) {
        var whitelist = {
          "autoRespond": true,
          "autoRespondAfter": true,
          "respondImmediately": true,
          "fakeHTTPMethods": true
        };
        var setting;

        config = config || {};
        for (setting in config) {
          if (whitelist.hasOwnProperty(setting) && config.hasOwnProperty(setting)) {
            this[setting] = config[setting];
          }
        }
      },
      addRequest: function addRequest(xhrObj) {
        var server = this;
        push.call(this.requests, xhrObj);

        xhrObj.onSend = function () {
          server.handleRequest(this);

          if (server.respondImmediately) {
            server.respond();
          } else if (server.autoRespond && !server.responding) {
            var request = this;
            var state = Leonardo.fetchStatesByUrlAndMethod(request.url, request.method);
            var delay;
            if (state && state.activeOption && state.activeOption.hasOwnProperty('delay')) {
              delay = state.activeOption.delay;
            } else {
              delay = server.autoRespondAfter || 10;
            }

            setTimeout(function () {
              server.responding = false;
              server.respond();
            }, delay);

            server.responding = true;
          }
        };
      },

      getHTTPMethod: function getHTTPMethod(request) {
        if (this.fakeHTTPMethods && /post/i.test(request.method)) {
          var matches = (request.requestBody || "").match(/_method=([^\b;]+)/);
          return matches ? matches[1] : request.method;
        }

        return request.method;
      },

      handleRequest: function handleRequest(xhr) {
        if (xhr.async) {
          if (!this.queue) {
            this.queue = [];
          }

          push.call(this.queue, xhr);
        } else {
          this.processRequest(xhr);
        }
      },

      log: function log(response, request) {
        var str;

        str = "Request:\n" + sinon.format(request) + "\n\n";
        str += "Response:\n" + sinon.format(response) + "\n\n";

        sinon.log(str);
      },

      respondWith: function respondWith(method, url, body) {
        if (arguments.length === 1 && typeof method !== "function") {
          this.response = responseArray(method);
          return;
        }

        if (!this.responses) {
          this.responses = [];
        }

        if (arguments.length === 1) {
          body = method;
          url = method = null;
        }

        if (arguments.length === 2) {
          body = url;
          url = method;
          method = null;
        }

        push.call(this.responses, {
          method: method,
          url: url,
          response: typeof body === "function" ? body : responseArray(body)
        });
      },

      respond: function respond() {
        if (arguments.length > 0) {
          this.respondWith.apply(this, arguments);
        }

        var queue = this.queue || [];
        var requests = queue.splice(0, queue.length);

        for (var i = 0; i < requests.length; i++) {
          this.processRequest(requests[i]);
        }
      },

      processRequest: function processRequest(request) {
        try {
          if (request.aborted) {
            return;
          }

          var response = this.response || [404, {}, ""];

          if (this.responses) {
            for (var l = this.responses.length, i = l - 1; i >= 0; i--) {
              if (match.call(this, this.responses[i], request)) {
                response = this.responses[i].response;
                break;
              }
            }
          }

          if (request.readyState !== 4) {
            this.log(response, request);
            request.respond(response[0], response[1], response[2]);
          }
        } catch (e) {
          sinon.logError("Fake server request processing", e);
        }
      },

      restore: function restore() {
        return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);
      }
    };
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  function loadDependencies(require, exports, module) {
    var sinon = require("./core");
    require("./fake_xdomain_request");
    require("./fake_xml_http_request");
    require("../format");
    makeApi(sinon);
    module.exports = sinon;
  }

  if (isAMD) {
    define(loadDependencies);
  } else if (isNode) {
    loadDependencies(require, module.exports, module);
  } else {
    makeApi(sinon); // eslint-disable-line no-undef
  }
}());

/**
 * Fake timer API
 * setTimeout
 * setInterval
 * clearTimeout
 * clearInterval
 * tick
 * reset
 * Date
 *
 * Inspired by jsUnitMockTimeOut from JsUnit
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {

  function makeApi(s, lol) {
    /*global lolex */
    var llx = typeof lolex !== "undefined" ? lolex : lol;

    s.useFakeTimers = function () {
      var now;
      var methods = Array.prototype.slice.call(arguments);

      if (typeof methods[0] === "string") {
        now = 0;
      } else {
        now = methods.shift();
      }

      var clock = llx.install(now || 0, methods);
      clock.restore = clock.uninstall;
      return clock;
    };

    s.clock = {
      create: function (now) {
        return llx.createClock(now);
      }
    };

    s.timers = {
      setTimeout: setTimeout,
      clearTimeout: clearTimeout,
      setImmediate: (typeof setImmediate !== "undefined" ? setImmediate : undefined),
      clearImmediate: (typeof clearImmediate !== "undefined" ? clearImmediate : undefined),
      setInterval: setInterval,
      clearInterval: clearInterval,
      Date: Date
    };
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  function loadDependencies(require, epxorts, module, lolex) {
    var core = require("./core");
    makeApi(core, lolex);
    module.exports = core;
  }

  if (isAMD) {
    define(loadDependencies);
  } else if (isNode) {
    loadDependencies(require, module.exports, module, require("lolex"));
  } else {
    makeApi(sinon); // eslint-disable-line no-undef
  }
}());

/**
 * @depend fake_server.js
 * @depend fake_timers.js
 */
/**
 * Add-on for sinon.fakeServer that automatically handles a fake timer along with
 * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery
 * 1.3.x, which does not use xhr object's onreadystatehandler at all - instead,
 * it polls the object for completion with setInterval. Dispite the direct
 * motivation, there is nothing jQuery-specific in this file, so it can be used
 * in any environment where the ajax implementation depends on setInterval or
 * setTimeout.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {

  function makeApi(sinon) {
    function Server() {
    }

    Server.prototype = sinon.fakeServer;

    sinon.fakeServerWithClock = new Server();

    sinon.fakeServerWithClock.addRequest = function addRequest(xhr) {
      if (xhr.async) {
        if (typeof setTimeout.clock === "object") {
          this.clock = setTimeout.clock;
        } else {
          this.clock = sinon.useFakeTimers();
          this.resetClock = true;
        }

        if (!this.longestTimeout) {
          var clockSetTimeout = this.clock.setTimeout;
          var clockSetInterval = this.clock.setInterval;
          var server = this;

          this.clock.setTimeout = function (fn, timeout) {
            server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);

            return clockSetTimeout.apply(this, arguments);
          };

          this.clock.setInterval = function (fn, timeout) {
            server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);

            return clockSetInterval.apply(this, arguments);
          };
        }
      }

      return sinon.fakeServer.addRequest.call(this, xhr);
    };

    sinon.fakeServerWithClock.respond = function respond() {
      var returnVal = sinon.fakeServer.respond.apply(this, arguments);

      if (this.clock) {
        this.clock.tick(this.longestTimeout || 0);
        this.longestTimeout = 0;

        if (this.resetClock) {
          this.clock.restore();
          this.resetClock = false;
        }
      }

      return returnVal;
    };

    sinon.fakeServerWithClock.restore = function restore() {
      if (this.clock) {
        this.clock.restore();
      }

      return sinon.fakeServer.restore.apply(this, arguments);
    };
  }

  var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
  var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

  function loadDependencies(require) {
    var sinon = require("./core");
    require("./fake_server");
    require("./fake_timers");
    makeApi(sinon);
  }

  if (isAMD) {
    define(loadDependencies);
  } else if (isNode) {
    loadDependencies(require);
  } else {
    makeApi(sinon); // eslint-disable-line no-undef
  }
}());

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
function leoConfiguration() {
    var _states = [], _scenarios = {}, _requestsLog = [], _savedStates = [], _statesChangedEvent = new CustomEvent('leonardo:setStates'), _eventsElem = document.body, _jsonpCallbacks = {};
    return {
        addState: addState,
        addStates: addStates,
        getActiveStateOption: getActiveStateOption,
        getStates: fetchStates,
        deactivateState: deactivateState,
        toggleActivateAll: toggleActivateAll,
        activateStateOption: activateStateOption,
        addScenario: addScenario,
        addScenarios: addScenarios,
        getScenario: getScenario,
        getScenarios: getScenarios,
        setActiveScenario: setActiveScenario,
        getRecordedStates: getRecordedStates,
        getRequestsLog: getRequestsLog,
        loadSavedStates: loadSavedStates,
        addSavedState: addSavedState,
        addOrUpdateSavedState: addOrUpdateSavedState,
        fetchStatesByUrlAndMethod: fetchStatesByUrlAndMethod,
        removeState: removeState,
        removeOption: removeOption,
        onStateChange: onSetStates,
        statesChanged: statesChanged,
        _logRequest: logRequest,
        _jsonpCallbacks: _jsonpCallbacks
    };
    function upsertOption(state, name, active) {
        var statesStatus = Leonardo.storage.getStates();
        statesStatus[state] = {
            name: name || findStateOption(state).name,
            active: active
        };
        Leonardo.storage.setStates(statesStatus);
        setupJsonpForState(state);
    }
    function setupJsonpForState(stateName) {
        var state = fetchState(stateName);
        if (state && state.verb === 'JSONP') {
            var callbackName = getCallbackName(state);
            state.active ? activeJsonpState(state, callbackName) : deactivateJsonpState(state, callbackName);
        }
    }
    function activeJsonpState(state, callbackName) {
        var funcName = state.name + callbackName;
        if (_jsonpCallbacks[funcName])
            return;
        if (typeof window[callbackName] === 'function') {
            _jsonpCallbacks[funcName] = window[callbackName];
            window[callbackName] = dummyJsonpCallback;
        }
        activateJsonpMObserver();
    }
    function activateJsonpMObserver() {
        if (Leonardo._jsonpMutationObservers) {
            if (!fetchStates().some(function (state) { return state.verb === 'JSONP' && state.active; })) {
                Leonardo._jsonpMutationObservers.forEach(function (mutationObserver) { return mutationObserver && mutationObserver.disconnect(); });
                delete Leonardo._jsonpCallbacks;
                delete Leonardo._jsonpMutationObservers;
            }
            return;
        }
        var targets = [document.body, document.head].filter(function (target) { return !!target; });
        var config = { attributes: false, childList: true, characterData: false, subtree: false };
        Leonardo._jsonpMutationObservers = targets.map(function (target) {
            return new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    if (mutation.addedNodes &&
                        mutation.addedNodes[0] &&
                        mutation.addedNodes[0].tagName &&
                        mutation.addedNodes[0].tagName.toLowerCase() === 'script') {
                        var scriptNode = mutation.addedNodes[0];
                        if (scriptNode.src && scriptNode.src.indexOf('callback') > 0) {
                            logRequest('JSONP', scriptNode.src, {}, 200);
                        }
                        var state = fetchStatesByUrlAndMethod(scriptNode.src, 'JSONP');
                        if (state && state.active) {
                            var callbackName = getCallbackName(state);
                            var funcName = state.name + callbackName;
                            if (!_jsonpCallbacks[funcName]) {
                                activeJsonpState(state, callbackName);
                            }
                            setTimeout(_jsonpCallbacks[funcName].bind(null, state.activeOption.data), state.activeOption.delay || 0);
                        }
                    }
                });
            });
        });
        targets.forEach(function (target, index) { return Leonardo._jsonpMutationObservers[index].observe(target, config); });
    }
    function dummyJsonpCallback() {
    }
    function deactivateJsonpState(state, callbackName) {
        var funcName = state.name + callbackName;
        if (_jsonpCallbacks[funcName]) {
            window[callbackName] = _jsonpCallbacks[funcName];
            delete _jsonpCallbacks[funcName];
        }
        activateJsonpMObserver();
    }
    function getCallbackName(state) {
        if (state.jsonpCallback) {
            return state.jsonpCallback;
        }
        var postfix = state.url.split('callback=')[1];
        return postfix.split('&')[0];
    }
    function fetchStatesByUrlAndMethod(url, method) {
        return fetchStates().filter(function (state) {
            return state.url &&
                (new RegExp(state.url).test(url) || state.url === url) &&
                state.verb.toLowerCase() === method.toLowerCase();
        })[0];
    }
    function fetchStates() {
        var activeStates = Leonardo.storage.getStates();
        var statesCopy = _states.map(function (state) {
            return Object.assign({}, state);
        });
        statesCopy.forEach(function (state) {
            var option = activeStates[state.name];
            state.active = !!option && option.active;
            state.activeOption = !!option ?
                state.options.filter(function (_option) {
                    return _option.name === option.name;
                })[0] : state.options[0];
        });
        return statesCopy;
    }
    function fetchState(name) {
        return fetchStates().filter(function (state) {
            return state.name === name;
        })[0];
    }
    function toggleActivateAll(flag) {
        var statesStatus = fetchStates();
        var statuses = statesStatus.reduce(function (obj, s) {
            var optionName = s.activeOption ? s.activeOption.name : s.options[0].name;
            obj[s.name] = { name: optionName, active: flag };
            return obj;
        }, {});
        Leonardo.storage.setStates(statuses);
        return statesStatus;
    }
    function findStateOption(name) {
        return fetchStates().filter(function (state) {
            return state.name === name;
        })[0].activeOption;
    }
    function getActiveStateOption(name) {
        var state = fetchStates().filter(function (state) {
            return state.name === name;
        })[0];
        return (state && state.active && findStateOption(name)) || null;
    }
    function addState(stateObj, overrideOption) {
        stateObj.options.forEach(function (option) {
            upsert({
                state: stateObj.name,
                url: stateObj.url,
                verb: stateObj.verb,
                name: option.name,
                from_local: !!overrideOption,
                status: option.status,
                data: option.data,
                delay: option.delay
            }, overrideOption);
        });
    }
    function addStates(statesArr, overrideOption) {
        if (overrideOption === void 0) { overrideOption = false; }
        if (Array.isArray(statesArr)) {
            statesArr.forEach(function (stateObj) {
                addState(stateObj, overrideOption);
            });
        }
        else {
            console.warn('leonardo: addStates should get an array');
        }
    }
    function upsert(configObj, overrideOption) {
        var verb = configObj.verb || 'GET', state = configObj.state, name = configObj.name, from_local = configObj.from_local, url = configObj.url, status = configObj.status || 200, data = (typeof configObj.data !== 'undefined') ? configObj.data : {}, delay = configObj.delay || 0;
        var defaultState = {};
        var defaultOption = {};
        if (!state) {
            console.log("leonardo: cannot upsert - state is mandatory");
            return;
        }
        var stateItem = _states.filter(function (_state) {
            return _state.name === state;
        })[0] || defaultState;
        Object.assign(stateItem, {
            name: state,
            url: url || stateItem.url,
            verb: verb,
            options: stateItem.options || []
        });
        if (stateItem === defaultState) {
            _states.push(stateItem);
        }
        var option = stateItem.options.filter(function (_option) {
            return _option.name === name;
        })[0];
        if (overrideOption && option) {
            Object.assign(option, {
                name: name,
                from_local: from_local,
                status: status,
                data: data,
                delay: delay
            });
        }
        else if (!option) {
            Object.assign(defaultOption, {
                name: name,
                from_local: from_local,
                status: status,
                data: data,
                delay: delay
            });
            stateItem.options.push(defaultOption);
        }
        setupJsonpForState(state);
    }
    function addScenario(scenario, fromLocal) {
        if (fromLocal === void 0) { fromLocal = false; }
        if (scenario && typeof scenario.name === 'string') {
            if (fromLocal) {
                var scenarios = Leonardo.storage.getScenarios();
                scenarios.push(scenario);
                Leonardo.storage.setScenarios(scenarios);
            }
            else {
                _scenarios[scenario.name] = scenario;
            }
        }
        else {
            throw 'addScenario method expects a scenario object with name property';
        }
    }
    function addScenarios(scenarios) {
        scenarios.forEach(function (scenario) {
            addScenario(scenario);
        });
    }
    function getScenarios() {
        var scenarios = Leonardo.storage.getScenarios().map(function (scenario) { return scenario.name; });
        return Object.keys(_scenarios).concat(scenarios);
    }
    function getScenario(name) {
        var states;
        if (_scenarios[name]) {
            states = _scenarios[name].states;
        }
        else {
            states = Leonardo.storage.getScenarios()
                .filter(function (scenario) { return scenario.name === name; })[0].states;
        }
        return states;
    }
    function setActiveScenario(name) {
        var scenario = getScenario(name);
        if (!scenario) {
            console.warn("leonardo: could not find scenario named " + name);
            return;
        }
        toggleActivateAll(false);
        scenario.forEach(function (state) {
            upsertOption(state.name, state.option, true);
        });
    }
    function activateStateOption(state, optionName) {
        upsertOption(state, optionName, true);
    }
    function deactivateState(state) {
        upsertOption(state, null, false);
    }
    function logRequest(method, url, data, status) {
        if (method && url && !(url.indexOf(".html") > 0)) {
            var req = {
                verb: method,
                data: data,
                url: url.trim(),
                status: status,
                timestamp: new Date()
            };
            req.state = fetchStatesByUrlAndMethod(req.url, req.verb);
            _requestsLog.push(req);
        }
    }
    function getRequestsLog() {
        return _requestsLog;
    }
    function loadSavedStates() {
        _savedStates = Leonardo.storage.getSavedStates();
        addStates(_savedStates, true);
    }
    function addSavedState(state) {
        _savedStates.push(state);
        Leonardo.storage.setSavedStates(_savedStates);
        addState(state, true);
    }
    function addOrUpdateSavedState(state) {
        var option = state.activeOption;
        var _savedState = _savedStates.filter(function (_state) {
            return _state.name === state.name;
        })[0];
        if (_savedState) {
            var _savedOption = _savedState.options.filter(function (_option) {
                return _option.name === option.name;
            })[0];
            if (_savedOption) {
                _savedOption.status = option.status;
                _savedOption.delay = option.delay;
                _savedOption.data = option.data;
            }
            else {
                _savedState.options.push(option);
            }
            Leonardo.storage.setSavedStates(_savedStates);
        }
        else {
            addSavedState(state);
        }
        var _state = _states.filter(function (__state) {
            return __state.name === state.name;
        })[0];
        if (_state) {
            var _option = _state.options.filter(function (__option) {
                return __option.name === option.name;
            })[0];
            if (_option) {
                _option.status = option.status;
                _option.delay = option.delay;
                _option.data = option.data;
            }
            else {
                _state.options.push(option);
            }
        }
    }
    function removeStateByName(name) {
        var index = 0;
        _states.forEach(function (state, i) {
            if (state.name === name) {
                index = i;
            }
        });
        _states.splice(index, 1);
    }
    function removeSavedStateByName(name) {
        var index = 0;
        _savedStates.forEach(function (state, i) {
            if (state.name === name) {
                index = i;
            }
        });
        _savedStates.splice(index, 1);
    }
    function removeState(state) {
        removeStateByName(state.name);
        removeSavedStateByName(state.name);
        Leonardo.storage.setSavedStates(_savedStates);
    }
    function removeStateOptionByName(stateName, optionName) {
        var sIndex = null;
        var oIndex = null;
        _states.forEach(function (state, i) {
            if (state.name === stateName) {
                sIndex = i;
            }
        });
        if (sIndex !== null) {
            _states[sIndex].options.forEach(function (option, i) {
                if (option.name === optionName) {
                    oIndex = i;
                }
            });
            if (oIndex !== null) {
                _states[sIndex].options.splice(oIndex, 1);
            }
        }
    }
    function removeSavedStateOptionByName(stateName, optionName) {
        var sIndex = null;
        var oIndex = null;
        _savedStates.forEach(function (state, i) {
            if (state.name === stateName) {
                sIndex = i;
            }
        });
        if (sIndex !== null) {
            _savedStates[sIndex].options.forEach(function (option, i) {
                if (option.name === optionName) {
                    oIndex = i;
                }
            });
            if (oIndex !== null) {
                _savedStates[sIndex].options.splice(oIndex, 1);
            }
        }
    }
    function removeOption(state, option) {
        removeStateOptionByName(state.name, option.name);
        removeSavedStateOptionByName(state.name, option.name);
        Leonardo.storage.setSavedStates(_savedStates);
        activateStateOption(_states[0].name, _states[0].options[0].name);
    }
    function getRecordedStates() {
        var requestsArr = _requestsLog
            .map(function (req) {
            var state = fetchStatesByUrlAndMethod(req.url, req.verb);
            return {
                name: state ? state.name : req.verb + " " + req.url,
                verb: req.verb,
                url: req.url,
                recorded: !!req.state,
                options: [{
                        name: req.status >= 200 && req.status < 300 ? 'Success' : 'Failure',
                        status: req.status,
                        data: req.data
                    }]
            };
        });
        return requestsArr;
    }
    function onSetStates(fn) {
        _eventsElem && _eventsElem.addEventListener('leonardo:setStates', fn, false);
    }
    function statesChanged() {
        _eventsElem && _eventsElem.dispatchEvent(_statesChangedEvent);
    }
}
exports.leoConfiguration = leoConfiguration;

},{}],2:[function(require,module,exports){
var configuration_srv_1 = require('./configuration.srv');
var storage_srv_1 = require('./storage.srv');
var polyfills_1 = require('./polyfills');
var sinon_srv_1 = require('./sinon.srv');
var ui_root_1 = require('./ui/ui-root');
polyfills_1.polifylls();
window.Leonardo = window.Leonardo || {};
var configuration = configuration_srv_1.leoConfiguration();
var storage = new storage_srv_1.Storage();
Object.assign(window.Leonardo || {}, configuration, { storage: storage });
Leonardo.loadSavedStates();
new sinon_srv_1.Sinon();
new ui_root_1.default();

},{"./configuration.srv":1,"./polyfills":3,"./sinon.srv":4,"./storage.srv":5,"./ui/ui-root":15}],3:[function(require,module,exports){
function polifylls() {
    (function () {
        function CustomEvent(event, params) {
            params = params || { bubbles: false, cancelable: false, detail: undefined };
            var evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            return evt;
        }
        CustomEvent.prototype = window['Event'].prototype;
        window['CustomEvent'] = CustomEvent;
    })();
    (function () {
        if (typeof Object.assign != 'function') {
            Object.assign = function (target) {
                'use strict';
                if (target == null) {
                    throw new TypeError('Cannot convert undefined or null to object');
                }
                target = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source != null) {
                        for (var key in source) {
                            if (Object.prototype.hasOwnProperty.call(source, key)) {
                                target[key] = source[key];
                            }
                        }
                    }
                }
                return target;
            };
        }
    })();
}
exports.polifylls = polifylls;

},{}],4:[function(require,module,exports){
var utils_1 = require('./utils');
var Sinon = (function () {
    function Sinon() {
        this.init();
    }
    Sinon.prototype.init = function () {
        var server = sinon.fakeServer.create({
            autoRespond: true,
            autoRespondAfter: 10
        });
        sinon.FakeXMLHttpRequest.useFilters = true;
        sinon.FakeXMLHttpRequest.addFilter(function (method, url) {
            if (url.indexOf('.html') > 0 && url.indexOf('template') >= 0) {
                return true;
            }
            var state = Leonardo.fetchStatesByUrlAndMethod(url, method);
            return !(state && state.active);
        });
        sinon.FakeXMLHttpRequest.onResponseEnd = function (xhr) {
            var res = xhr.response;
            try {
                res = JSON.parse(xhr.response);
            }
            catch (e) {
            }
            Leonardo._logRequest(xhr.method, xhr.url, res, xhr.status);
        };
        server.respondWith(function (request) {
            var state = Leonardo.fetchStatesByUrlAndMethod(request.url, request.method), activeOption = Leonardo.getActiveStateOption(state.name);
            if (!!activeOption) {
                var responseData = utils_1.default.isFunction(activeOption.data) ? activeOption.data(request) : activeOption.data;
                request.respond(activeOption.status, { 'Content-Type': 'application/json' }, JSON.stringify(responseData));
                Leonardo._logRequest(request.method, request.url, responseData, activeOption.status);
            }
            else {
                console.warn('could not find a state for the following request', request);
            }
        });
    };
    return Sinon;
})();
exports.Sinon = Sinon;

},{"./utils":30}],5:[function(require,module,exports){
var utils_1 = require('./utils');
var Storage = (function () {
    function Storage() {
        this.APP_PREFIX = Leonardo.APP_PREFIX || '';
        this.STATES_STORE_KEY = this.APP_PREFIX + "leonardo-states";
        this.SAVED_STATES_KEY = this.APP_PREFIX + "leonardo-unregistered-states";
        this.SCENARIOS_STORE_KEY = this.APP_PREFIX + "leonardo-scenarios";
        this.POSITION_KEY = this.APP_PREFIX + "leonardo-position";
    }
    Storage.prototype._getItem = function (key) {
        var item = window.localStorage.getItem(key);
        if (!item) {
            return null;
        }
        return utils_1.default.fromJson(item);
    };
    Storage.prototype._setItem = function (key, data) {
        window.localStorage.setItem(key, utils_1.default.toJson(data));
    };
    Storage.prototype.getStates = function () {
        return this._getItem(this.STATES_STORE_KEY) || {};
    };
    Storage.prototype.getScenarios = function () {
        return this._getItem(this.SCENARIOS_STORE_KEY) || [];
    };
    Storage.prototype.setStates = function (states) {
        this._setItem(this.STATES_STORE_KEY, states);
        Leonardo.statesChanged();
    };
    Storage.prototype.setScenarios = function (scenarios) {
        this._setItem(this.SCENARIOS_STORE_KEY, scenarios);
    };
    Storage.prototype.getSavedStates = function () {
        var states = this._getItem(this.SAVED_STATES_KEY) || [];
        states.forEach(function (state) {
            state.options.forEach(function (option) {
                option.from_local = true;
            });
        });
        return states;
    };
    Storage.prototype.setSavedStates = function (states) {
        this._setItem(this.SAVED_STATES_KEY, states);
    };
    Storage.prototype.setSavedPosition = function (position) {
        if (!position) {
            return;
        }
        this._setItem(this.POSITION_KEY, position);
    };
    Storage.prototype.getSavedPosition = function () {
        return this._getItem(this.POSITION_KEY);
    };
    return Storage;
})();
exports.Storage = Storage;

},{"./utils":30}],6:[function(require,module,exports){
var ui_events_1 = require('./ui-events');
var ui_utils_1 = require('./ui-utils');
var DOMElement = (function () {
    function DOMElement(viewString) {
        if (viewString === void 0) { viewString = ''; }
        this.viewString = viewString;
        this.eventSubs = [];
        this.bodyEventsSubs = [];
        this.viewNode = ui_utils_1.default.getElementFromHtml(this.viewString);
    }
    DOMElement.prototype.get = function () {
        return this.viewNode;
    };
    DOMElement.prototype.render = function () {
        if (!this.viewNode) {
            return;
        }
        this.viewNode.innerHTML = '';
    };
    DOMElement.prototype.onItem = function (node, eventType, cb) {
        var eventSub = ui_events_1.default.onItem(node, eventType, cb);
        this.eventSubs.push(eventSub);
        return eventSub;
    };
    DOMElement.prototype.clearEventSubs = function () {
        this.clearSetEventSubs(this.eventSubs);
    };
    DOMElement.prototype.clearSetEventSubs = function (list) {
        list.forEach(function (listener) {
            listener.off();
        });
    };
    DOMElement.prototype.destroy = function () {
        this.clearSetEventSubs(this.bodyEventsSubs);
        this.clearEventSubs();
        this.viewNode = null;
    };
    return DOMElement;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DOMElement;

},{"./ui-events":14,"./ui-utils":18}],7:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var DOMElement_1 = require('../DOMElement');
var ui_events_1 = require('../ui-events');
var CodeEditor = (function (_super) {
    __extends(CodeEditor, _super);
    function CodeEditor(onSaveCB, onCancelCB, initData) {
        _super.call(this, "<div id=\"leonardo-code-editor\" class=\"leonardo-code-editor\"></div>");
        this.onSaveCB = onSaveCB;
        this.onCancelCB = onCancelCB;
        this.initData = initData;
    }
    CodeEditor.prototype.render = function () {
        _super.prototype.render.call(this);
        this.viewNode.innerHTML = "<div class=\"leonardo-code-editor-container\">\n          <div class=\"leonardo-code-editor-header\">\n            <strong>Edit Response</strong>\n            <a class=\"leonardo-code-editor-beautify\">Beautify</a>\n          </div>          \n          <div class=\"leonardo-code-editor-body\">\n            <div id=\"leonardo-code-editor-edit-area\"></div>\n          </div>\n          <div class=\"leonardo-code-editor-footer\">\n            <button class=\"leonardo-button leonardo-code-editor-save\">Save</button>\n            <button class=\"leonardo-button leonardo-code-editor-cancel\" >Cancel</button>                        \n          </div>           \n      </div>";
        ui_events_1.default.dispatch(ui_events_1.default.OPEN_DIALOG, this.viewNode);
        ui_events_1.default.onItem(this.viewNode.querySelector('.leonardo-code-editor-beautify'), 'click', this.beautify.bind(this));
        ui_events_1.default.onItemOnce(this.viewNode.querySelector('.leonardo-code-editor-cancel'), 'click', this.onCancel.bind(this));
        ui_events_1.default.onItemOnce(this.viewNode.querySelector('.leonardo-code-editor-save'), 'click', this.onSave.bind(this));
        this.editor = window['ace'].edit("leonardo-code-editor-edit-area");
        this.editor.getSession().setUseWorker(false);
        this.editor.getSession().setMode("ace/mode/javascript");
        this.editor.setTheme("ace/theme/chrome");
        this.editor.setShowPrintMargin(false);
        this.editor.setValue(this.initData);
        this.editor.execCommand("gotolineend");
        this.editor.focus();
    };
    CodeEditor.prototype.getResString = function (resopnse) {
        var resStr;
        try {
            if (typeof resopnse === 'function') {
                resStr = resopnse.toString();
            }
            else {
                resStr = JSON.stringify(resopnse, null, 4);
            }
        }
        catch (e) {
            resStr = typeof resopnse === 'string' ? resopnse : resopnse.toString();
        }
        return resStr;
    };
    CodeEditor.prototype.onCancel = function () {
        this.onCancelCB();
        ui_events_1.default.dispatch(ui_events_1.default.CLOSE_DIALOG);
        this.destroy();
    };
    CodeEditor.prototype.onSave = function () {
        this.onSaveCB(this.editor.getValue());
        ui_events_1.default.dispatch(ui_events_1.default.CLOSE_DIALOG);
    };
    CodeEditor.prototype.beautify = function () {
        var val = this.editor.session.getValue();
        var array = val.split(/\n/);
        array[0] = array[0].trim();
        val = array.join("\n");
        val = window['js_beautify'](val);
        this.editor.session.setValue(val);
    };
    CodeEditor.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.editor.destroy();
    };
    return CodeEditor;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CodeEditor;

},{"../DOMElement":6,"../ui-events":14}],8:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../ui-events');
var DOMElement_1 = require('../DOMElement');
var DropDown = (function (_super) {
    __extends(DropDown, _super);
    function DropDown(items, activeItem, isDisabled, onSelectItem, onRemoveItem) {
        _super.call(this, "<div class=\"leonardo-dropdown\"></div>");
        this.items = items;
        this.activeItem = activeItem;
        this.isDisabled = isDisabled;
        this.onSelectItem = onSelectItem;
        this.onRemoveItem = onRemoveItem;
        this.optionsState = false;
        this.bodyEventsSubs.push(ui_events_1.default.on('click', this.closeDropDown.bind(this)));
        this.bodyEventsSubs.push(ui_events_1.default.on(ui_events_1.default.CLOSE_DROPDOWNS, this.closeDropDown.bind(this)));
    }
    DropDown.prototype.render = function () {
        _super.prototype.render.call(this);
        this.clearEventSubs();
        this.viewNode.innerHTML = "\n          <div class=\"leonardo-dropdown-selected\" " + this.isDisabledToken() + ">\n            <span class=\"leonardo-dropdown-selected-text\">" + this.activeItem.name + "</span>\n            <span class=\"leonardo-dropdown-selected-arrow\"></span>\n          </div>\n          <div class=\"leonardo-dropdown-options\">\n            <ul class=\"leonardo-dropdown-list\">" + this.getItems().join('') + "</ul>\n          </div>";
        this.onItem(this.viewNode, 'click', this.toggleDropDown.bind(this));
    };
    DropDown.prototype.disableDropDown = function () {
        this.isDisabled = true;
        this.viewNode.querySelector(".leonardo-dropdown-selected").setAttribute('disabled', 'disabled');
    };
    DropDown.prototype.enableDropDown = function () {
        this.isDisabled = false;
        this.viewNode.querySelector(".leonardo-dropdown-selected").removeAttribute('disabled');
    };
    DropDown.prototype.toggleDropDown = function (event) {
        if (this.isDisabled) {
            return;
        }
        if (event && event.target) {
            event.stopPropagation();
        }
        if (event.target['classList'].contains('leonardo-dropdown-item')) {
            this.setActiveItem(event.target['querySelector']('.leonardo-dropdown-item-text').innerHTML);
        }
        else if (event.target['classList'].contains('leonardo-dropdown-item-text')) {
            this.setActiveItem(event.target['innerHTML']);
        }
        else if (event.target['classList'].contains('leonardo-dropdown-item-x')) {
            this.removeItem(event.target['parentNode']);
        }
        if (this.optionsState) {
            this.closeDropDown();
            this.optionsState = false;
        }
        else {
            this.openDropDown();
            this.optionsState = true;
        }
    };
    DropDown.prototype.openDropDown = function () {
        var elem = this.viewNode.querySelector(".leonardo-dropdown-options");
        elem.style.display = 'block';
        var elemRec = elem.getBoundingClientRect();
        var isOverflowed = elemRec.top + elemRec.height > window.innerHeight;
        if (isOverflowed) {
            elem.style.top = -elemRec.height + 'px';
            elem.style.borderTop = '1px solid #212121';
            elem.style.borderBottom = 'none';
        }
        ui_events_1.default.dispatch(ui_events_1.default.CLOSE_DROPDOWNS, this.viewNode);
    };
    DropDown.prototype.closeDropDown = function (event) {
        var dropDown = this.viewNode.querySelector(".leonardo-dropdown-options");
        if (!dropDown || (event && event.detail === this.viewNode)) {
            return;
        }
        dropDown.style.display = 'none';
    };
    DropDown.prototype.setActiveItem = function (itemName) {
        if (this.activeItem.name === itemName) {
            return;
        }
        this.activeItem = this.getItemByName(itemName);
        this.viewNode.querySelector(".leonardo-dropdown-selected-text")['innerHTML'] = this.activeItem.name;
        this.onSelectItem(this.activeItem);
    };
    DropDown.prototype.getItemByName = function (itemName) {
        var retItem = this.activeItem;
        this.items.some(function (curItem) {
            if (curItem.name === itemName) {
                retItem = curItem;
                return true;
            }
        });
        return retItem;
    };
    DropDown.prototype.getItems = function () {
        return this.items.map(function (item) {
            return "<li class=\"leonardo-dropdown-item\"><span class=\"leonardo-dropdown-item-text\">" + item.name + "</span><span class=\"leonardo-x-btn leonardo-dropdown-item-x\"></span></li>";
        });
    };
    DropDown.prototype.isDisabledToken = function () {
        return this.isDisabled ? 'disabled' : '';
    };
    DropDown.prototype.removeItem = function (item) {
        if (this.items.length <= 1) {
            return;
        }
        var removedItem;
        this.items = this.items.filter(function (curItem) {
            if (curItem.name === item.querySelector('.leonardo-dropdown-item-text')['innerHTML']) {
                removedItem = curItem;
            }
        });
        this.viewNode.querySelector('.leonardo-dropdown-list').removeChild(item);
        this.onRemoveItem(removedItem);
    };
    return DropDown;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DropDown;

},{"../DOMElement":6,"../ui-events":14}],9:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_state_srv_1 = require('../ui-state/ui-state.srv');
var DOMElement_1 = require('../DOMElement');
var HeaderView = (function (_super) {
    __extends(HeaderView, _super);
    function HeaderView(tabList) {
        _super.call(this, "<div class=\"leonardo-header-container\">");
        this.tabList = tabList;
    }
    HeaderView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.viewNode.innerHTML = "<div class=\"leonardo-header-container-in\">\n        <span class=\"leonardo-header-label \">LEONARDO</span>\n        <span class=\"leonardo-header-tabs\">\n          <ul>\n            " + this.getTabsHtml(0) + "\n          </ul>\n      </span>\n    </div>";
        this.onItem(this.viewNode.querySelector('ul'), 'click', this.onClick.bind(this));
    };
    HeaderView.prototype.getTabsHtml = function (selectedIndex) {
        return this.tabList.map(function (tab, index) {
            var selected = index === selectedIndex ? HeaderView.SELECTED_CLASS_NAME : '';
            return "<li class=\"leonardo-header-tabItem " + selected + "\" data-headertab=\"leonardo-header-" + tab.label + "\" >" + tab.label + "</li>";
        }).join('');
    };
    HeaderView.prototype.onClick = function (event) {
        this.selectTab(event.target['innerHTML']);
    };
    HeaderView.prototype.selectTab = function (tabLabel) {
        document.querySelector("." + HeaderView.SELECTED_CLASS_NAME).classList.remove("leonardo-header-tabItem-selected");
        document.querySelector("[data-headertab=\"leonardo-header-" + tabLabel + "\"]").classList.add(HeaderView.SELECTED_CLASS_NAME);
        ui_state_srv_1.default.getInstance().setCurViewState(tabLabel);
    };
    HeaderView.SELECTED_CLASS_NAME = 'leonardo-header-tabItem-selected';
    return HeaderView;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HeaderView;

},{"../DOMElement":6,"../ui-state/ui-state.srv":17}],10:[function(require,module,exports){
var StringHelper = (function () {
    function StringHelper() {
    }
    StringHelper.trim = function (text) {
        return text.replace(new RegExp("^[\\s]+|[\\s]+$", 'g'), '');
    };
    return StringHelper;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StringHelper;

},{}],11:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../ui-events');
var DOMElement_1 = require('../DOMElement');
var Launcher = (function (_super) {
    __extends(Launcher, _super);
    function Launcher() {
        _super.call(this, "<div class=\"leonardo-launcher\"></div>");
        this.eventSubs.push(ui_events_1.default.on('keydown', this.bodyKeypress.bind(this)));
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.TOGGLE_ICON, this.toggleLauncher.bind(this)));
        this.onItem(this.viewNode, 'click', this.onClick.bind(this));
    }
    Launcher.prototype.onClick = function () {
        ui_events_1.default.dispatch(ui_events_1.default.TOGGLE_LAUNCHER);
    };
    Launcher.prototype.bodyKeypress = function (e) {
        if (e.shiftKey && e.ctrlKey && e.keyCode === 76) {
            ui_events_1.default.dispatch(ui_events_1.default.TOGGLE_ICON);
        }
    };
    Launcher.prototype.toggleLauncher = function () {
        this.viewNode.style.display = this.viewNode.style.display === 'none' ? 'block' : 'none';
    };
    return Launcher;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Launcher;

},{"../DOMElement":6,"../ui-events":14}],12:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_utils_1 = require('../ui-utils');
var ui_events_1 = require('../ui-events');
var header_1 = require('../header/header');
var ui_state_data_1 = require('../ui-state/ui-state.data');
var ui_state_srv_1 = require('../ui-state/ui-state.srv');
var views_container_1 = require('./views-container/views-container');
var DOMElement_1 = require('../DOMElement');
var MainView = (function (_super) {
    __extends(MainView, _super);
    function MainView() {
        _super.call(this, "<div class=\"leonardo-main-view leonardo-main-view-hidden\"></div>");
        this.className = 'leonardo-main-view';
        this.hiddenClassName = this.className + "-hidden";
        this.menuState = false;
        this.eventSubs.push(ui_events_1.default.on('keydown', this.onKeyPress.bind(this)));
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.TOGGLE_LAUNCHER, this.toggleView.bind(this)));
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.ATTACH_MENU_ITEM, this.attachMenu.bind(this)));
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.OPEN_MENU, this.openMenu.bind(this)));
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.CLOSE_MENU, this.closeMenu.bind(this)));
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.OPEN_DIALOG, this.openDialog.bind(this)));
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.CLOSE_DIALOG, this.closeDialog.bind(this)));
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.CHANGE_VIEW, this.closeMenu.bind(this)));
        this.bodyView = ui_utils_1.default.getElementFromHtml("<div class=\"leonardo-main-view-body\"></div>");
        this.menuView = ui_utils_1.default.getElementFromHtml("<div class=\"leonardo-main-view-menu\"></div>");
        this.dialogView = ui_utils_1.default.getElementFromHtml("<div class=\"leonardo-main-view-dialog\"></div>");
        ui_state_srv_1.default.getInstance().init(ui_state_data_1.UIStateList(), ui_state_data_1.UIStateList()[0].name);
        this.headerView = new header_1.default(this.getTabList());
        this.viewsContainer = new views_container_1.default();
    }
    MainView.prototype.toggleView = function () {
        var el = document.querySelector("." + this.className);
        if (!el)
            return;
        if (el.classList.contains(this.hiddenClassName)) {
            el.classList.remove(this.hiddenClassName);
            if (!el.childNodes.length) {
                this.render();
            }
        }
        else {
            this.closeLeo();
        }
    };
    MainView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.menuState = false;
        this.viewNode.appendChild(this.bodyView);
        this.viewNode.appendChild(this.menuView);
        this.viewNode.appendChild(this.dialogView);
        this.bodyView.appendChild(this.headerView.get());
        this.bodyView.appendChild(this.viewsContainer.get());
        this.headerView.render();
        this.viewsContainer.setView(ui_state_srv_1.default.getInstance().getCurViewState());
        this.viewsContainer.render();
    };
    MainView.prototype.attachMenu = function (event) {
        this.menuView.innerHTML = '';
        this.closeMenu(null);
        this.menuView.appendChild(event.detail);
    };
    MainView.prototype.openMenu = function (event) {
        if (this.menuState) {
            return;
        }
        this.menuState = true;
        this.menuView.classList.remove('leonardo-main-view-menu-in');
        this.menuView.classList.add('leonardo-main-view-menu-out');
        this.bodyView.style.width = (this.bodyView.getBoundingClientRect().width - this.menuView.getBoundingClientRect().width) + 'px';
    };
    MainView.prototype.closeMenu = function (event) {
        if (!this.menuState) {
            return;
        }
        this.menuState = false;
        this.menuView.classList.remove('leonardo-main-view-menu-out');
        this.menuView.classList.add('leonardo-main-view-menu-in');
        this.bodyView.style.width = '100vw';
    };
    MainView.prototype.openDialog = function (event) {
        this.dialogView.innerHTML = '';
        this.dialogView.appendChild(event.detail);
        this.dialogView.style.display = 'block';
        this.bodyView.classList.add('leonardo-main-overlay');
    };
    MainView.prototype.closeDialog = function (event) {
        this.bodyView.classList.remove('leonardo-main-overlay');
        this.dialogView.innerHTML = '';
        this.dialogView.style.display = 'none';
    };
    MainView.prototype.getTabList = function () {
        return ui_state_srv_1.default.getInstance().getViewStates().map(function (view) {
            return { label: view.name };
        });
    };
    MainView.prototype.closeLeo = function () {
        var el = document.querySelector("." + this.className);
        el.classList.add(this.hiddenClassName);
    };
    MainView.prototype.onKeyPress = function (event) {
        if (event.which == 27) {
            this.closeLeo();
        }
    };
    return MainView;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MainView;

},{"../DOMElement":6,"../header/header":9,"../ui-events":14,"../ui-state/ui-state.data":16,"../ui-state/ui-state.srv":17,"../ui-utils":18,"./views-container/views-container":13}],13:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../../ui-events');
var DOMElement_1 = require('../../DOMElement');
var ViewsContainer = (function (_super) {
    __extends(ViewsContainer, _super);
    function ViewsContainer() {
        _super.call(this, "<div id=\"leonardo-views-container\" class=\"leonardo-views-container\">view container</div>");
        this.eventSubs.push(ui_events_1.default.on(ui_events_1.default.CHANGE_VIEW, this.onViewChanged.bind(this)));
    }
    ViewsContainer.prototype.render = function () {
        _super.prototype.render.call(this);
        this.viewNode.appendChild(this.currentViewState.component.get());
        this.currentViewState.component.render();
    };
    ViewsContainer.prototype.setView = function (curView) {
        this.currentViewState = curView;
    };
    ViewsContainer.prototype.onViewChanged = function (event) {
        this.currentViewState.component.destroy();
        this.setView(this.currentViewState = event.detail);
        this.render();
    };
    return ViewsContainer;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ViewsContainer;

},{"../../DOMElement":6,"../../ui-events":14}],14:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    TOGGLE_LAUNCHER: 'leonardo:toggle:launcher',
    CHANGE_VIEW: 'leonardo:change:view',
    FILTER_STATES: 'leonardo:filter:states',
    CLOSE_DROPDOWNS: 'leonardo:close:dropdowns',
    TOGGLE_STATES: 'leonardo:toggle:states',
    TOGGLE_SCENARIOS: 'leonardo:toggle:scenario',
    ADD_SCENARIO: 'leonardo:add:scenario',
    TOGGLE_STATE: 'leonardo:toggle:states',
    TOGGLE_ICON: 'leonardo:toggle:icon',
    ATTACH_MENU_ITEM: 'leonardo:attach:menu',
    OPEN_MENU: 'leonardo:menu:open',
    CLOSE_MENU: 'leonardo:menu:close',
    OPEN_DIALOG: 'leonardo:dialog:open',
    CLOSE_DIALOG: 'leonardo:dialog:close',
    on: function (eventName, fn) {
        return this.onItem(document.body, eventName, fn);
    },
    onOnce: function (eventName, fn) {
        this.onItemOnce(document.body, eventName, fn);
    },
    dispatch: function (eventName, details) {
        var event = new CustomEvent(eventName, { detail: details });
        document.body.dispatchEvent(event);
    },
    onItemOnce: function (node, type, callback) {
        node.addEventListener(type, function (e) {
            e.target.removeEventListener(e.type, arguments.callee);
            return callback.apply(callback, arguments);
        });
    },
    onItem: function (node, type, callback) {
        node.addEventListener(type, callback, false);
        return {
            off: function () { return node.removeEventListener(type, callback, false); }
        };
    }
};

},{}],15:[function(require,module,exports){
var launcher_1 = require('./launcher/launcher');
var main_view_1 = require('./main-view/main-view');
var ui_utils_1 = require('./ui-utils');
var ui_events_1 = require('./ui-events');
var UIRoot = (function () {
    function UIRoot() {
        switch (document.readyState) {
            default:
            case 'loading':
                ui_events_1.default.onItemOnce(document, 'DOMContentLoaded', this.init.bind(this));
                break;
            case 'interactive':
            case 'complete':
                this.init();
                break;
        }
    }
    UIRoot.prototype.init = function () {
        this.leonardoApp = ui_utils_1.default.getElementFromHtml("<div leonardo-app></div>");
        this.launcher = new launcher_1.default();
        this.mainView = new main_view_1.default();
        this.leonardoApp.appendChild(this.mainView.get());
        this.leonardoApp.appendChild(this.launcher.get());
        ui_events_1.default.on(ui_events_1.default.TOGGLE_STATES, this.toggleAllStates.bind(this));
        document.body.appendChild(this.leonardoApp);
    };
    UIRoot.prototype.toggleAllStates = function (event) {
        Leonardo.toggleActivateAll(event.detail);
    };
    return UIRoot;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UIRoot;

},{"./launcher/launcher":11,"./main-view/main-view":12,"./ui-events":14,"./ui-utils":18}],16:[function(require,module,exports){
var scenarios_1 = require('../views/scenarios/scenarios');
var recorder_1 = require('../views/recorder/recorder');
var export_1 = require('../views/export/export');
var uiList;
function UIStateList() {
    if (uiList) {
        return uiList;
    }
    return uiList = [
        {
            name: 'scenarios',
            component: new scenarios_1.default()
        },
        {
            name: 'recorder',
            component: new recorder_1.default()
        },
        {
            name: 'exported code',
            component: new export_1.default()
        }
    ];
}
exports.UIStateList = UIStateList;

},{"../views/export/export":19,"../views/recorder/recorder":21,"../views/scenarios/scenarios":24}],17:[function(require,module,exports){
var ui_events_1 = require('../ui-events');
var UIStateViewService = (function () {
    function UIStateViewService() {
        if (UIStateViewService._instance) {
            throw new Error('UIStateViewService should be singleton');
        }
        UIStateViewService._instance = this;
    }
    UIStateViewService.getInstance = function () {
        return UIStateViewService._instance;
    };
    UIStateViewService.prototype.init = function (viewStateList, initViewName) {
        this.viewStateList = viewStateList;
        this.curViewState = this.getViewStateByName(initViewName);
    };
    UIStateViewService.prototype.getCurViewState = function () {
        return this.curViewState;
    };
    UIStateViewService.prototype.setCurViewState = function (stateName) {
        this.curViewState = this.getViewStateByName(stateName);
        ui_events_1.default.dispatch(ui_events_1.default.CHANGE_VIEW, this.curViewState);
    };
    UIStateViewService.prototype.getViewStates = function () {
        return this.viewStateList;
    };
    UIStateViewService.prototype.addViewState = function (viewState) {
        this.viewStateList.push(viewState);
    };
    UIStateViewService.prototype.removeViewState = function (viewStateName) {
        this.viewStateList = this.viewStateList.filter(function (view) {
            return view.name === viewStateName;
        });
    };
    UIStateViewService.prototype.getViewStateByName = function (viewStateName) {
        var retView;
        this.viewStateList.some(function (view) {
            if (viewStateName === view.name) {
                return !!(retView = view);
            }
        });
        return retView || this.curViewState;
    };
    UIStateViewService._instance = new UIStateViewService();
    return UIStateViewService;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UIStateViewService;

},{"../ui-events":14}],18:[function(require,module,exports){
var UiUtils = (function () {
    function UiUtils() {
    }
    UiUtils.getElementFromHtml = function (html) {
        var div = document.createElement('div');
        div.innerHTML = html.trim();
        return div.firstChild;
    };
    UiUtils.guidGenerator = function () {
        var S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());
    };
    return UiUtils;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UiUtils;

},{}],19:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../../ui-events');
var DOMElement_1 = require('../../DOMElement');
var string_helper_1 = require('../../helpers/string.helper');
var Export = (function (_super) {
    __extends(Export, _super);
    function Export() {
        _super.call(this, "<div id=\"leonardo-export\" class=\"leonardo-export\">");
    }
    Export.prototype.render = function () {
        _super.prototype.render.call(this);
        this.viewNode.innerHTML = "\n      <button id=\"leonardo-copy-clipboard-btn\" class=\"leonardo-button leonardo-export-buttons\" data-clipboard-target=\"#leonardo-exported-code\"> Copy To Clipboard</button>\n      <button id=\"leonardo-download-code-btn\" class=\"leonardo-button leonardo-export-buttons\"> Download Code</button>\n      <div class=\"leonardo-spacer\"></div>\n      <code contenteditable>\n        <div id=\"leonardo-exported-code\" class=\"leonardo-exported-code\">\n            <pre>" + string_helper_1.default.trim(JSON.stringify(Leonardo.getStates(), null, 4)) + "</pre>\n        </div>\n      </code>\n      <a id=\"downloadAnchorElem\" style=\"display:none\"></a>\n    </div>";
        ui_events_1.default.onItem(this.viewNode.querySelector('#leonardo-copy-clipboard-btn'), 'click', this.copyToClipboard.bind(this));
        ui_events_1.default.onItem(this.viewNode.querySelector('#leonardo-download-code-btn'), 'click', this.downloadFile.bind(this));
    };
    Export.prototype.downloadFile = function () {
        var inner = this.viewNode.querySelector('#leonardo-exported-code pre').innerHTML || '';
        var text = string_helper_1.default.trim(inner).replace(/<br>/g, '\r\n');
        var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(text);
        var dlAnchorElem = document.getElementById('downloadAnchorElem');
        dlAnchorElem.setAttribute('href', dataStr);
        dlAnchorElem.setAttribute('download', 'leonardo-states.json');
        dlAnchorElem.click();
    };
    Export.prototype.copyToClipboard = function () {
        var inner = this.viewNode.querySelector('#leonardo-exported-code pre').innerHTML || '';
        var text = string_helper_1.default.trim(inner).replace(/<br>/g, '\r\n');
        if (window.clipboardData && window.clipboardData.setData) {
            return window.clipboardData.setData('Text', text);
        }
        else if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
            var textarea = document.createElement('textarea');
            textarea.textContent = text;
            textarea.style.position = 'fixed';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                return document.execCommand('copy');
            }
            catch (ex) {
                console.warn('Copy to clipboard failed.', ex);
                return false;
            }
            finally {
                document.body.removeChild(textarea);
            }
        }
    };
    Export.prototype.destroy = function () {
    };
    return Export;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Export;

},{"../../DOMElement":6,"../../helpers/string.helper":10,"../../ui-events":14}],20:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_utils_1 = require('../../../ui-utils');
var ui_events_1 = require('../../../ui-events');
var states_detail_1 = require("../state-detail/states-detail");
var DOMElement_1 = require('../../../DOMElement');
var RecorderList = (function (_super) {
    __extends(RecorderList, _super);
    function RecorderList() {
        _super.call(this, "<div id=\"leonardo-recorder-list\" class=\"leonardo-recorder-list\"></div>");
        this.stateDetail = new states_detail_1.default();
        this.stateDetailsState = false;
    }
    RecorderList.prototype.render = function () {
        _super.prototype.render.call(this);
        this.clearEventSubs();
        var list = ui_utils_1.default.getElementFromHtml("<ul class=\"leonardo-recorder-list-container\"></ul>");
        this.getStateItems().forEach(function (item) { list.appendChild(item); });
        this.viewNode.appendChild(list);
        ui_events_1.default.dispatch(ui_events_1.default.ATTACH_MENU_ITEM, this.stateDetail.get());
    };
    RecorderList.prototype.getStateItems = function () {
        var _this = this;
        return Leonardo.getRecordedStates().map(function (state) {
            var item = ui_utils_1.default.getElementFromHtml("<li class=\"leonardo-recorder-list-item\">");
            item.innerHTML =
                "<span class=\"leonardo-recorder-list-verb leonardo-recorder-list-verb-" + state.verb.toLowerCase() + "\">" + state.verb + "</span>\n           <span class=\"leonardo-recorder-list-url\">" + state.url.substr(0, 110) + "</span>";
            item.innerHTML += state.recorded ? "<span class=\"leonardo-recorder-list-name\">" + state.name + "</span>" :
                "<span class=\"leonardo-recorder-list-name leonardo-recorder-list-name-new\">New</span>";
            _this.onItem(item, 'click', _this.toggleDetails.bind(_this, state));
            return item;
        });
    };
    RecorderList.prototype.toggleDetails = function (state, event) {
        this.stateDetailsState = !this.stateDetailsState;
        var selectedClass = 'leonardo-recorder-item-selected';
        this.stateDetailsState ? event.currentTarget.classList.add(selectedClass) : event.currentTarget.classList.remove(selectedClass);
        this.stateDetailsState && (state.activeOption = state.options[0]);
        this.stateDetail.toggle(state);
    };
    return RecorderList;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RecorderList;

},{"../../../DOMElement":6,"../../../ui-events":14,"../../../ui-utils":18,"../state-detail/states-detail":22}],21:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var recorder_list_1 = require('./recorder-list/recorder-list');
var DOMElement_1 = require('../../DOMElement');
var Recorder = (function (_super) {
    __extends(Recorder, _super);
    function Recorder() {
        _super.call(this, "<div id=\"leonardo-recorder\" class=\"leonardo-recorder\"</div>");
        this.recorderList = new recorder_list_1.default();
    }
    Recorder.prototype.render = function () {
        _super.prototype.render.call(this);
        this.viewNode.appendChild(this.recorderList.get());
        this.recorderList.render();
    };
    Recorder.prototype.destroy = function () {
    };
    return Recorder;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Recorder;

},{"../../DOMElement":6,"./recorder-list/recorder-list":20}],22:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../../../ui-events');
var DOMElement_1 = require('../../../DOMElement');
var code_editor_1 = require('../../../code-editor/code-editor');
var RecorderStateDetail = (function (_super) {
    __extends(RecorderStateDetail, _super);
    function RecorderStateDetail() {
        _super.call(this, "<div id=\"leonardo-state-detail\" class=\"leonardo-state-detail-recorder\"></div>");
        this.openState = false;
    }
    RecorderStateDetail.prototype.render = function () {
        _super.prototype.render.call(this);
        var html;
        if (this.curState.recorded) {
            html = "<div class=\"leonardo-states-detail-top\">Add mocked response for <strong>" + this.curState.name + "</strong></div>";
        }
        else {
            html = "<h1 class=\"leonardo-states-detail-top\"/>Add new state</h1>\n              <div class=\"leonardo-states-detail-input\">State name: <input class=\"leonardo-states-detail-state-name\" value=\"" + this.curState.name + "\"/></div>";
        }
        html += "<div class=\"leonardo-states-detail-input\"><div>URL: </div><input class=\"leonardo-states-detail-option-url\" value=\"" + this.curState.url + "\"/></div>\n              <div class=\"leonardo-states-detail-input\"><div>Option name: </div><input class=\"leonardo-states-detail-option-name\" value=\"" + this.curState.options[0].name + "\"/></div>\n              <div class=\"leonardo-states-detail-input\"><div>Status code: </div><input class=\"leonardo-states-detail-status\" value=\"" + this.curState.options[0].status + "\"/></div>\n              <div class=\"leonardo-states-detail-input\"><div>Delay: </div><input class=\"leonardo-states-detail-delay\" value=\"0\"/></div>\n              <br/>\n              <span>Response:</span>    <button class=\"leonardo-button leonardo-states-detail-edit\">Advanced</button> \n              <textarea class=\"leonardo-states-detail-json\">" + this.getResString(this.curState.options[0].data) + "</textarea></p>\n              <div class=\"leonardo-states-detail-buttons\">\n                <button class=\"leonardo-button leonardo-states-detail-save\">Save</button>\n                <button class=\"leonardo-button leonardo-states-detail-cancel\" >Cancel</button>\n              </div>";
        this.viewNode.innerHTML = html;
        ui_events_1.default.onItem(this.viewNode.querySelector('.leonardo-states-detail-edit'), 'click', this.editMode.bind(this));
        ui_events_1.default.onItemOnce(this.viewNode.querySelector('.leonardo-states-detail-cancel'), 'click', this.onCancel.bind(this));
        ui_events_1.default.onItemOnce(this.viewNode.querySelector('.leonardo-states-detail-save'), 'click', this.onSave.bind(this));
    };
    RecorderStateDetail.prototype.open = function (state) {
        this.curState = state;
        this.render();
        this.openState = true;
        ui_events_1.default.dispatch(ui_events_1.default.OPEN_MENU);
    };
    RecorderStateDetail.prototype.editMode = function () {
        var editor = new code_editor_1.default(this.closeEditMode.bind(this), this.closeEditMode.bind(this), this.viewNode.querySelector(".leonardo-states-detail-json").value);
        editor.render();
    };
    RecorderStateDetail.prototype.closeEditMode = function (data) {
        if (!data) {
            return;
        }
        this.viewNode.querySelector(".leonardo-states-detail-json").value = this.getResString(data);
    };
    RecorderStateDetail.prototype.close = function (state) {
        if (state && this.curState !== state) {
            this.open(state);
            return;
        }
        this.openState = false;
        ui_events_1.default.dispatch(ui_events_1.default.CLOSE_MENU);
    };
    RecorderStateDetail.prototype.toggle = function (state) {
        if (this.openState) {
            this.close(state);
            return;
        }
        this.open(state);
    };
    RecorderStateDetail.prototype.getResString = function (resopnse) {
        var resStr;
        try {
            switch (typeof resopnse) {
                case 'function':
                    resStr = resopnse.toString();
                    break;
                case 'object':
                    resStr = JSON.stringify(resopnse, null, 4);
                    break;
                default:
                    return resStr = resopnse;
            }
        }
        catch (e) {
            return resStr;
        }
        return resStr;
    };
    RecorderStateDetail.prototype.onCancel = function (event) {
        this.close();
    };
    RecorderStateDetail.prototype.onSave = function () {
        var urlVal = this.viewNode.querySelector(".leonardo-states-detail-option-url").value;
        var statusVal = this.viewNode.querySelector(".leonardo-states-detail-status").value;
        var delayVal = this.viewNode.querySelector(".leonardo-states-detail-delay").value;
        var jsonVal = this.viewNode.querySelector(".leonardo-states-detail-json").value;
        var optionNameVal = this.viewNode.querySelector(".leonardo-states-detail-option-name").value;
        this.curState.url = urlVal;
        this.curState.activeOption.status = statusVal;
        this.curState.activeOption.delay = delayVal;
        this.curState.activeOption.name = optionNameVal;
        if (!this.curState.recorded) {
            this.curState.name = this.viewNode.querySelector('.leonardo-states-detail-state-name').value;
        }
        try {
            this.curState.activeOption.data = JSON.parse(jsonVal);
        }
        catch (e) {
            this.curState.activeOption.data = jsonVal;
        }
        Leonardo.addOrUpdateSavedState(this.curState);
        this.close();
    };
    return RecorderStateDetail;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RecorderStateDetail;

},{"../../../DOMElement":6,"../../../code-editor/code-editor":7,"../../../ui-events":14}],23:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_utils_1 = require('../../../ui-utils');
var ui_events_1 = require('../../../ui-events');
var DOMElement_1 = require('../../../DOMElement');
var ScenariosList = (function (_super) {
    __extends(ScenariosList, _super);
    function ScenariosList() {
        _super.call(this, "<div id=\"leonardo-scenarios-list\" class=\"leonardo-scenarios-list\"></div>");
        this.bodyEventsSubs.push(ui_events_1.default.on(ui_events_1.default.ADD_SCENARIO, this.addScenario.bind(this)));
    }
    ScenariosList.prototype.render = function () {
        _super.prototype.render.call(this);
        this.clearEventSubs();
        this.viewNode.appendChild(ui_utils_1.default.getElementFromHtml("<div>Scenarios</div>"));
        var ul = ui_utils_1.default.getElementFromHtml("<ul></ul>");
        Leonardo.getScenarios()
            .map(this.getScenarioElement.bind(this))
            .forEach(function (scenarioElm) {
            ul.appendChild(scenarioElm);
        });
        this.viewNode.appendChild(ul);
    };
    ScenariosList.prototype.getScenarioElement = function (scenario) {
        var el = ui_utils_1.default.getElementFromHtml("<li>" + scenario + "</li>");
        this.onItem(el, 'click', this.setScenario.bind(this, scenario, el));
        return el;
    };
    ScenariosList.prototype.setScenario = function (scenario, el) {
        var states = Leonardo.getScenario(scenario);
        ui_events_1.default.dispatch(ui_events_1.default.TOGGLE_STATES, false);
        states.forEach(function (state) {
            ui_events_1.default.dispatch(ui_events_1.default.TOGGLE_STATES + ":" + state.name, state.option);
        });
        Array.prototype.slice.call(this.viewNode.querySelectorAll('li'), 0)
            .forEach(function (li) { return li.classList.remove(ScenariosList.SELECTED_CLASS); });
        el.classList.add(ScenariosList.SELECTED_CLASS);
    };
    ScenariosList.prototype.addScenario = function (event) {
        this.render();
    };
    ScenariosList.SELECTED_CLASS = 'leonardo-selected-scenario';
    return ScenariosList;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ScenariosList;

},{"../../../DOMElement":6,"../../../ui-events":14,"../../../ui-utils":18}],24:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var states_list_1 = require('./states-list/states-list');
var scenarios_list_1 = require('./scenarios-list/scenarios-list');
var DOMElement_1 = require('../../DOMElement');
var Scenarios = (function (_super) {
    __extends(Scenarios, _super);
    function Scenarios() {
        _super.call(this, "<div id=\"leonardo-scenarios\" class=\"leonardo-scenarios\"></div>");
        this.stateList = new states_list_1.default();
        this.scenariosList = new scenarios_list_1.default();
        this.viewNode.appendChild(this.scenariosList.get());
        this.viewNode.appendChild(this.stateList.get());
    }
    Scenarios.prototype.render = function () {
        this.stateList.render();
        this.scenariosList.render();
    };
    Scenarios.prototype.destroy = function () {
    };
    return Scenarios;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Scenarios;

},{"../../DOMElement":6,"./scenarios-list/scenarios-list":23,"./states-list/states-list":29}],25:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../../../../ui-events');
var DOMElement_1 = require('../../../../DOMElement');
var code_editor_1 = require('../../../../code-editor/code-editor');
var StateDetail = (function (_super) {
    __extends(StateDetail, _super);
    function StateDetail(onSaveCB, onCancelCB) {
        _super.call(this, "<div id=\"leonardo-state-detail\" class=\"leonardo-state-detail\"></div>");
        this.onSaveCB = onSaveCB;
        this.onCancelCB = onCancelCB;
        this.openState = false;
    }
    StateDetail.prototype.render = function () {
        _super.prototype.render.call(this);
        this.viewNode.innerHTML = "\n      <div class=\"leonardo-states-detail-container\"> \n        <div class=\"leonardo-states-detail-top\">Edit option <strong>" + this.curState.activeOption.name + "</strong>\n        for <strong>" + this.curState.name + "</strong>\n        </div>\n        \n        <div class=\"leonardo-states-detail-input\"><div>Status code: </div><input class=\"leonardo-states-detail-status\" value=\"" + this.curState.activeOption.status + "\"/></div>\n        <div class=\"leonardo-states-detail-input\"><div>Delay: </div><input class=\"leonardo-states-detail-delay\" value=\"" + this.curState.activeOption.delay + "\"/></div>\n        <div>\n          <br/> \n          <span>Response:</span>    <button class=\"leonardo-button leonardo-states-detail-edit\">Advanced</button>      \n          <textarea class=\"leonardo-states-detail-json\">" + this.getResString(this.curState.activeOption.data) + "</textarea>          \n        </div>\n        <div class=\"leonardo-states-detail-buttons\">        \n          <button class=\"leonardo-button leonardo-states-detail-save\">Save</button>\n          <button class=\"leonardo-button leonardo-states-detail-cancel\" >Cancel</button>\n        </div>";
        ui_events_1.default.onItem(this.viewNode.querySelector('.leonardo-states-detail-edit'), 'click', this.editMode.bind(this));
        ui_events_1.default.onItemOnce(this.viewNode.querySelector('.leonardo-states-detail-cancel'), 'click', this.onCancel.bind(this));
        ui_events_1.default.onItemOnce(this.viewNode.querySelector('.leonardo-states-detail-save'), 'click', this.onSave.bind(this));
    };
    StateDetail.prototype.open = function (state) {
        this.curState = state;
        this.render();
        this.openState = true;
        ui_events_1.default.dispatch(ui_events_1.default.OPEN_MENU);
    };
    StateDetail.prototype.close = function (state) {
        if (state && this.curState !== state) {
            this.open(state);
            return;
        }
        this.openState = false;
        ui_events_1.default.dispatch(ui_events_1.default.CLOSE_MENU);
    };
    StateDetail.prototype.toggle = function (state) {
        if (this.openState) {
            this.close(state);
            return;
        }
        this.open(state);
    };
    StateDetail.prototype.editMode = function () {
        var editor = new code_editor_1.default(this.closeEditMode.bind(this), this.closeEditMode.bind(this), this.viewNode.querySelector(".leonardo-states-detail-json").value);
        editor.render();
    };
    StateDetail.prototype.closeEditMode = function (data) {
        if (!data) {
            return;
        }
        this.viewNode.querySelector(".leonardo-states-detail-json").value = this.getResString(data);
    };
    StateDetail.prototype.getResString = function (resopnse) {
        var resStr;
        try {
            switch (typeof resopnse) {
                case 'function':
                    resStr = resopnse.toString();
                    break;
                case 'object':
                    resStr = JSON.stringify(resopnse, null, 4);
                    break;
                default:
                    return resStr = resopnse;
            }
        }
        catch (e) {
            return resStr;
        }
        return resStr;
    };
    StateDetail.prototype.onCancel = function () {
        this.close();
        this.onCancelCB();
    };
    StateDetail.prototype.onSave = function () {
        var statusVal = this.viewNode.querySelector(".leonardo-states-detail-status").value;
        var delayVal = this.viewNode.querySelector(".leonardo-states-detail-delay").value;
        var jsonVal = this.viewNode.querySelector(".leonardo-states-detail-json").value;
        this.curState.activeOption.status = statusVal;
        this.curState.activeOption.delay = delayVal;
        try {
            if (jsonVal.trim().indexOf('function') === 0) {
                this.curState.activeOption.data = eval('(' + jsonVal + ')');
            }
            else {
                this.curState.activeOption.data = JSON.parse(jsonVal);
            }
        }
        catch (e) {
            this.curState.activeOption.data = jsonVal;
        }
        Leonardo.addOrUpdateSavedState(this.curState);
        this.close();
        this.onSaveCB();
    };
    return StateDetail;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StateDetail;

},{"../../../../DOMElement":6,"../../../../code-editor/code-editor":7,"../../../../ui-events":14}],26:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_utils_1 = require('../../../../ui-utils');
var ui_events_1 = require('../../../../ui-events');
var drop_down_1 = require('../../../../drop-down/drop-down');
var DOMElement_1 = require('../../../../DOMElement');
var StateItem = (function (_super) {
    __extends(StateItem, _super);
    function StateItem(state, onRemove) {
        _super.call(this, "<div class=\"leonardo-state-item\"></div>");
        this.state = state;
        this.onRemove = onRemove;
        this.randomID = ui_utils_1.default.guidGenerator();
        this.dropDown = new drop_down_1.default(this.state.options, this.state.activeOption || this.state.options[0], !this.state.active, this.changeActiveOption.bind(this), this.removeOption.bind(this));
        this.bodyEventsSubs.push(ui_events_1.default.on(ui_events_1.default.TOGGLE_STATES, this.toggleAllstate.bind(this)));
        this.bodyEventsSubs.push(ui_events_1.default.on(ui_events_1.default.TOGGLE_STATES + ":" + this.state.name, this.setStateState.bind(this)));
    }
    StateItem.prototype.render = function () {
        _super.prototype.render.call(this);
        this.viewNode.innerHTML = "\n        <input " + this.isChecked() + " id=\"leonardo-state-toggle-" + this.randomID + "\" class=\"leonardo-toggle leonardo-toggle-ios\" type=\"checkbox\"/>\n        <label class=\"leonardo-toggle-btn\" for=\"leonardo-state-toggle-" + this.randomID + "\"></label>\n        <span class=\"leonardo-state-verb leonardo-state-verb-" + this.state.verb.toLowerCase() + "\">" + this.state.verb + "</span>\n        <span class=\"leonardo-state-data-container\">\n          <span class=\"leonardo-state-name\">" + this.state.name + "</span>\n          <span class=\"leonardo-state-url\">" + (this.state.url || '') + "</span>\n        </span>";
        this.viewNode.appendChild(this.dropDown.get());
        this.dropDown.render();
        this.viewNode.appendChild(ui_utils_1.default.getElementFromHtml("<div title=\"Remove State\" class=\"leonardo-x-btn leonardo-state-remove\"></div>"));
        this.onItem(this.viewNode.querySelector(".leonardo-toggle-btn"), 'click', this.toggleState.bind(this));
        ui_events_1.default.onItemOnce(this.viewNode.querySelector(".leonardo-state-remove"), 'click', this.removeState.bind(this));
    };
    StateItem.prototype.getName = function () {
        return this.state.name;
    };
    StateItem.prototype.getState = function () {
        return this.state;
    };
    StateItem.prototype.toggleVisible = function (show) {
        if (show) {
            this.viewNode.classList.remove('leonardo-state-item-hidden');
        }
        else {
            this.viewNode.classList.add('leonardo-state-item-hidden');
        }
    };
    StateItem.prototype.setState = function (state, setView) {
        if (setView === void 0) { setView = true; }
        this.state.active = state;
        if (state) {
            Leonardo.activateStateOption(this.state.name, this.state.activeOption.name);
            this.dropDown.enableDropDown();
            if (setView) {
                this.viewNode.querySelector('.leonardo-toggle')['checked'] = true;
            }
        }
        else {
            Leonardo.deactivateState(this.state.name);
            this.dropDown.disableDropDown();
            if (setView) {
                this.viewNode.querySelector('.leonardo-toggle')['checked'] = false;
            }
        }
    };
    StateItem.prototype.isChecked = function () {
        return this.state.active ? 'checked' : '';
    };
    StateItem.prototype.toggleState = function (event) {
        this.setState(!this.state.active, false);
    };
    StateItem.prototype.toggleAllstate = function (event) {
        this.setState(event.detail);
    };
    StateItem.prototype.setStateState = function (event) {
        var _this = this;
        this.setState(true);
        this.state.options.some(function (option) {
            if (option.name === event.detail) {
                _this.dropDown.setActiveItem(event.detail);
                _this.changeActiveOption(option);
                return true;
            }
        });
    };
    StateItem.prototype.changeActiveOption = function (option) {
        this.state.activeOption = option;
        Leonardo.activateStateOption(this.state.name, this.state.activeOption.name);
    };
    StateItem.prototype.removeState = function (event) {
        if (event) {
            event.stopPropagation();
        }
        this.onRemove(this.state.name, this.viewNode);
        Leonardo.removeState(this.state);
        this.destroy();
    };
    StateItem.prototype.removeOption = function (item) {
        Leonardo.removeOption(this.state, item);
    };
    return StateItem;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StateItem;

},{"../../../../DOMElement":6,"../../../../drop-down/drop-down":8,"../../../../ui-events":14,"../../../../ui-utils":18}],27:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../../../../../ui-events');
var DOMElement_1 = require('../../../../../DOMElement');
var AddScenario = (function (_super) {
    __extends(AddScenario, _super);
    function AddScenario() {
        _super.call(this, "<div id=\"leonardo-add-scenario\" class=\"leonardo-add-scenario\"></div>");
        this.openState = false;
    }
    AddScenario.prototype.render = function () {
        _super.prototype.render.call(this);
        this.clearEventSubs();
        this.viewNode.innerHTML = "\n        <div class=\"leonardo-add-scenario-box\">\n          <span>Scenario Name: </span>\n          <input class=\"leonardo-add-scenario-name\"/>\n          <button class=\"leonardo-button leonardo-add-scenario-save\">Save</button>\n          <button class=\"leonardo-button leonardo-add-scenario-cancel\">Cancel</button>\n        </div>";
        this.onItem(this.viewNode.querySelector('.leonardo-add-scenario-cancel'), 'click', this.onCancel.bind(this));
        this.onItem(this.viewNode.querySelector('.leonardo-add-scenario-save'), 'click', this.onSave.bind(this));
    };
    AddScenario.prototype.open = function () {
        this.render();
        this.openState = true;
        this.viewNode.style.display = 'block';
    };
    AddScenario.prototype.close = function () {
        this.openState = false;
        this.viewNode.style.display = 'none';
    };
    AddScenario.prototype.toggle = function () {
        if (this.openState) {
            this.close();
            return;
        }
        this.open();
    };
    AddScenario.prototype.onCancel = function () {
        this.close();
    };
    AddScenario.prototype.onSave = function () {
        this.close();
        ui_events_1.default.dispatch(ui_events_1.default.ADD_SCENARIO, this.viewNode.querySelector('.leonardo-add-scenario-name').value);
    };
    return AddScenario;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AddScenario;

},{"../../../../../DOMElement":6,"../../../../../ui-events":14}],28:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../../../../ui-events');
var state_add_scenario_1 = require('./state-add-scenario/state-add-scenario');
var DOMElement_1 = require('../../../../DOMElement');
var StatesBar = (function (_super) {
    __extends(StatesBar, _super);
    function StatesBar() {
        _super.call(this, "<div class=\"leonardo-states-bar\"></div>");
        this.activeAllState = false;
        this.addScenario = new state_add_scenario_1.default();
        this.curSearchData = '';
    }
    StatesBar.prototype.render = function () {
        _super.prototype.render.call(this);
        this.clearEventSubs();
        this.viewNode.innerHTML = "\n        <input value=\"" + this.curSearchData + "\" class=\"leonardo-search-state\" name=\"leonardo-search-state\" type=\"text\" placeholder=\"Search...\" />\n        <div>\n          <span class=\"leonardo-button leonardo-activate-all\">Activate All</span>\n          <span class=\"leonardo-button leonardo-add-scenario-btn\">Add Scenario</span>\n        </div>";
        this.viewNode.appendChild(this.addScenario.get());
        this.addScenario.render();
        this.onItem(this.viewNode.querySelector('.leonardo-search-state'), 'keyup', this.searchStates.bind(this));
        this.onItem(this.viewNode.querySelector('.leonardo-activate-all'), 'click', this.toggleActivateAll.bind(this));
        this.onItem(this.viewNode.querySelector('.leonardo-add-scenario-btn'), 'click', this.onAddScenario.bind(this));
        this.searchStates({ target: { value: this.curSearchData } });
    };
    StatesBar.prototype.searchStates = function (evt) {
        this.curSearchData = evt.target.value;
        ui_events_1.default.dispatch(ui_events_1.default.FILTER_STATES, { val: this.curSearchData });
    };
    StatesBar.prototype.toggleActivateAll = function () {
        this.activeAllState = !this.activeAllState;
        Leonardo.toggleActivateAll(this.activeAllState);
        ui_events_1.default.dispatch(ui_events_1.default.TOGGLE_STATES, this.activeAllState);
        this.viewNode.querySelector('.leonardo-activate-all')['innerHTML'] = this.activeAllState ? 'Deactivate all' : 'Activate all';
    };
    StatesBar.prototype.onAddScenario = function () {
        this.addScenario.open();
    };
    return StatesBar;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StatesBar;

},{"../../../../DOMElement":6,"../../../../ui-events":14,"./state-add-scenario/state-add-scenario":27}],29:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ui_events_1 = require('../../../ui-events');
var state_item_1 = require('./state-item/state-item');
var states_bar_1 = require('./states-bar/states-bar');
var states_detail_1 = require('./state-detail/states-detail');
var DOMElement_1 = require('../../../DOMElement');
var StatesList = (function (_super) {
    __extends(StatesList, _super);
    function StatesList() {
        _super.call(this, "<div id=\"leonardo-states-list\" class=\"leonardo-states-list\"></div>");
        this.statesBar = new states_bar_1.default();
        this.stateDetail = new states_detail_1.default(this.onStateDetailSave.bind(this), this.clearSelected.bind(this));
        this.statesElements = [];
        this.bodyEventSubs = [];
        this.bodyEventSubs.push(ui_events_1.default.on(ui_events_1.default.FILTER_STATES, this.onFilterStates.bind(this)));
        this.bodyEventSubs.push(ui_events_1.default.on(ui_events_1.default.ADD_SCENARIO, this.addScenario.bind(this)));
    }
    StatesList.prototype.render = function () {
        var _this = this;
        _super.prototype.render.call(this);
        this.clearEventSubs();
        this.viewNode.appendChild(this.statesBar.get());
        ui_events_1.default.dispatch(ui_events_1.default.ATTACH_MENU_ITEM, this.stateDetail.get());
        this.statesElements.length = 0;
        Leonardo.getStates()
            .map(function (state) { return new state_item_1.default(state, _this.removeStateByName.bind(_this)); })
            .forEach(function (stateElm) {
            _this.statesElements.push(stateElm);
            _this.viewNode.appendChild(stateElm.get());
            _this.onItem(stateElm.get(), 'click', _this.toggleDetail.bind(_this, stateElm));
            stateElm.render();
        });
        this.statesBar.render();
    };
    StatesList.prototype.onFilterStates = function (data) {
        this.statesElements.forEach(function (stateElm) {
            if (stateElm.getName().toLowerCase().indexOf(data.detail.val.toLowerCase()) >= 0) {
                stateElm.toggleVisible(true);
            }
            else {
                stateElm.toggleVisible(false);
            }
        });
    };
    StatesList.prototype.removeStateByName = function (stateName, stateView) {
        this.statesElements = this.statesElements.filter(function (state) {
            return state.getName() !== stateName;
        });
        this.viewNode.removeChild(stateView);
    };
    StatesList.prototype.toggleDetail = function (stateElm, event) {
        event.stopPropagation();
        var open = stateElm.get().classList.contains('leonardo-state-item-detailed');
        this.clearSelected();
        if (!open) {
            stateElm.get().classList.add('leonardo-state-item-detailed');
        }
        this.stateDetail.toggle(stateElm.getState());
    };
    StatesList.prototype.clearSelected = function () {
        this.statesElements.forEach(function (curState) {
            curState.get().classList.remove('leonardo-state-item-detailed');
        });
    };
    StatesList.prototype.onStateDetailSave = function () {
        this.clearSelected();
    };
    StatesList.prototype.addScenario = function (event) {
        var states = this.statesElements.map(function (stateElem) {
            return stateElem.getState();
        }).filter(function (state) { return state.active; })
            .map(function (state) {
            return {
                name: state.name,
                option: state.activeOption.name
            };
        });
        Leonardo.addScenario({
            name: event.detail,
            states: states,
            from_local: true
        }, true);
    };
    StatesList.prototype.destroy = function () {
        this.clearSetEventSubs(this.bodyEventSubs);
    };
    return StatesList;
})(DOMElement_1.default);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StatesList;

},{"../../../DOMElement":6,"../../../ui-events":14,"./state-detail/states-detail":25,"./state-item/state-item":26,"./states-bar/states-bar":28}],30:[function(require,module,exports){
var Utils = (function () {
    function Utils() {
    }
    Utils.isUndefined = function (value) {
        return typeof value === 'undefined';
    };
    Utils.isNumber = function (value) {
        return typeof value === 'number';
    };
    Utils.isFunction = function (value) {
        return typeof value === 'function';
    };
    Utils.isString = function (value) {
        return typeof value === 'string';
    };
    Utils.fromJson = function (json) {
        return this.isString(json)
            ? JSON.parse(json)
            : json;
    };
    Utils.toJson = function (obj, pretty) {
        if (this.isUndefined(obj))
            return undefined;
        if (!this.isNumber(pretty)) {
            pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, null, pretty);
    };
    return Utils;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Utils;

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvbGVvbmFyZG8vY29uZmlndXJhdGlvbi5zcnYudHMiLCJzcmMvbGVvbmFyZG8vbGVvbmFyZG8udHMiLCJzcmMvbGVvbmFyZG8vcG9seWZpbGxzLnRzIiwic3JjL2xlb25hcmRvL3Npbm9uLnNydi50cyIsInNyYy9sZW9uYXJkby9zdG9yYWdlLnNydi50cyIsInNyYy9sZW9uYXJkby91aS9ET01FbGVtZW50LnRzIiwic3JjL2xlb25hcmRvL3VpL2NvZGUtZWRpdG9yL2NvZGUtZWRpdG9yLnRzIiwic3JjL2xlb25hcmRvL3VpL2Ryb3AtZG93bi9kcm9wLWRvd24udHMiLCJzcmMvbGVvbmFyZG8vdWkvaGVhZGVyL2hlYWRlci50cyIsInNyYy9sZW9uYXJkby91aS9oZWxwZXJzL3N0cmluZy5oZWxwZXIudHMiLCJzcmMvbGVvbmFyZG8vdWkvbGF1bmNoZXIvbGF1bmNoZXIudHMiLCJzcmMvbGVvbmFyZG8vdWkvbWFpbi12aWV3L21haW4tdmlldy50cyIsInNyYy9sZW9uYXJkby91aS9tYWluLXZpZXcvdmlld3MtY29udGFpbmVyL3ZpZXdzLWNvbnRhaW5lci50cyIsInNyYy9sZW9uYXJkby91aS91aS1ldmVudHMudHMiLCJzcmMvbGVvbmFyZG8vdWkvdWktcm9vdC50cyIsInNyYy9sZW9uYXJkby91aS91aS1zdGF0ZS91aS1zdGF0ZS5kYXRhLnRzIiwic3JjL2xlb25hcmRvL3VpL3VpLXN0YXRlL3VpLXN0YXRlLnNydi50cyIsInNyYy9sZW9uYXJkby91aS91aS11dGlscy50cyIsInNyYy9sZW9uYXJkby91aS92aWV3cy9leHBvcnQvZXhwb3J0LnRzIiwic3JjL2xlb25hcmRvL3VpL3ZpZXdzL3JlY29yZGVyL3JlY29yZGVyLWxpc3QvcmVjb3JkZXItbGlzdC50cyIsInNyYy9sZW9uYXJkby91aS92aWV3cy9yZWNvcmRlci9yZWNvcmRlci50cyIsInNyYy9sZW9uYXJkby91aS92aWV3cy9yZWNvcmRlci9zdGF0ZS1kZXRhaWwvc3RhdGVzLWRldGFpbC50cyIsInNyYy9sZW9uYXJkby91aS92aWV3cy9zY2VuYXJpb3Mvc2NlbmFyaW9zLWxpc3Qvc2NlbmFyaW9zLWxpc3QudHMiLCJzcmMvbGVvbmFyZG8vdWkvdmlld3Mvc2NlbmFyaW9zL3NjZW5hcmlvcy50cyIsInNyYy9sZW9uYXJkby91aS92aWV3cy9zY2VuYXJpb3Mvc3RhdGVzLWxpc3Qvc3RhdGUtZGV0YWlsL3N0YXRlcy1kZXRhaWwudHMiLCJzcmMvbGVvbmFyZG8vdWkvdmlld3Mvc2NlbmFyaW9zL3N0YXRlcy1saXN0L3N0YXRlLWl0ZW0vc3RhdGUtaXRlbS50cyIsInNyYy9sZW9uYXJkby91aS92aWV3cy9zY2VuYXJpb3Mvc3RhdGVzLWxpc3Qvc3RhdGVzLWJhci9zdGF0ZS1hZGQtc2NlbmFyaW8vc3RhdGUtYWRkLXNjZW5hcmlvLnRzIiwic3JjL2xlb25hcmRvL3VpL3ZpZXdzL3NjZW5hcmlvcy9zdGF0ZXMtbGlzdC9zdGF0ZXMtYmFyL3N0YXRlcy1iYXIudHMiLCJzcmMvbGVvbmFyZG8vdWkvdmlld3Mvc2NlbmFyaW9zL3N0YXRlcy1saXN0L3N0YXRlcy1saXN0LnRzIiwic3JjL2xlb25hcmRvL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDRUE7SUFDRSxJQUFJLE9BQU8sR0FBRyxFQUFFLEVBQ2QsVUFBVSxHQUFHLEVBQUUsRUFDZixZQUFZLEdBQUcsRUFBRSxFQUNqQixZQUFZLEdBQUcsRUFBRSxFQUNqQixtQkFBbUIsR0FBRyxJQUFJLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxFQUMzRCxXQUFXLEdBQUcsUUFBUSxDQUFDLElBQUksRUFDM0IsZUFBZSxHQUFHLEVBQUUsQ0FBQztJQUl2QixNQUFNLENBQUM7UUFDTCxRQUFRLEVBQUUsUUFBUTtRQUNsQixTQUFTLEVBQUUsU0FBUztRQUNwQixvQkFBb0IsRUFBRSxvQkFBb0I7UUFDMUMsU0FBUyxFQUFFLFdBQVc7UUFDdEIsZUFBZSxFQUFFLGVB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USxHQUFmLFVBQWdCLEtBQUs7UUFDbkIsTUFBTSxDQUFDLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztJQUNuQyxDQUFDO0lBRU0sZ0JBQVUsR0FBakIsVUFBa0IsS0FBSztRQUNyQixNQUFNLENBQUMsT0FBTyxLQUFLLEtBQUssVUFBVSxDQUFDO0lBQ3JDLENBQUM7SUFFTSxjQUFRLEdBQWYsVUFBZ0IsS0FBSztRQUNuQixNQUFNLENBQUMsT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDO0lBQ25DLENBQUM7SUFFTSxjQUFRLEdBQWYsVUFBZ0IsSUFBSTtRQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7Y0FDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7Y0FDaEIsSUFBSSxDQUFDO0lBQ1gsQ0FBQztJQUVNLFlBQU0sR0FBYixVQUFjLEdBQUcsRUFBRSxNQUFPO1FBQ3hCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7WUFBQyxNQUFNLENBQUMsU0FBUyxDQUFDO1FBQzVDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0IsTUFBTSxHQUFHLE1BQU0sR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQzdCLENBQUM7UUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFDSCxZQUFDO0FBQUQsQ0FqQ0EsQUFpQ0MsSUFBQTtBQWpDRDt1QkFpQ0MsQ0FBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwibGVvbmFyZG8uZC50c1wiIC8+XG5kZWNsYXJlIHZhciBPYmplY3Q6IGFueTtcbmV4cG9ydCBmdW5jdGlvbiBsZW9Db25maWd1cmF0aW9uKCkge1xuICB2YXIgX3N0YXRlcyA9IFtdLFxuICAgIF9zY2VuYXJpb3MgPSB7fSxcbiAgICBfcmVxdWVzdHNMb2cgPSBbXSxcbiAgICBfc2F2ZWRTdGF0ZXMgPSBbXSxcbiAgICBfc3RhdGVzQ2hhbmdlZEV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdsZW9uYXJkbzpzZXRTdGF0ZXMnKSxcbiAgICBfZXZlbnRzRWxlbSA9IGRvY3VtZW50LmJvZHksXG4gICAgX2pzb25wQ2FsbGJhY2tzID0ge307XG5cbiAgLy8gQ29yZSBBUElcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuICByZXR1cm4ge1xuICAgIGFkZFN0YXRlOiBhZGRTdGF0ZSxcbiAgICBhZGRTdGF0ZXM6IGFkZFN0YXRlcyxcbiAgICBnZXRBY3RpdmVTdGF0ZU9wdGlvbjogZ2V0QWN0aXZlU3RhdGVPcHRpb24sXG4gICAgZ2V0U3RhdGVzOiBmZXRjaFN0YXRlcyxcbiAgICBkZWFjdGl2YXRlU3RhdGU6IGRlYWN0aXZhdGVTdGF0ZSxcbiAgICB0b2dnbGVBY3RpdmF0ZUFsbDogdG9nZ2xlQWN0aXZhdGVBbGwsXG4gICAgYWN0aXZhdGVTdGF0ZU9wdGlvbjogYWN0aXZhdGVTdGF0ZU9wdGlvbixcbiAgICBhZGRTY2VuYXJpbzogYWRkU2NlbmFyaW8sXG4gICAgYWRkU2NlbmFyaW9zOiBhZGRTY2VuYXJpb3MsXG4gICAgZ2V0U2NlbmFyaW86IGdldFNjZW5hcmlvLFxuICAgIGdldFNjZW5hcmlvczogZ2V0U2NlbmFyaW9zLFxuICAgIHNldEFjdGl2ZVNjZW5hcmlvOiBzZXRBY3RpdmVTY2VuYXJpbyxcbiAgICBnZXRSZWNvcmRlZFN0YXRlczogZ2V0UmVjb3JkZWRTdGF0ZXMsXG4gICAgZ2V0UmVxdWVzdHNMb2c6IGdldFJlcXVlc3RzTG9nLFxuICAgIGxvYWRTYXZlZFN0YXRlczogbG9hZFNhdmVkU3RhdGVzLFxuICAgIGFkZFNhdmVkU3RhdGU6IGFkZFNhdmVkU3RhdGUsXG4gICAgYWRkT3JVcGRhdGVTYXZlZFN0YXRlOiBhZGRPclVwZGF0ZVNhdmVkU3RhdGUsXG4gICAgZmV0Y2hTdGF0ZXNCeVVybEFuZE1ldGhvZDogZmV0Y2hTdGF0ZXNCeVVybEFuZE1ldGhvZCxcbiAgICByZW1vdmVTdGF0ZTogcmVtb3ZlU3RhdGUsXG4gICAgcmVtb3ZlT3B0aW9uOiByZW1vdmVPcHRpb24sXG4gICAgb25TdGF0ZUNoYW5nZTogb25TZXRTdGF0ZXMsXG4gICAgc3RhdGVzQ2hhbmdlZDogc3RhdGVzQ2hhbmdlZCxcbiAgICBfbG9nUmVxdWVzdDogbG9nUmVxdWVzdCxcbiAgICBfanNvbnBDYWxsYmFja3M6IF9qc29ucENhbGxiYWNrc1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gdXBzZXJ0T3B0aW9uKHN0YXRlLCBuYW1lLCBhY3RpdmUpIHtcbiAgICB2YXIgc3RhdGVzU3RhdHVzID0gTGVvbmFyZG8uc3RvcmFnZS5nZXRTdGF0ZXMoKTtcbiAgICBzdGF0ZXNTdGF0dXNbc3RhdGVdID0ge1xuICAgICAgbmFtZTogbmFtZSB8fCBmaW5kU3RhdGVPcHRpb24oc3RhdGUpLm5hbWUsXG4gICAgICBhY3RpdmU6IGFjdGl2ZVxuICAgIH07XG5cbiAgICBMZW9uYXJkby5zdG9yYWdlLnNldFN0YXRlcyhzdGF0ZXNTdGF0dXMpO1xuICAgIHNldHVwSnNvbnBGb3JTdGF0ZShzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cEpzb25wRm9yU3RhdGUoc3RhdGVOYW1lKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBmZXRjaFN0YXRlKHN0YXRlTmFtZSk7XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnZlcmIgPT09ICdKU09OUCcpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrTmFtZSA9IGdldENhbGxiYWNrTmFtZShzdGF0ZSk7XG4gICAgICBzdGF0ZS5hY3RpdmUgPyBhY3RpdmVKc29ucFN0YXRlKHN0YXRlLCBjYWxsYmFja05hbWUpIDogZGVhY3RpdmF0ZUpzb25wU3RhdGUoc3RhdGUsIGNhbGxiYWNrTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZlSnNvbnBTdGF0ZShzdGF0ZSwgY2FsbGJhY2tOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmdW5jTmFtZSA9IHN0YXRlLm5hbWUgKyBjYWxsYmFja05hbWU7XG4gICAgaWYgKF9qc29ucENhbGxiYWNrc1tmdW5jTmFtZV0pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHdpbmRvd1tjYWxsYmFja05hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfanNvbnBDYWxsYmFja3NbZnVuY05hbWVdID0gd2luZG93W2NhbGxiYWNrTmFtZV07XG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGR1bW15SnNvbnBDYWxsYmFjaztcbiAgICB9XG4gICAgYWN0aXZhdGVKc29ucE1PYnNlcnZlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGVKc29ucE1PYnNlcnZlcigpIHtcbiAgICBpZiAoTGVvbmFyZG8uX2pzb25wTXV0YXRpb25PYnNlcnZlcnMpIHtcbiAgICAgIGlmICghZmV0Y2hTdGF0ZXMoKS5zb21lKHN0YXRlID0+IHN0YXRlLnZlcmIgPT09ICdKU09OUCcgJiYgc3RhdGUuYWN0aXZlKSkge1xuICAgICAgICBMZW9uYXJkby5fanNvbnBNdXRhdGlvbk9ic2VydmVycy5mb3JFYWNoKG11dGF0aW9uT2JzZXJ2ZXIgPT4gbXV0YXRpb25PYnNlcnZlciAmJiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKSk7XG4gICAgICAgIGRlbGV0ZSBMZW9uYXJkby5fanNvbnBDYWxsYmFja3M7XG4gICAgICAgIGRlbGV0ZSBMZW9uYXJkby5fanNvbnBNdXRhdGlvbk9ic2VydmVycztcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0cyA9IFtkb2N1bWVudC5ib2R5LCBkb2N1bWVudC5oZWFkXS5maWx0ZXIodGFyZ2V0ID0+ICEhdGFyZ2V0KTtcbiAgICBjb25zdCBjb25maWcgPSB7YXR0cmlidXRlczogZmFsc2UsIGNoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogZmFsc2UsIHN1YnRyZWU6IGZhbHNlfTtcblxuICAgIExlb25hcmRvLl9qc29ucE11dGF0aW9uT2JzZXJ2ZXJzID0gdGFyZ2V0cy5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uOiBhbnkpIHtcbiAgICAgICAgICBpZiAobXV0YXRpb24uYWRkZWROb2RlcyAmJlxuICAgICAgICAgICAgbXV0YXRpb24uYWRkZWROb2Rlc1swXSAmJlxuICAgICAgICAgICAgbXV0YXRpb24uYWRkZWROb2Rlc1swXS50YWdOYW1lICYmXG4gICAgICAgICAgICBtdXRhdGlvbi5hZGRlZE5vZGVzWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdE5vZGUgPSBtdXRhdGlvbi5hZGRlZE5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKHNjcmlwdE5vZGUuc3JjICYmIHNjcmlwdE5vZGUuc3JjLmluZGV4T2YoJ2NhbGxiYWNrJykgPiAwKSB7XG4gICAgICAgICAgICAgIGxvZ1JlcXVlc3QoJ0pTT05QJywgc2NyaXB0Tm9kZS5zcmMsIHt9LCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBmZXRjaFN0YXRlc0J5VXJsQW5kTWV0aG9kKHNjcmlwdE5vZGUuc3JjLCAnSlNPTlAnKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tOYW1lID0gZ2V0Q2FsbGJhY2tOYW1lKHN0YXRlKTtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY05hbWUgPSBzdGF0ZS5uYW1lICsgY2FsbGJhY2tOYW1lO1xuICAgICAgICAgICAgICBpZiAoIV9qc29ucENhbGxiYWNrc1tmdW5jTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVKc29ucFN0YXRlKHN0YXRlLCBjYWxsYmFja05hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoX2pzb25wQ2FsbGJhY2tzW2Z1bmNOYW1lXS5iaW5kKG51bGwsIHN0YXRlLmFjdGl2ZU9wdGlvbi5kYXRhKSwgc3RhdGUuYWN0aXZlT3B0aW9uLmRlbGF5IHx8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCwgaW5kZXgpID0+IExlb25hcmRvLl9qc29ucE11dGF0aW9uT2JzZXJ2ZXJzW2luZGV4XS5vYnNlcnZlKHRhcmdldCwgY29uZmlnKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkdW1teUpzb25wQ2FsbGJhY2soKSB7XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlSnNvbnBTdGF0ZShzdGF0ZSwgY2FsbGJhY2tOYW1lKSB7XG4gICAgY29uc3QgZnVuY05hbWUgPSBzdGF0ZS5uYW1lICsgY2FsbGJhY2tOYW1lO1xuICAgIGlmIChfanNvbnBDYWxsYmFja3NbZnVuY05hbWVdKSB7XG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IF9qc29ucENhbGxiYWNrc1tmdW5jTmFtZV07XG4gICAgICBkZWxldGUgX2pzb25wQ2FsbGJhY2tzW2Z1bmNOYW1lXTtcbiAgICB9XG4gICAgYWN0aXZhdGVKc29ucE1PYnNlcnZlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2tOYW1lKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmpzb25wQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBzdGF0ZS5qc29ucENhbGxiYWNrO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc3RmaXggPSBzdGF0ZS51cmwuc3BsaXQoJ2NhbGxiYWNrPScpWzFdO1xuICAgIHJldHVybiBwb3N0Zml4LnNwbGl0KCcmJylbMF07XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaFN0YXRlc0J5VXJsQW5kTWV0aG9kKHVybCwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZldGNoU3RhdGVzKCkuZmlsdGVyKChzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIHN0YXRlLnVybCAmJlxuICAgICAgICAobmV3IFJlZ0V4cChzdGF0ZS51cmwpLnRlc3QodXJsKSB8fCBzdGF0ZS51cmwgPT09IHVybCkgJiZcbiAgICAgICAgc3RhdGUudmVyYi50b0xvd2VyQ2FzZSgpID09PSBtZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAgIH0pWzBdO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hTdGF0ZXMoKSB7XG4gICAgdmFyIGFjdGl2ZVN0YXRlcyA9IExlb25hcmRvLnN0b3JhZ2UuZ2V0U3RhdGVzKCk7XG4gICAgdmFyIHN0YXRlc0NvcHkgPSBfc3RhdGVzLm1hcChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgfSk7XG5cbiAgICBzdGF0ZXNDb3B5LmZvckVhY2goZnVuY3Rpb24gKHN0YXRlOiBhbnkpIHtcbiAgICAgIHZhciBvcHRpb24gPSBhY3RpdmVTdGF0ZXNbc3RhdGUubmFtZV07XG4gICAgICBzdGF0ZS5hY3RpdmUgPSAhIW9wdGlvbiAmJiBvcHRpb24uYWN0aXZlO1xuICAgICAgc3RhdGUuYWN0aXZlT3B0aW9uID0gISFvcHRpb24gP1xuICAgICAgICBzdGF0ZS5vcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoX29wdGlvbikge1xuICAgICAgICAgIHJldHVybiBfb3B0aW9uLm5hbWUgPT09IG9wdGlvbi5uYW1lO1xuICAgICAgICB9KVswXSA6IHN0YXRlLm9wdGlvbnNbMF07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RhdGVzQ29weTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoU3RhdGUobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZldGNoU3RhdGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLm5hbWUgPT09IG5hbWU7XG4gICAgfSlbMF07XG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVBY3RpdmF0ZUFsbChmbGFnOiBib29sZWFuKSB7XG4gICAgbGV0IHN0YXRlc1N0YXR1cyA9IGZldGNoU3RhdGVzKCk7XG4gICAgY29uc3Qgc3RhdHVzZXMgPSBzdGF0ZXNTdGF0dXMucmVkdWNlKChvYmosIHMpID0+IHtcbiAgICAgICAgdmFyIG9wdGlvbk5hbWUgPSBzLmFjdGl2ZU9wdGlvbiA/IHMuYWN0aXZlT3B0aW9uLm5hbWUgOiBzLm9wdGlvbnNbMF0ubmFtZTtcbiAgICAgICAgb2JqW3MubmFtZV0gPSB7bmFtZTogb3B0aW9uTmFtZSwgYWN0aXZlOiBmbGFnfTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICAgICwge30pO1xuICAgIExlb25hcmRvLnN0b3JhZ2Uuc2V0U3RhdGVzKHN0YXR1c2VzKTtcbiAgICByZXR1cm4gc3RhdGVzU3RhdHVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFN0YXRlT3B0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZmV0Y2hTdGF0ZXMoKS5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUubmFtZSA9PT0gbmFtZTtcbiAgICB9KVswXS5hY3RpdmVPcHRpb247XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBY3RpdmVTdGF0ZU9wdGlvbihuYW1lKSB7XG4gICAgdmFyIHN0YXRlID0gZmV0Y2hTdGF0ZXMoKS5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUubmFtZSA9PT0gbmFtZVxuICAgIH0pWzBdO1xuICAgIHJldHVybiAoc3RhdGUgJiYgc3RhdGUuYWN0aXZlICYmIGZpbmRTdGF0ZU9wdGlvbihuYW1lKSkgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFN0YXRlKHN0YXRlT2JqLCBvdmVycmlkZU9wdGlvbikge1xuXG4gICAgc3RhdGVPYmoub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgIHVwc2VydCh7XG4gICAgICAgIHN0YXRlOiBzdGF0ZU9iai5uYW1lLFxuICAgICAgICB1cmw6IHN0YXRlT2JqLnVybCxcbiAgICAgICAgdmVyYjogc3RhdGVPYmoudmVyYixcbiAgICAgICAgbmFtZTogb3B0aW9uLm5hbWUsXG4gICAgICAgIGZyb21fbG9jYWw6ICEhb3ZlcnJpZGVPcHRpb24sXG4gICAgICAgIHN0YXR1czogb3B0aW9uLnN0YXR1cyxcbiAgICAgICAgZGF0YTogb3B0aW9uLmRhdGEsXG4gICAgICAgIGRlbGF5OiBvcHRpb24uZGVsYXlcbiAgICAgIH0sIG92ZXJyaWRlT3B0aW9uKTtcbiAgICB9KTtcblxuICAgIC8vJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdsZW9uYXJkbzpzdGF0ZUNoYW5nZWQnLCBzdGF0ZU9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTdGF0ZXMoc3RhdGVzQXJyLCBvdmVycmlkZU9wdGlvbiA9IGZhbHNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGVzQXJyKSkge1xuICAgICAgc3RhdGVzQXJyLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlT2JqKSB7XG4gICAgICAgIGFkZFN0YXRlKHN0YXRlT2JqLCBvdmVycmlkZU9wdGlvbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdsZW9uYXJkbzogYWRkU3RhdGVzIHNob3VsZCBnZXQgYW4gYXJyYXknKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cHNlcnQoY29uZmlnT2JqLCBvdmVycmlkZU9wdGlvbikge1xuICAgIHZhciB2ZXJiID0gY29uZmlnT2JqLnZlcmIgfHwgJ0dFVCcsXG4gICAgICBzdGF0ZSA9IGNvbmZpZ09iai5zdGF0ZSxcbiAgICAgIG5hbWUgPSBjb25maWdPYmoubmFtZSxcbiAgICAgIGZyb21fbG9jYWwgPSBjb25maWdPYmouZnJvbV9sb2NhbCxcbiAgICAgIHVybCA9IGNvbmZpZ09iai51cmwsXG4gICAgICBzdGF0dXMgPSBjb25maWdPYmouc3RhdHVzIHx8IDIwMCxcbiAgICAgIGRhdGEgPSAodHlwZW9mIGNvbmZpZ09iai5kYXRhICE9PSAndW5kZWZpbmVkJykgPyBjb25maWdPYmouZGF0YSA6IHt9LFxuICAgICAgZGVsYXkgPSBjb25maWdPYmouZGVsYXkgfHwgMDtcbiAgICB2YXIgZGVmYXVsdFN0YXRlID0ge307XG5cbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHt9O1xuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgY29uc29sZS5sb2coXCJsZW9uYXJkbzogY2Fubm90IHVwc2VydCAtIHN0YXRlIGlzIG1hbmRhdG9yeVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGVJdGVtID0gX3N0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKF9zdGF0ZSkge1xuICAgICAgICByZXR1cm4gX3N0YXRlLm5hbWUgPT09IHN0YXRlO1xuICAgICAgfSlbMF0gfHwgZGVmYXVsdFN0YXRlO1xuXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZUl0ZW0sIHtcbiAgICAgIG5hbWU6IHN0YXRlLFxuICAgICAgdXJsOiB1cmwgfHwgc3RhdGVJdGVtLnVybCxcbiAgICAgIHZlcmI6IHZlcmIsXG4gICAgICBvcHRpb25zOiBzdGF0ZUl0ZW0ub3B0aW9ucyB8fCBbXVxuICAgIH0pO1xuXG5cbiAgICBpZiAoc3RhdGVJdGVtID09PSBkZWZhdWx0U3RhdGUpIHtcbiAgICAgIF9zdGF0ZXMucHVzaChzdGF0ZUl0ZW0pO1xuICAgIH1cblxuICAgIHZhciBvcHRpb24gPSBzdGF0ZUl0ZW0ub3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKF9vcHRpb24pIHtcbiAgICAgIHJldHVybiBfb3B0aW9uLm5hbWUgPT09IG5hbWVcbiAgICB9KVswXTtcblxuICAgIGlmIChvdmVycmlkZU9wdGlvbiAmJiBvcHRpb24pIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uLCB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGZyb21fbG9jYWw6IGZyb21fbG9jYWwsXG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBkZWxheTogZGVsYXlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghb3B0aW9uKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb24sIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgZnJvbV9sb2NhbDogZnJvbV9sb2NhbCxcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGRlbGF5OiBkZWxheVxuICAgICAgfSk7XG5cbiAgICAgIHN0YXRlSXRlbS5vcHRpb25zLnB1c2goZGVmYXVsdE9wdGlvbik7XG4gICAgfVxuICAgIHNldHVwSnNvbnBGb3JTdGF0ZShzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTY2VuYXJpbyhzY2VuYXJpbywgZnJvbUxvY2FsOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBpZiAoc2NlbmFyaW8gJiYgdHlwZW9mIHNjZW5hcmlvLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZnJvbUxvY2FsKSB7XG4gICAgICAgIGNvbnN0IHNjZW5hcmlvcyA9IExlb25hcmRvLnN0b3JhZ2UuZ2V0U2NlbmFyaW9zKCk7XG4gICAgICAgIHNjZW5hcmlvcy5wdXNoKHNjZW5hcmlvKTtcbiAgICAgICAgTGVvbmFyZG8uc3RvcmFnZS5zZXRTY2VuYXJpb3Moc2NlbmFyaW9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zY2VuYXJpb3Nbc2NlbmFyaW8ubmFtZV0gPSBzY2VuYXJpbztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ2FkZFNjZW5hcmlvIG1ldGhvZCBleHBlY3RzIGEgc2NlbmFyaW8gb2JqZWN0IHdpdGggbmFtZSBwcm9wZXJ0eSc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkU2NlbmFyaW9zKHNjZW5hcmlvcykge1xuICAgIHNjZW5hcmlvcy5mb3JFYWNoKChzY2VuYXJpbykgPT4ge1xuICAgICAgYWRkU2NlbmFyaW8oc2NlbmFyaW8pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2NlbmFyaW9zKCkge1xuICAgIGNvbnN0IHNjZW5hcmlvcyA9IExlb25hcmRvLnN0b3JhZ2UuZ2V0U2NlbmFyaW9zKCkubWFwKChzY2VuYXJpbzogYW55KSA9PiBzY2VuYXJpby5uYW1lKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoX3NjZW5hcmlvcykuY29uY2F0KHNjZW5hcmlvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTY2VuYXJpbyhuYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgc3RhdGVzO1xuICAgIGlmIChfc2NlbmFyaW9zW25hbWVdKSB7XG4gICAgICBzdGF0ZXMgPSBfc2NlbmFyaW9zW25hbWVdLnN0YXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGVzID0gTGVvbmFyZG8uc3RvcmFnZS5nZXRTY2VuYXJpb3MoKVxuICAgICAgICAuZmlsdGVyKChzY2VuYXJpbykgPT4gc2NlbmFyaW8ubmFtZSA9PT0gbmFtZSlbMF0uc3RhdGVzO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBY3RpdmVTY2VuYXJpbyhuYW1lKSB7XG4gICAgdmFyIHNjZW5hcmlvID0gZ2V0U2NlbmFyaW8obmFtZSk7XG4gICAgaWYgKCFzY2VuYXJpbykge1xuICAgICAgY29uc29sZS53YXJuKFwibGVvbmFyZG86IGNvdWxkIG5vdCBmaW5kIHNjZW5hcmlvIG5hbWVkIFwiICsgbmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvZ2dsZUFjdGl2YXRlQWxsKGZhbHNlKTtcbiAgICBzY2VuYXJpby5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdXBzZXJ0T3B0aW9uKHN0YXRlLm5hbWUsIHN0YXRlLm9wdGlvbiwgdHJ1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhY3RpdmF0ZVN0YXRlT3B0aW9uKHN0YXRlLCBvcHRpb25OYW1lKSB7XG4gICAgdXBzZXJ0T3B0aW9uKHN0YXRlLCBvcHRpb25OYW1lLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGVTdGF0ZShzdGF0ZSkge1xuICAgIHVwc2VydE9wdGlvbihzdGF0ZSwgbnVsbCwgZmFsc2UpO1xuICB9XG5cbiAgaW50ZXJmYWNlIElOZXR3b3JrUmVxdWVzdCB7XG4gICAgdmVyYjogRnVuY3Rpb247XG4gICAgZGF0YTogYW55O1xuICAgIHVybD86IHN0cmluZztcbiAgICBzdGF0dXM6IHN0cmluZztcbiAgICB0aW1lc3RhbXA6IERhdGU7XG4gICAgc3RhdGU/OiBzdHJpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBsb2dSZXF1ZXN0KG1ldGhvZCwgdXJsLCBkYXRhLCBzdGF0dXMpIHtcbiAgICBpZiAobWV0aG9kICYmIHVybCAmJiAhKHVybC5pbmRleE9mKFwiLmh0bWxcIikgPiAwKSkge1xuICAgICAgdmFyIHJlcTogSU5ldHdvcmtSZXF1ZXN0ID0ge1xuICAgICAgICB2ZXJiOiBtZXRob2QsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHVybDogdXJsLnRyaW0oKSxcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxuICAgICAgfTtcbiAgICAgIHJlcS5zdGF0ZSA9IGZldGNoU3RhdGVzQnlVcmxBbmRNZXRob2QocmVxLnVybCwgcmVxLnZlcmIpO1xuICAgICAgX3JlcXVlc3RzTG9nLnB1c2gocmVxKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXF1ZXN0c0xvZygpIHtcbiAgICByZXR1cm4gX3JlcXVlc3RzTG9nO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFNhdmVkU3RhdGVzKCkge1xuICAgIF9zYXZlZFN0YXRlcyA9IExlb25hcmRvLnN0b3JhZ2UuZ2V0U2F2ZWRTdGF0ZXMoKTtcbiAgICBhZGRTdGF0ZXMoX3NhdmVkU3RhdGVzLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNhdmVkU3RhdGUoc3RhdGUpIHtcbiAgICBfc2F2ZWRTdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgTGVvbmFyZG8uc3RvcmFnZS5zZXRTYXZlZFN0YXRlcyhfc2F2ZWRTdGF0ZXMpO1xuICAgIGFkZFN0YXRlKHN0YXRlLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE9yVXBkYXRlU2F2ZWRTdGF0ZShzdGF0ZSkge1xuICAgIHZhciBvcHRpb24gPSBzdGF0ZS5hY3RpdmVPcHRpb247XG5cbiAgICAvL3VwZGF0ZSBsb2NhbCBzdG9yYWdlIHN0YXRlXG4gICAgdmFyIF9zYXZlZFN0YXRlID0gX3NhdmVkU3RhdGVzLmZpbHRlcihmdW5jdGlvbiAoX3N0YXRlKSB7XG4gICAgICByZXR1cm4gX3N0YXRlLm5hbWUgPT09IHN0YXRlLm5hbWU7XG4gICAgfSlbMF07XG5cbiAgICBpZiAoX3NhdmVkU3RhdGUpIHtcbiAgICAgIHZhciBfc2F2ZWRPcHRpb24gPSBfc2F2ZWRTdGF0ZS5vcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoX29wdGlvbikge1xuICAgICAgICByZXR1cm4gX29wdGlvbi5uYW1lID09PSBvcHRpb24ubmFtZTtcbiAgICAgIH0pWzBdO1xuXG4gICAgICBpZiAoX3NhdmVkT3B0aW9uKSB7XG4gICAgICAgIF9zYXZlZE9wdGlvbi5zdGF0dXMgPSBvcHRpb24uc3RhdHVzO1xuICAgICAgICBfc2F2ZWRPcHRpb24uZGVsYXkgPSBvcHRpb24uZGVsYXk7XG4gICAgICAgIF9zYXZlZE9wdGlvbi5kYXRhID0gb3B0aW9uLmRhdGE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgX3NhdmVkU3RhdGUub3B0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgICB9XG5cbiAgICAgIExlb25hcmRvLnN0b3JhZ2Uuc2V0U2F2ZWRTdGF0ZXMoX3NhdmVkU3RhdGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhZGRTYXZlZFN0YXRlKHN0YXRlKTtcbiAgICB9XG5cbiAgICAvL3VwZGF0ZSBpbiBtZW1vcnkgc3RhdGVcbiAgICB2YXIgX3N0YXRlID0gX3N0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKF9fc3RhdGUpIHtcbiAgICAgIHJldHVybiBfX3N0YXRlLm5hbWUgPT09IHN0YXRlLm5hbWU7XG4gICAgfSlbMF07XG5cbiAgICBpZiAoX3N0YXRlKSB7XG4gICAgICB2YXIgX29wdGlvbiA9IF9zdGF0ZS5vcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoX19vcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fb3B0aW9uLm5hbWUgPT09IG9wdGlvbi5uYW1lO1xuICAgICAgfSlbMF07XG5cbiAgICAgIGlmIChfb3B0aW9uKSB7XG4gICAgICAgIF9vcHRpb24uc3RhdHVzID0gb3B0aW9uLnN0YXR1cztcbiAgICAgICAgX29wdGlvbi5kZWxheSA9IG9wdGlvbi5kZWxheTtcbiAgICAgICAgX29wdGlvbi5kYXRhID0gb3B0aW9uLmRhdGE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgX3N0YXRlLm9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgfVxuXG4gICAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnbGVvbmFyZG86c3RhdGVDaGFuZ2VkJywgX3N0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTdGF0ZUJ5TmFtZShuYW1lKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBfc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlLCBpKSB7XG4gICAgICBpZiAoc3RhdGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfc3RhdGVzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTYXZlZFN0YXRlQnlOYW1lKG5hbWUpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIF9zYXZlZFN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSwgaSkge1xuICAgICAgaWYgKHN0YXRlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX3NhdmVkU3RhdGVzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTdGF0ZShzdGF0ZSkge1xuXG4gICAgcmVtb3ZlU3RhdGVCeU5hbWUoc3RhdGUubmFtZSk7XG4gICAgcmVtb3ZlU2F2ZWRTdGF0ZUJ5TmFtZShzdGF0ZS5uYW1lKTtcblxuICAgIExlb25hcmRvLnN0b3JhZ2Uuc2V0U2F2ZWRTdGF0ZXMoX3NhdmVkU3RhdGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVN0YXRlT3B0aW9uQnlOYW1lKHN0YXRlTmFtZSwgb3B0aW9uTmFtZSkge1xuICAgIHZhciBzSW5kZXggPSBudWxsO1xuICAgIHZhciBvSW5kZXggPSBudWxsO1xuXG4gICAgX3N0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSwgaSkge1xuICAgICAgaWYgKHN0YXRlLm5hbWUgPT09IHN0YXRlTmFtZSkge1xuICAgICAgICBzSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgX3N0YXRlc1tzSW5kZXhdLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uLCBpKSB7XG4gICAgICAgIGlmIChvcHRpb24ubmFtZSA9PT0gb3B0aW9uTmFtZSkge1xuICAgICAgICAgIG9JbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAob0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIF9zdGF0ZXNbc0luZGV4XS5vcHRpb25zLnNwbGljZShvSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVNhdmVkU3RhdGVPcHRpb25CeU5hbWUoc3RhdGVOYW1lLCBvcHRpb25OYW1lKSB7XG4gICAgdmFyIHNJbmRleCA9IG51bGw7XG4gICAgdmFyIG9JbmRleCA9IG51bGw7XG5cbiAgICBfc2F2ZWRTdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUsIGkpIHtcbiAgICAgIGlmIChzdGF0ZS5uYW1lID09PSBzdGF0ZU5hbWUpIHtcbiAgICAgICAgc0luZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzSW5kZXggIT09IG51bGwpIHtcbiAgICAgIF9zYXZlZFN0YXRlc1tzSW5kZXhdLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uLCBpKSB7XG4gICAgICAgIGlmIChvcHRpb24ubmFtZSA9PT0gb3B0aW9uTmFtZSkge1xuICAgICAgICAgIG9JbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAob0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIF9zYXZlZFN0YXRlc1tzSW5kZXhdLm9wdGlvbnMuc3BsaWNlKG9JbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlT3B0aW9uKHN0YXRlLCBvcHRpb24pIHtcbiAgICByZW1vdmVTdGF0ZU9wdGlvbkJ5TmFtZShzdGF0ZS5uYW1lLCBvcHRpb24ubmFtZSk7XG4gICAgcmVtb3ZlU2F2ZWRTdGF0ZU9wdGlvbkJ5TmFtZShzdGF0ZS5uYW1lLCBvcHRpb24ubmFtZSk7XG5cbiAgICBMZW9uYXJkby5zdG9yYWdlLnNldFNhdmVkU3RhdGVzKF9zYXZlZFN0YXRlcyk7XG5cbiAgICBhY3RpdmF0ZVN0YXRlT3B0aW9uKF9zdGF0ZXNbMF0ubmFtZSwgX3N0YXRlc1swXS5vcHRpb25zWzBdLm5hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVjb3JkZWRTdGF0ZXMoKSB7XG4gICAgdmFyIHJlcXVlc3RzQXJyID0gX3JlcXVlc3RzTG9nXG4gICAgICAubWFwKGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZmV0Y2hTdGF0ZXNCeVVybEFuZE1ldGhvZChyZXEudXJsLCByZXEudmVyYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogc3RhdGUgPyBzdGF0ZS5uYW1lIDogcmVxLnZlcmIgKyBcIiBcIiArIHJlcS51cmwsXG4gICAgICAgICAgdmVyYjogcmVxLnZlcmIsXG4gICAgICAgICAgdXJsOiByZXEudXJsLFxuICAgICAgICAgIHJlY29yZGVkOiAhIXJlcS5zdGF0ZSxcbiAgICAgICAgICBvcHRpb25zOiBbe1xuICAgICAgICAgICAgbmFtZTogcmVxLnN0YXR1cyA+PSAyMDAgJiYgcmVxLnN0YXR1cyA8IDMwMCA/ICdTdWNjZXNzJyA6ICdGYWlsdXJlJyxcbiAgICAgICAgICAgIHN0YXR1czogcmVxLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IHJlcS5kYXRhXG4gICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIHJlcXVlc3RzQXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TZXRTdGF0ZXMoZm4pIHtcbiAgICBfZXZlbnRzRWxlbSAmJiBfZXZlbnRzRWxlbS5hZGRFdmVudExpc3RlbmVyKCdsZW9uYXJkbzpzZXRTdGF0ZXMnLCBmbiwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVzQ2hhbmdlZCgpIHtcbiAgICBfZXZlbnRzRWxlbSAmJiBfZXZlbnRzRWxlbS5kaXNwYXRjaEV2ZW50KF9zdGF0ZXNDaGFuZ2VkRXZlbnQpO1xuICB9XG59XG4iLCJpbXBvcnQge2xlb0NvbmZpZ3VyYXRpb259IGZyb20gJy4vY29uZmlndXJhdGlvbi5zcnYnO1xuaW1wb3J0IHtTdG9yYWdlfSBmcm9tICcuL3N0b3JhZ2Uuc3J2JztcbmltcG9ydCB7cG9saWZ5bGxzfSBmcm9tICcuL3BvbHlmaWxscyc7XG5pbXBvcnQge1Npbm9ufSBmcm9tICcuL3Npbm9uLnNydic7XG5pbXBvcnQgVUlSb290IGZyb20gJy4vdWkvdWktcm9vdCc7XG5cbmRlY2xhcmUgY29uc3Qgd2luZG93O1xuZGVjbGFyZSBjb25zdCBPYmplY3Q7XG5cbnBvbGlmeWxscygpO1xuXG4vL0luaXQgQ29uZmlndXJhdGlvblxud2luZG93Lkxlb25hcmRvID0gd2luZG93Lkxlb25hcmRvIHx8IHt9O1xuY29uc3QgY29uZmlndXJhdGlvbiA9IGxlb0NvbmZpZ3VyYXRpb24oKTtcbmNvbnN0IHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuT2JqZWN0LmFzc2lnbih3aW5kb3cuTGVvbmFyZG8gfHwge30sIGNvbmZpZ3VyYXRpb24sIHtzdG9yYWdlfSk7XG5MZW9uYXJkby5sb2FkU2F2ZWRTdGF0ZXMoKTtcblxuLy8gSW5pdCBTaW5vblxubmV3IFNpbm9uKCk7XG5cbi8vSW5pdCBVSVxubmV3IFVJUm9vdCgpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIHBvbGlmeWxscygpIHtcblxuICAvLyBDdXN0b21FdmVudFxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7YnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZH07XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3dbJ0V2ZW50J10ucHJvdG90eXBlO1xuXG4gICAgd2luZG93WydDdXN0b21FdmVudCddID0gQ3VzdG9tRXZlbnQ7XG4gIH0pKCk7XG5cbiAgLy8gT2JqZWN0LmFzc2lnblxuICAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgKDxhbnk+T2JqZWN0KS5hc3NpZ24gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgKDxhbnk+T2JqZWN0KS5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuICAgIH1cblxuICB9KSgpXG59XG5cbiIsImltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzJztcblxuZGVjbGFyZSB2YXIgc2lub247XG5cbmV4cG9ydCBjbGFzcyBTaW5vbiB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBwcml2YXRlIGluaXQoKSB7XG4gICAgdmFyIHNlcnZlciA9IHNpbm9uLmZha2VTZXJ2ZXIuY3JlYXRlKHtcbiAgICAgIGF1dG9SZXNwb25kOiB0cnVlLFxuICAgICAgYXV0b1Jlc3BvbmRBZnRlcjogMTBcbiAgICB9KTtcblxuICAgIHNpbm9uLkZha2VYTUxIdHRwUmVxdWVzdC51c2VGaWx0ZXJzID0gdHJ1ZTtcbiAgICBzaW5vbi5GYWtlWE1MSHR0cFJlcXVlc3QuYWRkRmlsdGVyKGZ1bmN0aW9uIChtZXRob2QsIHVybCkge1xuICAgICAgaWYgKHVybC5pbmRleE9mKCcuaHRtbCcpID4gMCAmJiB1cmwuaW5kZXhPZigndGVtcGxhdGUnKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXRlID0gTGVvbmFyZG8uZmV0Y2hTdGF0ZXNCeVVybEFuZE1ldGhvZCh1cmwsIG1ldGhvZCk7XG4gICAgICByZXR1cm4gIShzdGF0ZSAmJiBzdGF0ZS5hY3RpdmUpO1xuICAgIH0pO1xuXG4gICAgc2lub24uRmFrZVhNTEh0dHBSZXF1ZXN0Lm9uUmVzcG9uc2VFbmQgPSBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICB2YXIgcmVzID0geGhyLnJlc3BvbnNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICAgIExlb25hcmRvLl9sb2dSZXF1ZXN0KHhoci5tZXRob2QsIHhoci51cmwsIHJlcywgeGhyLnN0YXR1cyk7XG4gICAgfTtcblxuICAgIHNlcnZlci5yZXNwb25kV2l0aChmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgdmFyIHN0YXRlID0gTGVvbmFyZG8uZmV0Y2hTdGF0ZXNCeVVybEFuZE1ldGhvZChyZXF1ZXN0LnVybCwgcmVxdWVzdC5tZXRob2QpLFxuICAgICAgICBhY3RpdmVPcHRpb24gPSBMZW9uYXJkby5nZXRBY3RpdmVTdGF0ZU9wdGlvbihzdGF0ZS5uYW1lKTtcblxuICAgICAgaWYgKCEhYWN0aXZlT3B0aW9uKSB7XG4gICAgICAgIHZhciByZXNwb25zZURhdGEgPSBVdGlscy5pc0Z1bmN0aW9uKGFjdGl2ZU9wdGlvbi5kYXRhKSA/IGFjdGl2ZU9wdGlvbi5kYXRhKHJlcXVlc3QpIDogYWN0aXZlT3B0aW9uLmRhdGE7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uZChhY3RpdmVPcHRpb24uc3RhdHVzLCB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30sIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlRGF0YSkpO1xuICAgICAgICBMZW9uYXJkby5fbG9nUmVxdWVzdChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHJlc3BvbnNlRGF0YSwgYWN0aXZlT3B0aW9uLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2NvdWxkIG5vdCBmaW5kIGEgc3RhdGUgZm9yIHRoZSBmb2xsb3dpbmcgcmVxdWVzdCcsIHJlcXVlc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmRlY2xhcmUgY29uc3Qgd2luZG93OiBhbnk7XG5cbmV4cG9ydCBjbGFzcyBTdG9yYWdlIHtcbiAgcHJpdmF0ZSBBUFBfUFJFRklYO1xuICBwcml2YXRlIFNUQVRFU19TVE9SRV9LRVk7XG4gIHByaXZhdGUgU0NFTkFSSU9TX1NUT1JFX0tFWTtcbiAgcHJpdmF0ZSBTQVZFRF9TVEFURVNfS0VZO1xuICBwcml2YXRlIFBPU0lUSU9OX0tFWTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLkFQUF9QUkVGSVggPSBMZW9uYXJkby5BUFBfUFJFRklYIHx8ICcnO1xuICAgIHRoaXMuU1RBVEVTX1NUT1JFX0tFWSA9IGAke3RoaXMuQVBQX1BSRUZJWH1sZW9uYXJkby1zdGF0ZXNgO1xuICAgIHRoaXMuU0FWRURfU1RBVEVTX0tFWSA9IGAke3RoaXMuQVBQX1BSRUZJWH1sZW9uYXJkby11bnJlZ2lzdGVyZWQtc3RhdGVzYDtcbiAgICB0aGlzLlNDRU5BUklPU19TVE9SRV9LRVkgPSBgJHt0aGlzLkFQUF9QUkVGSVh9bGVvbmFyZG8tc2NlbmFyaW9zYDtcbiAgICB0aGlzLlBPU0lUSU9OX0tFWSA9IGAke3RoaXMuQVBQX1BSRUZJWH1sZW9uYXJkby1wb3NpdGlvbmA7XG4gIH1cblxuICBfZ2V0SXRlbShrZXkpIHtcbiAgICB2YXIgaXRlbSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5mcm9tSnNvbihpdGVtKTtcbiAgfVxuXG4gIF9zZXRJdGVtKGtleSwgZGF0YSkge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIFV0aWxzLnRvSnNvbihkYXRhKSk7XG4gIH1cblxuICBnZXRTdGF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEl0ZW0odGhpcy5TVEFURVNfU1RPUkVfS0VZKSB8fCB7fTtcbiAgfVxuXG4gIGdldFNjZW5hcmlvcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbSh0aGlzLlNDRU5BUklPU19TVE9SRV9LRVkpIHx8IFtdO1xuICB9XG5cbiAgc2V0U3RhdGVzKHN0YXRlcykge1xuICAgIHRoaXMuX3NldEl0ZW0odGhpcy5TVEFURVNfU1RPUkVfS0VZLCBzdGF0ZXMpO1xuICAgIExlb25hcmRvLnN0YXRlc0NoYW5nZWQoKTtcbiAgfVxuXG4gIHNldFNjZW5hcmlvcyhzY2VuYXJpb3MpIHtcbiAgICB0aGlzLl9zZXRJdGVtKHRoaXMuU0NFTkFSSU9TX1NUT1JFX0tFWSwgc2NlbmFyaW9zKTtcbiAgfVxuXG4gIGdldFNhdmVkU3RhdGVzKCkge1xuICAgIHZhciBzdGF0ZXMgPSB0aGlzLl9nZXRJdGVtKHRoaXMuU0FWRURfU1RBVEVTX0tFWSkgfHwgW107XG4gICAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5vcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgb3B0aW9uLmZyb21fbG9jYWwgPSB0cnVlO1xuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdGVzO1xuICB9XG5cbiAgc2V0U2F2ZWRTdGF0ZXMoc3RhdGVzKSB7XG4gICAgdGhpcy5fc2V0SXRlbSh0aGlzLlNBVkVEX1NUQVRFU19LRVksIHN0YXRlcyk7XG4gIH1cblxuICBzZXRTYXZlZFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZXRJdGVtKHRoaXMuUE9TSVRJT05fS0VZLCBwb3NpdGlvbik7XG4gIH1cblxuICBnZXRTYXZlZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRJdGVtKHRoaXMuUE9TSVRJT05fS0VZKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtFdmVudFN1Yn0gZnJvbSAnLi91aS1ldmVudHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL3VpLWV2ZW50cyc7XG5pbXBvcnQgVWlVdGlscyBmcm9tICcuL3VpLXV0aWxzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERPTUVsZW1lbnQge1xuICBwcm90ZWN0ZWQgdmlld05vZGU6IGFueTtcbiAgcHJvdGVjdGVkIGV2ZW50U3ViczogQXJyYXk8RXZlbnRTdWI+ID0gW107XG4gIHByb3RlY3RlZCBib2R5RXZlbnRzU3ViczpBcnJheTxFdmVudFN1Yj4gPSBbXTtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB2aWV3U3RyaW5nOiBzdHJpbmcgPSAnJykge1xuICAgIHRoaXMudmlld05vZGUgPSBVaVV0aWxzLmdldEVsZW1lbnRGcm9tSHRtbCh0aGlzLnZpZXdTdHJpbmcpO1xuICB9XG5cbiAgZ2V0KCk6IEhUTUxFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy52aWV3Tm9kZTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXIoKXtcbiAgICBpZighdGhpcy52aWV3Tm9kZSl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmlld05vZGUuaW5uZXJIVE1MID0gJyc7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25JdGVtKG5vZGU6IEhUTUxFbGVtZW50LCBldmVudFR5cGU6IHN0cmluZywgY2I6IEV2ZW50TGlzdGVuZXIpOiBFdmVudFN1YiB7XG4gICAgY29uc3QgZXZlbnRTdWI6IEV2ZW50U3ViID0gIEV2ZW50cy5vbkl0ZW0obm9kZSwgZXZlbnRUeXBlLCBjYik7XG4gICAgdGhpcy5ldmVudFN1YnMucHVzaChldmVudFN1Yik7XG4gICAgcmV0dXJuIGV2ZW50U3ViO1xuICB9XG5cblxuICBwcm90ZWN0ZWQgY2xlYXJFdmVudFN1YnMoKSB7XG4gICAgdGhpcy5jbGVhclNldEV2ZW50U3Vicyh0aGlzLmV2ZW50U3Vicyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2xlYXJTZXRFdmVudFN1YnMobGlzdDogQXJyYXk8RXZlbnRTdWI+KSB7XG4gICAgbGlzdC5mb3JFYWNoKChsaXN0ZW5lcjogRXZlbnRTdWIpPT4ge1xuICAgICAgbGlzdGVuZXIub2ZmKCk7XG4gICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclNldEV2ZW50U3Vicyh0aGlzLmJvZHlFdmVudHNTdWJzKTtcbiAgICB0aGlzLmNsZWFyRXZlbnRTdWJzKCk7XG4gICAgdGhpcy52aWV3Tm9kZSA9IG51bGw7XG4gIH1cbn1cbiIsImltcG9ydCBET01FbGVtZW50IGZyb20gJy4uL0RPTUVsZW1lbnQnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi91aS1ldmVudHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29kZUVkaXRvciBleHRlbmRzIERPTUVsZW1lbnQge1xuICBlZGl0b3I6IGFueTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9uU2F2ZUNCOiBGdW5jdGlvbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBvbkNhbmNlbENCOiBGdW5jdGlvbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBpbml0RGF0YTogc3RyaW5nKSB7XG4gICAgc3VwZXIoYDxkaXYgaWQ9XCJsZW9uYXJkby1jb2RlLWVkaXRvclwiIGNsYXNzPVwibGVvbmFyZG8tY29kZS1lZGl0b3JcIj48L2Rpdj5gKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLnZpZXdOb2RlLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwibGVvbmFyZG8tY29kZS1lZGl0b3ItY29udGFpbmVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImxlb25hcmRvLWNvZGUtZWRpdG9yLWhlYWRlclwiPlxuICAgICAgICAgICAgPHN0cm9uZz5FZGl0IFJlc3BvbnNlPC9zdHJvbmc+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImxlb25hcmRvLWNvZGUtZWRpdG9yLWJlYXV0aWZ5XCI+QmVhdXRpZnk8L2E+XG4gICAgICAgICAgPC9kaXY+ICAgICAgICAgIFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1jb2RlLWVkaXRvci1ib2R5XCI+XG4gICAgICAgICAgICA8ZGl2IGlkPVwibGVvbmFyZG8tY29kZS1lZGl0b3ItZWRpdC1hcmVhXCI+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImxlb25hcmRvLWNvZGUtZWRpdG9yLWZvb3RlclwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImxlb25hcmRvLWJ1dHRvbiBsZW9uYXJkby1jb2RlLWVkaXRvci1zYXZlXCI+U2F2ZTwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImxlb25hcmRvLWJ1dHRvbiBsZW9uYXJkby1jb2RlLWVkaXRvci1jYW5jZWxcIiA+Q2FuY2VsPC9idXR0b24+ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgPC9kaXY+ICAgICAgICAgICBcbiAgICAgIDwvZGl2PmA7XG4gICAgRXZlbnRzLmRpc3BhdGNoKEV2ZW50cy5PUEVOX0RJQUxPRywgdGhpcy52aWV3Tm9kZSk7XG4gICAgRXZlbnRzLm9uSXRlbSh0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5sZW9uYXJkby1jb2RlLWVkaXRvci1iZWF1dGlmeScpLCdjbGljaycsIHRoaXMuYmVhdXRpZnkuYmluZCh0aGlzKSk7XG4gICAgRXZlbnRzLm9uSXRlbU9uY2UodGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKCcubGVvbmFyZG8tY29kZS1lZGl0b3ItY2FuY2VsJyksJ2NsaWNrJywgdGhpcy5vbkNhbmNlbC5iaW5kKHRoaXMpKTtcbiAgICBFdmVudHMub25JdGVtT25jZSh0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5sZW9uYXJkby1jb2RlLWVkaXRvci1zYXZlJyksICdjbGljaycsIHRoaXMub25TYXZlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZWRpdG9yID0gd2luZG93WydhY2UnXS5lZGl0KFwibGVvbmFyZG8tY29kZS1lZGl0b3ItZWRpdC1hcmVhXCIpO1xuICAgIHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKS5zZXRVc2VXb3JrZXIoZmFsc2UpO1xuICAgIHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKS5zZXRNb2RlKFwiYWNlL21vZGUvamF2YXNjcmlwdFwiKTtcbiAgICB0aGlzLmVkaXRvci5zZXRUaGVtZShcImFjZS90aGVtZS9jaHJvbWVcIik7XG4gICAgdGhpcy5lZGl0b3Iuc2V0U2hvd1ByaW50TWFyZ2luKGZhbHNlKTtcbiAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh0aGlzLmluaXREYXRhKTtcbiAgICB0aGlzLmVkaXRvci5leGVjQ29tbWFuZChcImdvdG9saW5lZW5kXCIpO1xuICAgIHRoaXMuZWRpdG9yLmZvY3VzKCk7XG4gIH1cblxuICBwcml2YXRlIGdldFJlc1N0cmluZyhyZXNvcG5zZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsZXQgcmVzU3RyOiBzdHJpbmc7XG4gICAgdHJ5IHtcbiAgICAgIGlmKHR5cGVvZiByZXNvcG5zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXNTdHIgPSByZXNvcG5zZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgcmVzU3RyID0gSlNPTi5zdHJpbmdpZnkocmVzb3Buc2UsIG51bGwsIDQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaChlKXtcbiAgICAgIHJlc1N0ciA9IHR5cGVvZiByZXNvcG5zZSA9PT0gJ3N0cmluZycgPyByZXNvcG5zZSA6IHJlc29wbnNlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNTdHI7XG4gIH1cblxuICBwcml2YXRlIG9uQ2FuY2VsKCkge1xuICAgIHRoaXMub25DYW5jZWxDQigpO1xuICAgIEV2ZW50cy5kaXNwYXRjaChFdmVudHMuQ0xPU0VfRElBTE9HKTtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHByaXZhdGUgb25TYXZlKCkge1xuICAgIHRoaXMub25TYXZlQ0IodGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSk7XG4gICAgRXZlbnRzLmRpc3BhdGNoKEV2ZW50cy5DTE9TRV9ESUFMT0cpO1xuICB9XG5cbiAgcHJpdmF0ZSBiZWF1dGlmeSgpIHtcbiAgICBsZXQgdmFsID0gdGhpcy5lZGl0b3Iuc2Vzc2lvbi5nZXRWYWx1ZSgpO1xuICAgIC8vUmVtb3ZlIGxlYWRpbmcgc3BhY2VzXG4gICAgbGV0IGFycmF5ID0gdmFsLnNwbGl0KC9cXG4vKTtcbiAgICBhcnJheVswXSA9IGFycmF5WzBdLnRyaW0oKTtcbiAgICB2YWwgPSBhcnJheS5qb2luKFwiXFxuXCIpO1xuICAgIC8vQWN0dWFsIGJlYXV0aWZ5IChwcmV0dGlmeSlcbiAgICB2YWwgPSB3aW5kb3dbJ2pzX2JlYXV0aWZ5J10odmFsKTtcbiAgICAvL0NoYW5nZSBjdXJyZW50IHRleHQgdG8gZm9ybWF0dGVkIHRleHRcbiAgICB0aGlzLmVkaXRvci5zZXNzaW9uLnNldFZhbHVlKHZhbCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmVkaXRvci5kZXN0cm95KCk7XG4gIH1cbn1cbiIsImltcG9ydCBFdmVudHMgZnJvbSAnLi4vdWktZXZlbnRzJztcbmltcG9ydCBET01FbGVtZW50IGZyb20gJy4uL0RPTUVsZW1lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wRG93biBleHRlbmRzIERPTUVsZW1lbnR7XG5cbiAgb3B0aW9uc1N0YXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpdGVtcyxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBhY3RpdmVJdGVtLFxuICAgICAgICAgICAgICBwcml2YXRlIGlzRGlzYWJsZWQ6IGJvb2xlYW4sXG4gICAgICAgICAgICAgIHByaXZhdGUgb25TZWxlY3RJdGVtOiBGdW5jdGlvbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBvblJlbW92ZUl0ZW06IEZ1bmN0aW9uKSB7XG4gICAgc3VwZXIoYDxkaXYgY2xhc3M9XCJsZW9uYXJkby1kcm9wZG93blwiPjwvZGl2PmApO1xuICAgIHRoaXMuYm9keUV2ZW50c1N1YnMucHVzaChFdmVudHMub24oJ2NsaWNrJywgdGhpcy5jbG9zZURyb3BEb3duLmJpbmQodGhpcykpKTtcbiAgICB0aGlzLmJvZHlFdmVudHNTdWJzLnB1c2goRXZlbnRzLm9uKEV2ZW50cy5DTE9TRV9EUk9QRE9XTlMsIHRoaXMuY2xvc2VEcm9wRG93bi5iaW5kKHRoaXMpKSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5jbGVhckV2ZW50U3VicygpO1xuICAgIHRoaXMudmlld05vZGUuaW5uZXJIVE1MID0gYFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1kcm9wZG93bi1zZWxlY3RlZFwiICR7dGhpcy5pc0Rpc2FibGVkVG9rZW4oKX0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxlb25hcmRvLWRyb3Bkb3duLXNlbGVjdGVkLXRleHRcIj4ke3RoaXMuYWN0aXZlSXRlbS5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGVvbmFyZG8tZHJvcGRvd24tc2VsZWN0ZWQtYXJyb3dcIj48L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImxlb25hcmRvLWRyb3Bkb3duLW9wdGlvbnNcIj5cbiAgICAgICAgICAgIDx1bCBjbGFzcz1cImxlb25hcmRvLWRyb3Bkb3duLWxpc3RcIj4ke3RoaXMuZ2V0SXRlbXMoKS5qb2luKCcnKX08L3VsPlxuICAgICAgICAgIDwvZGl2PmA7XG4gICAgdGhpcy5vbkl0ZW0odGhpcy52aWV3Tm9kZSwgJ2NsaWNrJywgdGhpcy50b2dnbGVEcm9wRG93bi5iaW5kKHRoaXMpKTtcblxuICB9XG5cbiAgZGlzYWJsZURyb3BEb3duKCkge1xuICAgIHRoaXMuaXNEaXNhYmxlZCA9IHRydWU7XG4gICAgdGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKGAubGVvbmFyZG8tZHJvcGRvd24tc2VsZWN0ZWRgKS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBlbmFibGVEcm9wRG93bigpIHtcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoYC5sZW9uYXJkby1kcm9wZG93bi1zZWxlY3RlZGApLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIHRvZ2dsZURyb3BEb3duKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldFsnY2xhc3NMaXN0J10uY29udGFpbnMoJ2xlb25hcmRvLWRyb3Bkb3duLWl0ZW0nKSkge1xuICAgICAgdGhpcy5zZXRBY3RpdmVJdGVtKGV2ZW50LnRhcmdldFsncXVlcnlTZWxlY3RvciddKCcubGVvbmFyZG8tZHJvcGRvd24taXRlbS10ZXh0JykuaW5uZXJIVE1MKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQudGFyZ2V0WydjbGFzc0xpc3QnXS5jb250YWlucygnbGVvbmFyZG8tZHJvcGRvd24taXRlbS10ZXh0JykpIHtcbiAgICAgIHRoaXMuc2V0QWN0aXZlSXRlbShldmVudC50YXJnZXRbJ2lubmVySFRNTCddKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQudGFyZ2V0WydjbGFzc0xpc3QnXS5jb250YWlucygnbGVvbmFyZG8tZHJvcGRvd24taXRlbS14JykpIHtcbiAgICAgIHRoaXMucmVtb3ZlSXRlbSg8SFRNTEVsZW1lbnQ+ZXZlbnQudGFyZ2V0WydwYXJlbnROb2RlJ10pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zU3RhdGUpIHtcbiAgICAgIHRoaXMuY2xvc2VEcm9wRG93bigpO1xuICAgICAgdGhpcy5vcHRpb25zU3RhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm9wZW5Ecm9wRG93bigpO1xuICAgICAgdGhpcy5vcHRpb25zU3RhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIG9wZW5Ecm9wRG93bigpIHtcbiAgICBjb25zdCBlbGVtOiBIVE1MRWxlbWVudCA9IDxIVE1MRWxlbWVudD50aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoYC5sZW9uYXJkby1kcm9wZG93bi1vcHRpb25zYCk7XG4gICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBjb25zdCBlbGVtUmVjOiBDbGllbnRSZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc092ZXJmbG93ZWQ6IGJvb2xlYW4gPSBlbGVtUmVjLnRvcCArIGVsZW1SZWMuaGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGlmIChpc092ZXJmbG93ZWQpIHtcbiAgICAgIGVsZW0uc3R5bGUudG9wID0gLWVsZW1SZWMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgIGVsZW0uc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCAjMjEyMTIxJztcbiAgICAgIGVsZW0uc3R5bGUuYm9yZGVyQm90dG9tID0gJ25vbmUnO1xuICAgIH1cbiAgICBFdmVudHMuZGlzcGF0Y2goRXZlbnRzLkNMT1NFX0RST1BET1dOUywgdGhpcy52aWV3Tm9kZSk7XG4gIH1cblxuICBjbG9zZURyb3BEb3duKGV2ZW50PzogQ3VzdG9tRXZlbnQpIHtcbiAgICBjb25zdCBkcm9wRG93bjogSFRNTEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+dGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKGAubGVvbmFyZG8tZHJvcGRvd24tb3B0aW9uc2ApO1xuICAgIGlmICghZHJvcERvd24gfHwgKGV2ZW50ICYmIGV2ZW50LmRldGFpbCA9PT0gdGhpcy52aWV3Tm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJvcERvd24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG4gIHNldEFjdGl2ZUl0ZW0oaXRlbU5hbWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLmFjdGl2ZUl0ZW0ubmFtZSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVJdGVtID0gdGhpcy5nZXRJdGVtQnlOYW1lKGl0ZW1OYW1lKTtcbiAgICB0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoYC5sZW9uYXJkby1kcm9wZG93bi1zZWxlY3RlZC10ZXh0YClbJ2lubmVySFRNTCddID0gdGhpcy5hY3RpdmVJdGVtLm5hbWU7XG4gICAgdGhpcy5vblNlbGVjdEl0ZW0odGhpcy5hY3RpdmVJdGVtKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0SXRlbUJ5TmFtZShpdGVtTmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IHJldEl0ZW0gPSB0aGlzLmFjdGl2ZUl0ZW07XG4gICAgdGhpcy5pdGVtcy5zb21lKChjdXJJdGVtKSA9PiB7XG4gICAgICBpZiAoY3VySXRlbS5uYW1lID09PSBpdGVtTmFtZSkge1xuICAgICAgICByZXRJdGVtID0gY3VySXRlbTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldEl0ZW07XG4gIH1cblxuICBwcml2YXRlIGdldEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcCgoaXRlbToge25hbWU6IHN0cmluZ30pID0+IHtcbiAgICAgIHJldHVybiBgPGxpIGNsYXNzPVwibGVvbmFyZG8tZHJvcGRvd24taXRlbVwiPjxzcGFuIGNsYXNzPVwibGVvbmFyZG8tZHJvcGRvd24taXRlbS10ZXh0XCI+JHtpdGVtLm5hbWV9PC9zcGFuPjxzcGFuIGNsYXNzPVwibGVvbmFyZG8teC1idG4gbGVvbmFyZG8tZHJvcGRvd24taXRlbS14XCI+PC9zcGFuPjwvbGk+YFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGlzRGlzYWJsZWRUb2tlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0Rpc2FibGVkID8gJ2Rpc2FibGVkJyA6ICcnO1xuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVJdGVtKGl0ZW06IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJlbW92ZWRJdGVtO1xuICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLmZpbHRlcigoY3VySXRlbSkgPT4ge1xuICAgICAgaWYgKGN1ckl0ZW0ubmFtZSA9PT0gaXRlbS5xdWVyeVNlbGVjdG9yKCcubGVvbmFyZG8tZHJvcGRvd24taXRlbS10ZXh0JylbJ2lubmVySFRNTCddKSB7XG4gICAgICAgIHJlbW92ZWRJdGVtID0gY3VySXRlbTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5sZW9uYXJkby1kcm9wZG93bi1saXN0JykucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgdGhpcy5vblJlbW92ZUl0ZW0ocmVtb3ZlZEl0ZW0pO1xuXG4gIH1cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi9sZW9uYXJkby5kLnRzXCIgLz5cbmltcG9ydCBVdGlscyBmcm9tICcuLi91aS11dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uL3VpLWV2ZW50cyc7XG5pbXBvcnQge0hlYWRlclRhYkl0ZW19IGZyb20gJy4vaGVhZGVyLm1vZGVsJztcbmltcG9ydCBVSVN0YXRlVmlld1NlcnZpY2UgZnJvbSAnLi4vdWktc3RhdGUvdWktc3RhdGUuc3J2JztcbmltcG9ydCBET01FbGVtZW50IGZyb20gJy4uL0RPTUVsZW1lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWFkZXJWaWV3IGV4dGVuZHMgRE9NRWxlbWVudHtcbiAgXG4gIHN0YXRpYyBTRUxFQ1RFRF9DTEFTU19OQU1FOiBzdHJpbmcgPSAnbGVvbmFyZG8taGVhZGVyLXRhYkl0ZW0tc2VsZWN0ZWQnO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGFiTGlzdDogQXJyYXk8SGVhZGVyVGFiSXRlbT4pIHtcbiAgICBzdXBlcihgPGRpdiBjbGFzcz1cImxlb25hcmRvLWhlYWRlci1jb250YWluZXJcIj5gKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLnZpZXdOb2RlLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwibGVvbmFyZG8taGVhZGVyLWNvbnRhaW5lci1pblwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImxlb25hcmRvLWhlYWRlci1sYWJlbCBcIj5MRU9OQVJETzwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJsZW9uYXJkby1oZWFkZXItdGFic1wiPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICR7dGhpcy5nZXRUYWJzSHRtbCgwKX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PmA7XG4gICAgdGhpcy5vbkl0ZW0odGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKCd1bCcpLCAnY2xpY2snLCB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gIH1cblxuICBwcml2YXRlIGdldFRhYnNIdG1sKHNlbGVjdGVkSW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLnRhYkxpc3QubWFwKCh0YWI6IEhlYWRlclRhYkl0ZW0sIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkOiBzdHJpbmcgPSBpbmRleCA9PT0gc2VsZWN0ZWRJbmRleCA/IEhlYWRlclZpZXcuU0VMRUNURURfQ0xBU1NfTkFNRSA6ICcnO1xuICAgICAgcmV0dXJuIGA8bGkgY2xhc3M9XCJsZW9uYXJkby1oZWFkZXItdGFiSXRlbSAke3NlbGVjdGVkfVwiIGRhdGEtaGVhZGVydGFiPVwibGVvbmFyZG8taGVhZGVyLSR7dGFiLmxhYmVsfVwiID4ke3RhYi5sYWJlbH08L2xpPmA7XG4gICAgfSkuam9pbignJyk7XG4gIH1cblxuICBvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RUYWIoZXZlbnQudGFyZ2V0Wydpbm5lckhUTUwnXSk7XG4gIH1cblxuICBzZWxlY3RUYWIodGFiTGFiZWw6IHN0cmluZyl7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLiR7SGVhZGVyVmlldy5TRUxFQ1RFRF9DTEFTU19OQU1FfWApLmNsYXNzTGlzdC5yZW1vdmUoYGxlb25hcmRvLWhlYWRlci10YWJJdGVtLXNlbGVjdGVkYCk7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtaGVhZGVydGFiPVwibGVvbmFyZG8taGVhZGVyLSR7dGFiTGFiZWx9XCJdYCkuY2xhc3NMaXN0LmFkZChIZWFkZXJWaWV3LlNFTEVDVEVEX0NMQVNTX05BTUUpO1xuICAgIFVJU3RhdGVWaWV3U2VydmljZS5nZXRJbnN0YW5jZSgpLnNldEN1clZpZXdTdGF0ZSh0YWJMYWJlbCk7XG4gIH1cblxuICAvLyQoZG9jdW1lbnQpLm9uKCdrZXlwcmVzcycsIChlKSA9PiB7XG4gIC8vICBpZiAoZS5zaGlmdEtleSAmJiBlLmN0cmxLZXkpIHtcbiAgLy8gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgLy8gICAgICBjYXNlIDEyOlxuICAvLyAgICAgICAgJCgnLmxlb25hcmRvLWFjdGl2YXRvcicpLnRvZ2dsZSgpO1xuICAvLyAgICAgICAgYnJlYWs7XG4gIC8vICAgICAgY2FzZSAxMTpcbiAgLy8gICAgICAgIHRvZ2dsZVdpbmRvdygpO1xuICAvLyAgICAgICAgYnJlYWs7XG4gIC8vICAgICAgZGVmYXVsdDpcbiAgLy8gICAgICAgIGJyZWFrO1xuICAvLyAgICB9XG4gIC8vICB9XG4gIC8vfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdIZWxwZXIge1xuXG4gIHN0YXRpYyB0cmltKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoYF5bXFxcXHNdK3xbXFxcXHNdKyRgLCAnZycpLCAnJyk7XG4gIH1cbn0iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vbGVvbmFyZG8uZC50c1wiIC8+XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdWktdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi91aS1ldmVudHMnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnLi4vRE9NRWxlbWVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhdW5jaGVyIGV4dGVuZHMgRE9NRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYDxkaXYgY2xhc3M9XCJsZW9uYXJkby1sYXVuY2hlclwiPjwvZGl2PmApO1xuICAgIHRoaXMuZXZlbnRTdWJzLnB1c2goRXZlbnRzLm9uKCdrZXlkb3duJywgdGhpcy5ib2R5S2V5cHJlc3MuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuZXZlbnRTdWJzLnB1c2goRXZlbnRzLm9uKEV2ZW50cy5UT0dHTEVfSUNPTiwgdGhpcy50b2dnbGVMYXVuY2hlci5iaW5kKHRoaXMpKSk7XG4gICAgdGhpcy5vbkl0ZW0odGhpcy52aWV3Tm9kZSwgJ2NsaWNrJywgdGhpcy5vbkNsaWNrLmJpbmQodGhpcykpO1xuICB9XG5cbiAgb25DbGljaygpIHtcbiAgICBFdmVudHMuZGlzcGF0Y2goRXZlbnRzLlRPR0dMRV9MQVVOQ0hFUik7XG4gIH1cblxuICBib2R5S2V5cHJlc3MoZTogS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUuY3RybEtleSAmJiBlLmtleUNvZGUgPT09IDc2KSB7XG4gICAgICBFdmVudHMuZGlzcGF0Y2goRXZlbnRzLlRPR0dMRV9JQ09OKTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVMYXVuY2hlcigpIHtcbiAgICB0aGlzLnZpZXdOb2RlLnN0eWxlLmRpc3BsYXkgPSB0aGlzLnZpZXdOb2RlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICdibG9jaycgOiAnbm9uZSc7XG4gIH1cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi9sZW9uYXJkby5kLnRzXCIgLz5cbmltcG9ydCBVdGlscyBmcm9tICcuLi91aS11dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uL3VpLWV2ZW50cyc7XG5pbXBvcnQgSGVhZGVyVmlldyBmcm9tICcuLi9oZWFkZXIvaGVhZGVyJztcbmltcG9ydCB7SGVhZGVyVGFiSXRlbX0gZnJvbSAnLi4vaGVhZGVyL2hlYWRlci5tb2RlbCc7XG5pbXBvcnQge1VJU3RhdGVMaXN0fSBmcm9tICcuLi91aS1zdGF0ZS91aS1zdGF0ZS5kYXRhJztcbmltcG9ydCBVSVN0YXRlVmlld1NlcnZpY2UgZnJvbSAnLi4vdWktc3RhdGUvdWktc3RhdGUuc3J2JztcbmltcG9ydCB7VUlWaWV3U3RhdGV9IGZyb20gJy4uL3VpLXN0YXRlL3VpLXN0YXRlLm1vZGVsJztcbmltcG9ydCBWaWV3c0NvbnRhaW5lciBmcm9tICcuL3ZpZXdzLWNvbnRhaW5lci92aWV3cy1jb250YWluZXInO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnLi4vRE9NRWxlbWVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5WaWV3IGV4dGVuZHMgRE9NRWxlbWVudHtcbiAgY2xhc3NOYW1lID0gJ2xlb25hcmRvLW1haW4tdmlldyc7XG4gIGhpZGRlbkNsYXNzTmFtZSA9IGAke3RoaXMuY2xhc3NOYW1lfS1oaWRkZW5gO1xuICBoZWFkZXJWaWV3OiBIZWFkZXJWaWV3O1xuICB2aWV3c0NvbnRhaW5lcjogVmlld3NDb250YWluZXI7XG4gIGJvZHlWaWV3OiBIVE1MRWxlbWVudDtcbiAgbWVudVZpZXc6IEhUTUxFbGVtZW50O1xuICBkaWFsb2dWaWV3OiBIVE1MRWxlbWVudDtcbiAgbWVudVN0YXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYDxkaXYgY2xhc3M9XCJsZW9uYXJkby1tYWluLXZpZXcgbGVvbmFyZG8tbWFpbi12aWV3LWhpZGRlblwiPjwvZGl2PmApO1xuICAgIHRoaXMuZXZlbnRTdWJzLnB1c2goRXZlbnRzLm9uKCdrZXlkb3duJywgdGhpcy5vbktleVByZXNzLmJpbmQodGhpcykpKTtcbiAgICB0aGlzLmV2ZW50U3Vicy5wdXNoKEV2ZW50cy5vbihFdmVudHMuVE9HR0xFX0xBVU5DSEVSLCB0aGlzLnRvZ2dsZVZpZXcuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuZXZlbnRTdWJzLnB1c2goRXZlbnRzLm9uKEV2ZW50cy5BVFRBQ0hfTUVOVV9JVEVNLCB0aGlzLmF0dGFjaE1lbnUuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuZXZlbnRTdWJzLnB1c2goRXZlbnRzLm9uKEV2ZW50cy5PUEVOX01FTlUsIHRoaXMub3Blbk1lbnUuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuZXZlbnRTdWJzLnB1c2goRXZlbnRzLm9uKEV2ZW50cy5DTE9TRV9NRU5VLCB0aGlzLmNsb3NlTWVudS5iaW5kKHRoaXMpKSk7XG4gICAgdGhpcy5ldmVudFN1YnMucHVzaChFdmVudHMub24oRXZlbnRzLk9QRU5fRElBTE9HLCB0aGlzLm9wZW5EaWFsb2cuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuZXZlbnRTdWJzLnB1c2goRXZlbnRzLm9uKEV2ZW50cy5DTE9TRV9ESUFMT0csIHRoaXMuY2xvc2VEaWFsb2cuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuZXZlbnRTdWJzLnB1c2goRXZlbnRzLm9uKEV2ZW50cy5DSEFOR0VfVklFVywgdGhpcy5jbG9zZU1lbnUuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuYm9keVZpZXcgPSBVdGlscy5nZXRFbGVtZW50RnJvbUh0bWwoYDxkaXYgY2xhc3M9XCJsZW9uYXJkby1tYWluLXZpZXctYm9keVwiPjwvZGl2PmApO1xuICAgIHRoaXMubWVudVZpZXcgPSBVdGlscy5nZXRFbGVtZW50RnJvbUh0bWwoYDxkaXYgY2xhc3M9XCJsZW9uYXJkby1tYWluLXZpZXctbWVudVwiPjwvZGl2PmApO1xuICAgIHRoaXMuZGlhbG9nVmlldyA9IFV0aWxzLmdldEVsZW1lbnRGcm9tSHRtbChgPGRpdiBjbGFzcz1cImxlb25hcmRvLW1haW4tdmlldy1kaWFsb2dcIj48L2Rpdj5gKTtcbiAgICBVSVN0YXRlVmlld1NlcnZpY2UuZ2V0SW5zdGFuY2UoKS5pbml0KFVJU3RhdGVMaXN0KCksIFVJU3RhdGVMaXN0KClbMF0ubmFtZSk7XG4gICAgdGhpcy5oZWFkZXJWaWV3ID0gbmV3IEhlYWRlclZpZXcodGhpcy5nZXRUYWJMaXN0KCkpO1xuICAgIHRoaXMudmlld3NDb250YWluZXIgPSBuZXcgVmlld3NDb250YWluZXIoKTtcbiAgfVxuXG4gIHRvZ2dsZVZpZXcoKSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLmNsYXNzTmFtZX1gKTtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmhpZGRlbkNsYXNzTmFtZSkpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5oaWRkZW5DbGFzc05hbWUpO1xuICAgICAgaWYgKCFlbC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlTGVvKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMubWVudVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy52aWV3Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmJvZHlWaWV3KTtcbiAgICB0aGlzLnZpZXdOb2RlLmFwcGVuZENoaWxkKHRoaXMubWVudVZpZXcpO1xuICAgIHRoaXMudmlld05vZGUuYXBwZW5kQ2hpbGQodGhpcy5kaWFsb2dWaWV3KTtcbiAgICB0aGlzLmJvZHlWaWV3LmFwcGVuZENoaWxkKHRoaXMuaGVhZGVyVmlldy5nZXQoKSk7XG4gICAgdGhpcy5ib2R5Vmlldy5hcHBlbmRDaGlsZCh0aGlzLnZpZXdzQ29udGFpbmVyLmdldCgpKTtcbiAgICB0aGlzLmhlYWRlclZpZXcucmVuZGVyKCk7XG4gICAgdGhpcy52aWV3c0NvbnRhaW5lci5zZXRWaWV3KFVJU3RhdGVWaWV3U2VydmljZS5nZXRJbnN0YW5jZSgpLmdldEN1clZpZXdTdGF0ZSgpKTtcbiAgICB0aGlzLnZpZXdzQ29udGFpbmVyLnJlbmRlcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBhdHRhY2hNZW51KGV2ZW50OiBDdXN0b21FdmVudCl7XG4gICAgdGhpcy5tZW51Vmlldy5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLmNsb3NlTWVudShudWxsKTtcbiAgICB0aGlzLm1lbnVWaWV3LmFwcGVuZENoaWxkKGV2ZW50LmRldGFpbCk7XG4gIH1cblxuICBwcml2YXRlIG9wZW5NZW51KGV2ZW50OiBDdXN0b21FdmVudCl7XG4gICAgaWYodGhpcy5tZW51U3RhdGUpe1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1lbnVTdGF0ZSA9IHRydWU7XG4gICAgdGhpcy5tZW51Vmlldy5jbGFzc0xpc3QucmVtb3ZlKCdsZW9uYXJkby1tYWluLXZpZXctbWVudS1pbicpO1xuICAgIHRoaXMubWVudVZpZXcuY2xhc3NMaXN0LmFkZCgnbGVvbmFyZG8tbWFpbi12aWV3LW1lbnUtb3V0Jyk7XG4gICAgdGhpcy5ib2R5Vmlldy5zdHlsZS53aWR0aCA9ICh0aGlzLmJvZHlWaWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gdGhpcy5tZW51Vmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkgKyAncHgnXG4gIH1cblxuICBwcml2YXRlIGNsb3NlTWVudShldmVudDogQ3VzdG9tRXZlbnQpe1xuICAgIGlmKCF0aGlzLm1lbnVTdGF0ZSl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubWVudVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5tZW51Vmlldy5jbGFzc0xpc3QucmVtb3ZlKCdsZW9uYXJkby1tYWluLXZpZXctbWVudS1vdXQnKTtcbiAgICB0aGlzLm1lbnVWaWV3LmNsYXNzTGlzdC5hZGQoJ2xlb25hcmRvLW1haW4tdmlldy1tZW51LWluJyk7XG4gICAgdGhpcy5ib2R5Vmlldy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIH1cblxuICBwcml2YXRlIG9wZW5EaWFsb2coZXZlbnQ6IEN1c3RvbUV2ZW50KXtcbiAgICB0aGlzLmRpYWxvZ1ZpZXcuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5kaWFsb2dWaWV3LmFwcGVuZENoaWxkKGV2ZW50LmRldGFpbCk7XG4gICAgdGhpcy5kaWFsb2dWaWV3LnN0eWxlLmRpc3BsYXkgPSdibG9jayc7XG4gICAgdGhpcy5ib2R5Vmlldy5jbGFzc0xpc3QuYWRkKCdsZW9uYXJkby1tYWluLW92ZXJsYXknKTtcblxuICB9XG5cbiAgcHJpdmF0ZSBjbG9zZURpYWxvZyhldmVudDogQ3VzdG9tRXZlbnQpe1xuICAgIHRoaXMuYm9keVZpZXcuY2xhc3NMaXN0LnJlbW92ZSgnbGVvbmFyZG8tbWFpbi1vdmVybGF5Jyk7XG4gICAgdGhpcy5kaWFsb2dWaWV3LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuZGlhbG9nVmlldy5zdHlsZS5kaXNwbGF5ID0nbm9uZSc7XG4gIH1cblxuICBwcml2YXRlIGdldFRhYkxpc3QoKTogQXJyYXk8SGVhZGVyVGFiSXRlbT4ge1xuICAgIHJldHVybiBVSVN0YXRlVmlld1NlcnZpY2UuZ2V0SW5zdGFuY2UoKS5nZXRWaWV3U3RhdGVzKCkubWFwKCh2aWV3OiBVSVZpZXdTdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIHtsYWJlbDogdmlldy5uYW1lfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjbG9zZUxlbygpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuY2xhc3NOYW1lfWApO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQodGhpcy5oaWRkZW5DbGFzc05hbWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbktleVByZXNzKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LndoaWNoID09IDI3KSB7XG4gICAgICB0aGlzLmNsb3NlTGVvKCk7XG4gICAgfVxuICB9XG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vbGVvbmFyZG8uZC50c1wiIC8+XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdWktdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi91aS1ldmVudHMnO1xuaW1wb3J0IHtVSVZpZXdTdGF0ZX0gZnJvbSAnLi4vLi4vdWktc3RhdGUvdWktc3RhdGUubW9kZWwnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnLi4vLi4vRE9NRWxlbWVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdzQ29udGFpbmVyIGV4dGVuZHMgRE9NRWxlbWVudHtcblxuICBjdXJyZW50Vmlld1N0YXRlOiBVSVZpZXdTdGF0ZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgPGRpdiBpZD1cImxlb25hcmRvLXZpZXdzLWNvbnRhaW5lclwiIGNsYXNzPVwibGVvbmFyZG8tdmlld3MtY29udGFpbmVyXCI+dmlldyBjb250YWluZXI8L2Rpdj5gKTtcbiAgICB0aGlzLmV2ZW50U3Vicy5wdXNoKEV2ZW50cy5vbihFdmVudHMuQ0hBTkdFX1ZJRVcsIHRoaXMub25WaWV3Q2hhbmdlZC5iaW5kKHRoaXMpKSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy52aWV3Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRWaWV3U3RhdGUuY29tcG9uZW50LmdldCgpKTtcbiAgICB0aGlzLmN1cnJlbnRWaWV3U3RhdGUuY29tcG9uZW50LnJlbmRlcigpO1xuICB9XG5cbiAgc2V0VmlldyhjdXJWaWV3OiBVSVZpZXdTdGF0ZSl7XG4gICAgdGhpcy5jdXJyZW50Vmlld1N0YXRlID0gY3VyVmlldztcbiAgfVxuXG4gIG9uVmlld0NoYW5nZWQoZXZlbnQ6IEN1c3RvbUV2ZW50KSB7XG4gICAgdGhpcy5jdXJyZW50Vmlld1N0YXRlLmNvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgdGhpcy5zZXRWaWV3KHRoaXMuY3VycmVudFZpZXdTdGF0ZSA9IGV2ZW50LmRldGFpbCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxufVxuIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2xlb25hcmRvLmQudHNcIiAvPlxuZXhwb3J0IGludGVyZmFjZSBFdmVudFN1YiB7XG4gIG9mZjogRnVuY3Rpb25cbn1cblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFRPR0dMRV9MQVVOQ0hFUjogJ2xlb25hcmRvOnRvZ2dsZTpsYXVuY2hlcicsXG4gIENIQU5HRV9WSUVXOiAnbGVvbmFyZG86Y2hhbmdlOnZpZXcnLFxuICBGSUxURVJfU1RBVEVTOiAnbGVvbmFyZG86ZmlsdGVyOnN0YXRlcycsXG4gIENMT1NFX0RST1BET1dOUzogJ2xlb25hcmRvOmNsb3NlOmRyb3Bkb3ducycsXG4gIFRPR0dMRV9TVEFURVM6ICdsZW9uYXJkbzp0b2dnbGU6c3RhdGVzJyxcbiAgVE9HR0xFX1NDRU5BUklPUzogJ2xlb25hcmRvOnRvZ2dsZTpzY2VuYXJpbycsXG4gIEFERF9TQ0VOQVJJTzogJ2xlb25hcmRvOmFkZDpzY2VuYXJpbycsXG4gIFRPR0dMRV9TVEFURTogJ2xlb25hcmRvOnRvZ2dsZTpzdGF0ZXMnLFxuICBUT0dHTEVfSUNPTjogJ2xlb25hcmRvOnRvZ2dsZTppY29uJyxcbiAgQVRUQUNIX01FTlVfSVRFTTogJ2xlb25hcmRvOmF0dGFjaDptZW51JyxcbiAgT1BFTl9NRU5VOiAnbGVvbmFyZG86bWVudTpvcGVuJyxcbiAgQ0xPU0VfTUVOVTogJ2xlb25hcmRvOm1lbnU6Y2xvc2UnLFxuICBPUEVOX0RJQUxPRzogJ2xlb25hcmRvOmRpYWxvZzpvcGVuJyxcbiAgQ0xPU0VfRElBTE9HOiAnbGVvbmFyZG86ZGlhbG9nOmNsb3NlJyxcblxuICAvL1dlIHdhbnQgdG8gbWFpbnRhaW4gc2NvcGUgaGVyZVxuICBvbjogZnVuY3Rpb24oZXZlbnROYW1lOiBzdHJpbmcsIGZuOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMub25JdGVtKGRvY3VtZW50LmJvZHksIGV2ZW50TmFtZSwgZm4pO1xuICB9LFxuICBvbk9uY2U6IGZ1bmN0aW9uKGV2ZW50TmFtZTogc3RyaW5nLCBmbjogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCl7XG4gICAgdGhpcy5vbkl0ZW1PbmNlKGRvY3VtZW50LmJvZHksIGV2ZW50TmFtZSwgZm4pO1xuICB9LFxuICBkaXNwYXRjaDogKGV2ZW50TmFtZTogc3RyaW5nLCBkZXRhaWxzPzogYW55KSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7ZGV0YWlsOiBkZXRhaWxzfSk7XG4gICAgZG9jdW1lbnQuYm9keS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSxcbiAgb25JdGVtT25jZTogKG5vZGU6IGFueSwgdHlwZTogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZS50eXBlLCA8RXZlbnRMaXN0ZW5lcj5hcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShjYWxsYmFjaywgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgfSxcbiAgb25JdGVtOiAobm9kZTogYW55LCB0eXBlOiBzdHJpbmcsIGNhbGxiYWNrOiBFdmVudExpc3RlbmVyKSA9PiB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZjogKCkgPT4ge3JldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIGZhbHNlKX1cbiAgICB9XG4gIH1cblxufVxuIiwiaW1wb3J0IExhdW5jaGVyIGZyb20gJy4vbGF1bmNoZXIvbGF1bmNoZXInO1xuaW1wb3J0IE1haW5WaWV3IGZyb20gJy4vbWFpbi12aWV3L21haW4tdmlldyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91aS11dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vdWktZXZlbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlSb290IHtcbiAgbGVvbmFyZG9BcHA6IE5vZGU7XG4gIGxhdW5jaGVyOiBMYXVuY2hlcjtcbiAgbWFpblZpZXc6IE1haW5WaWV3OyAgXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3dpdGNoIChkb2N1bWVudC5yZWFkeVN0YXRlKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgIEV2ZW50cy5vbkl0ZW1PbmNlKGRvY3VtZW50LCAnRE9NQ29udGVudExvYWRlZCcsIHRoaXMuaW5pdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnRlcmFjdGl2ZSc6XG4gICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpbml0KCkge1xuXG4gICAgdGhpcy5sZW9uYXJkb0FwcCA9IFV0aWxzLmdldEVsZW1lbnRGcm9tSHRtbChgPGRpdiBsZW9uYXJkby1hcHA+PC9kaXY+YCk7XG4gICAgdGhpcy5sYXVuY2hlciA9IG5ldyBMYXVuY2hlcigpO1xuICAgIHRoaXMubWFpblZpZXcgPSBuZXcgTWFpblZpZXcoKTtcbiAgICB0aGlzLmxlb25hcmRvQXBwLmFwcGVuZENoaWxkKHRoaXMubWFpblZpZXcuZ2V0KCkpO1xuICAgIHRoaXMubGVvbmFyZG9BcHAuYXBwZW5kQ2hpbGQodGhpcy5sYXVuY2hlci5nZXQoKSk7XG4gICAgRXZlbnRzLm9uKEV2ZW50cy5UT0dHTEVfU1RBVEVTLCB0aGlzLnRvZ2dsZUFsbFN0YXRlcy5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubGVvbmFyZG9BcHApO1xuICB9XG5cbiAgcHJpdmF0ZSB0b2dnbGVBbGxTdGF0ZXMoZXZlbnQ6IEN1c3RvbUV2ZW50KSB7XG4gICAgTGVvbmFyZG8udG9nZ2xlQWN0aXZhdGVBbGwoZXZlbnQuZGV0YWlsKTtcbiAgfVxufSIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi9sZW9uYXJkby5kLnRzXCIgLz5cblxuaW1wb3J0IHtVSVZpZXdTdGF0ZX0gZnJvbSAnLi91aS1zdGF0ZS5tb2RlbCc7XG5pbXBvcnQgU2NlbmFyaW9zIGZyb20gJy4uL3ZpZXdzL3NjZW5hcmlvcy9zY2VuYXJpb3MnO1xuaW1wb3J0IFJlY29yZGVyIGZyb20gJy4uL3ZpZXdzL3JlY29yZGVyL3JlY29yZGVyJztcbmltcG9ydCBFeHBvcnQgZnJvbSAnLi4vdmlld3MvZXhwb3J0L2V4cG9ydCc7XG5cbmxldCB1aUxpc3Q6IEFycmF5PFVJVmlld1N0YXRlPjtcblxuZXhwb3J0IGZ1bmN0aW9uIFVJU3RhdGVMaXN0KCk6IEFycmF5PFVJVmlld1N0YXRlPiB7XG4gIGlmKHVpTGlzdCl7XG4gICAgcmV0dXJuIHVpTGlzdDtcbiAgfVxuICByZXR1cm4gdWlMaXN0ID0gW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzY2VuYXJpb3MnLFxuICAgICAgY29tcG9uZW50OiBuZXcgU2NlbmFyaW9zKClcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZWNvcmRlcicsXG4gICAgICBjb21wb25lbnQ6IG5ldyBSZWNvcmRlcigpXG5cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdleHBvcnRlZCBjb2RlJyxcbiAgICAgIGNvbXBvbmVudDogbmV3IEV4cG9ydCgpXG4gICAgfVxuICBdO1xufVxuXG5cblxuIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL2xlb25hcmRvLmQudHNcIiAvPlxuXG5pbXBvcnQge1VJVmlld1N0YXRlfSBmcm9tICcuL3VpLXN0YXRlLm1vZGVsJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vdWktZXZlbnRzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJU3RhdGVWaWV3U2VydmljZSB7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX2luc3RhbmNlOiBVSVN0YXRlVmlld1NlcnZpY2UgPSBuZXcgVUlTdGF0ZVZpZXdTZXJ2aWNlKCk7XG4gIHByaXZhdGUgY3VyVmlld1N0YXRlOiBVSVZpZXdTdGF0ZTtcbiAgcHJpdmF0ZSB2aWV3U3RhdGVMaXN0OiBBcnJheTxVSVZpZXdTdGF0ZT47XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFVJU3RhdGVWaWV3U2VydmljZSB7XG4gICAgcmV0dXJuIFVJU3RhdGVWaWV3U2VydmljZS5faW5zdGFuY2U7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAoVUlTdGF0ZVZpZXdTZXJ2aWNlLl9pbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVSVN0YXRlVmlld1NlcnZpY2Ugc2hvdWxkIGJlIHNpbmdsZXRvbicpO1xuICAgIH1cbiAgICBVSVN0YXRlVmlld1NlcnZpY2UuX2luc3RhbmNlID0gdGhpcztcbiAgfVxuXG5cblxuICBpbml0KHZpZXdTdGF0ZUxpc3Q6IEFycmF5PFVJVmlld1N0YXRlPiwgaW5pdFZpZXdOYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLnZpZXdTdGF0ZUxpc3QgPSB2aWV3U3RhdGVMaXN0O1xuICAgIHRoaXMuY3VyVmlld1N0YXRlID0gdGhpcy5nZXRWaWV3U3RhdGVCeU5hbWUoaW5pdFZpZXdOYW1lKTtcbiAgfVxuXG4gIGdldEN1clZpZXdTdGF0ZSgpe1xuICAgIHJldHVybiB0aGlzLmN1clZpZXdTdGF0ZTtcbiAgfVxuXG4gIHNldEN1clZpZXdTdGF0ZShzdGF0ZU5hbWU6IHN0cmluZyl7XG4gICAgdGhpcy5jdXJWaWV3U3RhdGUgPSB0aGlzLmdldFZpZXdTdGF0ZUJ5TmFtZShzdGF0ZU5hbWUpO1xuICAgIEV2ZW50cy5kaXNwYXRjaChFdmVudHMuQ0hBTkdFX1ZJRVcsIHRoaXMuY3VyVmlld1N0YXRlKTtcbiAgfVxuXG4gIGdldFZpZXdTdGF0ZXMoKXtcbiAgICByZXR1cm4gdGhpcy52aWV3U3RhdGVMaXN0O1xuICB9XG5cbiAgYWRkVmlld1N0YXRlKHZpZXdTdGF0ZTogVUlWaWV3U3RhdGUpe1xuICAgIHRoaXMudmlld1N0YXRlTGlzdC5wdXNoKHZpZXdTdGF0ZSk7XG4gIH1cblxuICByZW1vdmVWaWV3U3RhdGUodmlld1N0YXRlTmFtZTogc3RyaW5nKXtcbiAgICB0aGlzLnZpZXdTdGF0ZUxpc3QgPSB0aGlzLnZpZXdTdGF0ZUxpc3QuZmlsdGVyKCh2aWV3OiBVSVZpZXdTdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIHZpZXcubmFtZSA9PT0gdmlld1N0YXRlTmFtZTtcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRWaWV3U3RhdGVCeU5hbWUodmlld1N0YXRlTmFtZTogc3RyaW5nKTogVUlWaWV3U3RhdGV7XG4gICAgbGV0IHJldFZpZXc6IFVJVmlld1N0YXRlO1xuICAgIHRoaXMudmlld1N0YXRlTGlzdC5zb21lKCh2aWV3OiBVSVZpZXdTdGF0ZSkgPT4ge1xuICAgICAgaWYodmlld1N0YXRlTmFtZSA9PT0gdmlldy5uYW1lKXtcbiAgICAgICAgcmV0dXJuICEhKHJldFZpZXcgPSB2aWV3KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0VmlldyB8fCB0aGlzLmN1clZpZXdTdGF0ZTtcbiAgfVxuXG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgVWlVdGlscyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgc3RhdGljIGdldEVsZW1lbnRGcm9tSHRtbChodG1sOiBzdHJpbmcpOiBIVE1MRWxlbWVudCB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmlubmVySFRNTCA9IGh0bWwudHJpbSgpO1xuICAgIHJldHVybiA8SFRNTEVsZW1lbnQ+ZGl2LmZpcnN0Q2hpbGQ7XG4gIH1cblxuICBzdGF0aWMgZ3VpZEdlbmVyYXRvcigpIHtcbiAgICB2YXIgUzQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKCgoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIH07XG4gICAgcmV0dXJuIChTNCgpICsgUzQoKSArICctJyArIFM0KCkgKyAnLScgKyBTNCgpICsgJy0nICsgUzQoKSArICctJyArIFM0KCkgKyBTNCgpICsgUzQoKSk7XG4gIH1cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi9sZW9uYXJkby5kLnRzXCIgLz5cbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi91aS11dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL3VpLWV2ZW50cyc7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICcuLi8uLi9ET01FbGVtZW50JztcbmltcG9ydCBTdHJpbmdIZWxwZXIgZnJvbSAnLi4vLi4vaGVscGVycy9zdHJpbmcuaGVscGVyJztcblxuZGVjbGFyZSB2YXIgd2luZG93O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHBvcnQgZXh0ZW5kcyBET01FbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgPGRpdiBpZD1cImxlb25hcmRvLWV4cG9ydFwiIGNsYXNzPVwibGVvbmFyZG8tZXhwb3J0XCI+YCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy52aWV3Tm9kZS5pbm5lckhUTUwgPSBgXG4gICAgICA8YnV0dG9uIGlkPVwibGVvbmFyZG8tY29weS1jbGlwYm9hcmQtYnRuXCIgY2xhc3M9XCJsZW9uYXJkby1idXR0b24gbGVvbmFyZG8tZXhwb3J0LWJ1dHRvbnNcIiBkYXRhLWNsaXBib2FyZC10YXJnZXQ9XCIjbGVvbmFyZG8tZXhwb3J0ZWQtY29kZVwiPiBDb3B5IFRvIENsaXBib2FyZDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBpZD1cImxlb25hcmRvLWRvd25sb2FkLWNvZGUtYnRuXCIgY2xhc3M9XCJsZW9uYXJkby1idXR0b24gbGVvbmFyZG8tZXhwb3J0LWJ1dHRvbnNcIj4gRG93bmxvYWQgQ29kZTwvYnV0dG9uPlxuICAgICAgPGRpdiBjbGFzcz1cImxlb25hcmRvLXNwYWNlclwiPjwvZGl2PlxuICAgICAgPGNvZGUgY29udGVudGVkaXRhYmxlPlxuICAgICAgICA8ZGl2IGlkPVwibGVvbmFyZG8tZXhwb3J0ZWQtY29kZVwiIGNsYXNzPVwibGVvbmFyZG8tZXhwb3J0ZWQtY29kZVwiPlxuICAgICAgICAgICAgPHByZT4ke1N0cmluZ0hlbHBlci50cmltKEpTT04uc3RyaW5naWZ5KExlb25hcmRvLmdldFN0YXRlcygpLCBudWxsLCAgNCkpfTwvcHJlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvY29kZT5cbiAgICAgIDxhIGlkPVwiZG93bmxvYWRBbmNob3JFbGVtXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj48L2E+XG4gICAgPC9kaXY+YDtcblxuXG4gICAgRXZlbnRzLm9uSXRlbSh0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJyNsZW9uYXJkby1jb3B5LWNsaXBib2FyZC1idG4nKSwgJ2NsaWNrJywgdGhpcy5jb3B5VG9DbGlwYm9hcmQuYmluZCh0aGlzKSk7XG4gICAgRXZlbnRzLm9uSXRlbSh0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJyNsZW9uYXJkby1kb3dubG9hZC1jb2RlLWJ0bicpLCAnY2xpY2snLCB0aGlzLmRvd25sb2FkRmlsZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGRvd25sb2FkRmlsZSgpIHtcbiAgICBjb25zdCBpbm5lciA9IHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignI2xlb25hcmRvLWV4cG9ydGVkLWNvZGUgcHJlJykuaW5uZXJIVE1MIHx8ICcnO1xuICAgIGNvbnN0IHRleHQgPSBTdHJpbmdIZWxwZXIudHJpbShpbm5lcikucmVwbGFjZSgvPGJyPi9nLCAnXFxyXFxuJyk7XG5cbiAgICBjb25zdCBkYXRhU3RyID0gYGRhdGE6dGV4dC9qc29uO2NoYXJzZXQ9dXRmLTgsJHtlbmNvZGVVUklDb21wb25lbnQodGV4dCl9YDtcbiAgICBjb25zdCBkbEFuY2hvckVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWRBbmNob3JFbGVtJyk7XG5cbiAgICBkbEFuY2hvckVsZW0uc2V0QXR0cmlidXRlKCdocmVmJywgZGF0YVN0cik7XG4gICAgZGxBbmNob3JFbGVtLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCAnbGVvbmFyZG8tc3RhdGVzLmpzb24nKTtcbiAgICBkbEFuY2hvckVsZW0uY2xpY2soKTtcbiAgfVxuXG4gIGNvcHlUb0NsaXBib2FyZCgpIHtcbiAgICBjb25zdCBpbm5lciA9IHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignI2xlb25hcmRvLWV4cG9ydGVkLWNvZGUgcHJlJykuaW5uZXJIVE1MIHx8ICcnO1xuICAgIGNvbnN0IHRleHQgPSBTdHJpbmdIZWxwZXIudHJpbShpbm5lcikucmVwbGFjZSgvPGJyPi9nLCAnXFxyXFxuJyk7XG5cbiAgICBpZiAod2luZG93LmNsaXBib2FyZERhdGEgJiYgd2luZG93LmNsaXBib2FyZERhdGEuc2V0RGF0YSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoJ1RleHQnLCB0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCAmJiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoJ2NvcHknKSkge1xuICAgICAgdmFyIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgIHRleHRhcmVhLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIHRleHRhcmVhLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dGFyZWEpO1xuICAgICAgdGV4dGFyZWEuc2VsZWN0KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ29weSB0byBjbGlwYm9hcmQgZmFpbGVkLicsIGV4KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0YXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gT3ZlcnJpZGUgYmFzZSBzbyB3ZSBkb250IGNsZWFyIHZpZXdOb2RlXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxufVxuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uL3VpLXV0aWxzJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vLi4vdWktZXZlbnRzJztcbmltcG9ydCBSZWNvcmRlclN0YXRlRGV0YWlsIGZyb20gXCIuLi9zdGF0ZS1kZXRhaWwvc3RhdGVzLWRldGFpbFwiO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnLi4vLi4vLi4vRE9NRWxlbWVudCc7XG5pbXBvcnQge0V2ZW50U3VifSBmcm9tICcuLi8uLi8uLi91aS1ldmVudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNvcmRlckxpc3QgZXh0ZW5kcyBET01FbGVtZW50IHtcblxuICBzdGF0ZURldGFpbDogUmVjb3JkZXJTdGF0ZURldGFpbCA9IG5ldyBSZWNvcmRlclN0YXRlRGV0YWlsKCk7XG4gIHN0YXRlRGV0YWlsc1N0YXRlOiBib29sZWFuID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGA8ZGl2IGlkPVwibGVvbmFyZG8tcmVjb3JkZXItbGlzdFwiIGNsYXNzPVwibGVvbmFyZG8tcmVjb3JkZXItbGlzdFwiPjwvZGl2PmApO1xuXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5jbGVhckV2ZW50U3VicygpO1xuICAgIGNvbnN0IGxpc3QgPSBVdGlscy5nZXRFbGVtZW50RnJvbUh0bWwoYDx1bCBjbGFzcz1cImxlb25hcmRvLXJlY29yZGVyLWxpc3QtY29udGFpbmVyXCI+PC91bD5gKTtcbiAgICB0aGlzLmdldFN0YXRlSXRlbXMoKS5mb3JFYWNoKChpdGVtKSA9PiB7bGlzdC5hcHBlbmRDaGlsZChpdGVtKX0pO1xuICAgIHRoaXMudmlld05vZGUuYXBwZW5kQ2hpbGQobGlzdCk7XG4gICAgRXZlbnRzLmRpc3BhdGNoKEV2ZW50cy5BVFRBQ0hfTUVOVV9JVEVNLCB0aGlzLnN0YXRlRGV0YWlsLmdldCgpKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3RhdGVJdGVtcygpOiBBcnJheTxhbnk+IHtcbiAgICByZXR1cm4gTGVvbmFyZG8uZ2V0UmVjb3JkZWRTdGF0ZXMoKS5tYXAoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gVXRpbHMuZ2V0RWxlbWVudEZyb21IdG1sKGA8bGkgY2xhc3M9XCJsZW9uYXJkby1yZWNvcmRlci1saXN0LWl0ZW1cIj5gKTtcbiAgICAgIGl0ZW0uaW5uZXJIVE1MID1cbiAgICAgICAgICBgPHNwYW4gY2xhc3M9XCJsZW9uYXJkby1yZWNvcmRlci1saXN0LXZlcmIgbGVvbmFyZG8tcmVjb3JkZXItbGlzdC12ZXJiLSR7c3RhdGUudmVyYi50b0xvd2VyQ2FzZSgpfVwiPiR7c3RhdGUudmVyYn08L3NwYW4+XG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGVvbmFyZG8tcmVjb3JkZXItbGlzdC11cmxcIj4ke3N0YXRlLnVybC5zdWJzdHIoMCwxMTApfTwvc3Bhbj5gO1xuICAgICAgaXRlbS5pbm5lckhUTUwgKz0gc3RhdGUucmVjb3JkZWQgPyBgPHNwYW4gY2xhc3M9XCJsZW9uYXJkby1yZWNvcmRlci1saXN0LW5hbWVcIj4ke3N0YXRlLm5hbWV9PC9zcGFuPmAgOlxuICAgICAgICBgPHNwYW4gY2xhc3M9XCJsZW9uYXJkby1yZWNvcmRlci1saXN0LW5hbWUgbGVvbmFyZG8tcmVjb3JkZXItbGlzdC1uYW1lLW5ld1wiPk5ldzwvc3Bhbj5gO1xuICAgICAgdGhpcy5vbkl0ZW0oaXRlbSwgJ2NsaWNrJywgdGhpcy50b2dnbGVEZXRhaWxzLmJpbmQodGhpcywgc3RhdGUpKTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pXG4gIH1cblxuICB0b2dnbGVEZXRhaWxzKHN0YXRlLCBldmVudCl7XG4gICAgdGhpcy5zdGF0ZURldGFpbHNTdGF0ZSA9ICF0aGlzLnN0YXRlRGV0YWlsc1N0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2xhc3M6IHN0cmluZyA9ICdsZW9uYXJkby1yZWNvcmRlci1pdGVtLXNlbGVjdGVkJztcbiAgICB0aGlzLnN0YXRlRGV0YWlsc1N0YXRlID8gZXZlbnQuY3VycmVudFRhcmdldC5jbGFzc0xpc3QuYWRkKHNlbGVjdGVkQ2xhc3MpIDogZXZlbnQuY3VycmVudFRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKHNlbGVjdGVkQ2xhc3MpO1xuICAgIHRoaXMuc3RhdGVEZXRhaWxzU3RhdGUgJiYgKHN0YXRlLmFjdGl2ZU9wdGlvbiA9IHN0YXRlLm9wdGlvbnNbMF0pO1xuICAgIHRoaXMuc3RhdGVEZXRhaWwudG9nZ2xlKHN0YXRlKTtcbiAgfVxuXG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vbGVvbmFyZG8uZC50c1wiIC8+XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdWktdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi91aS1ldmVudHMnO1xuaW1wb3J0IFJlY29yZGVyTGlzdCBmcm9tICcuL3JlY29yZGVyLWxpc3QvcmVjb3JkZXItbGlzdCc7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICcuLi8uLi9ET01FbGVtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjb3JkZXIgZXh0ZW5kcyBET01FbGVtZW50IHtcblxuICByZWNvcmRlckxpc3Q6IFJlY29yZGVyTGlzdDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgPGRpdiBpZD1cImxlb25hcmRvLXJlY29yZGVyXCIgY2xhc3M9XCJsZW9uYXJkby1yZWNvcmRlclwiPC9kaXY+YCk7XG4gICAgdGhpcy5yZWNvcmRlckxpc3QgPSBuZXcgUmVjb3JkZXJMaXN0KCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy52aWV3Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnJlY29yZGVyTGlzdC5nZXQoKSk7XG4gICAgdGhpcy5yZWNvcmRlckxpc3QucmVuZGVyKCk7XG4gIH1cblxuICAvLyBPdmVycmlkZSBiYXNlIHNvIHdlIGRvbnQgY2xlYXIgdmlld05vZGVcbiAgZGVzdHJveSgpIHtcblxuICB9XG59XG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vdWktdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi8uLi91aS1ldmVudHMnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnLi4vLi4vLi4vRE9NRWxlbWVudCc7XG5pbXBvcnQgQ29kZUVkaXRvciBmcm9tICcuLi8uLi8uLi9jb2RlLWVkaXRvci9jb2RlLWVkaXRvcic7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNvcmRlclN0YXRlRGV0YWlsIGV4dGVuZHMgRE9NRWxlbWVudCB7XG4gIG9wZW5TdGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBjdXJTdGF0ZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgPGRpdiBpZD1cImxlb25hcmRvLXN0YXRlLWRldGFpbFwiIGNsYXNzPVwibGVvbmFyZG8tc3RhdGUtZGV0YWlsLXJlY29yZGVyXCI+PC9kaXY+YCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgbGV0IGh0bWw7XG5cbiAgICAvL1RPRE8gY29uZ3JhdHVsYXRlIG91cnNlbHZlcyBvbiBiZWluZyBhd2Vzb21lISFcbiAgICBpZiAodGhpcy5jdXJTdGF0ZS5yZWNvcmRlZCkge1xuICAgICAgaHRtbCA9IGA8ZGl2IGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWRldGFpbC10b3BcIj5BZGQgbW9ja2VkIHJlc3BvbnNlIGZvciA8c3Ryb25nPiR7dGhpcy5jdXJTdGF0ZS5uYW1lfTwvc3Ryb25nPjwvZGl2PmA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaHRtbCA9IGA8aDEgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLXRvcFwiLz5BZGQgbmV3IHN0YXRlPC9oMT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxlb25hcmRvLXN0YXRlcy1kZXRhaWwtaW5wdXRcIj5TdGF0ZSBuYW1lOiA8aW5wdXQgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLXN0YXRlLW5hbWVcIiB2YWx1ZT1cIiR7dGhpcy5jdXJTdGF0ZS5uYW1lfVwiLz48L2Rpdj5gO1xuICAgIH1cblxuICAgIGh0bWwgKz0gYDxkaXYgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWlucHV0XCI+PGRpdj5VUkw6IDwvZGl2PjxpbnB1dCBjbGFzcz1cImxlb25hcmRvLXN0YXRlcy1kZXRhaWwtb3B0aW9uLXVybFwiIHZhbHVlPVwiJHt0aGlzLmN1clN0YXRlLnVybH1cIi8+PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWlucHV0XCI+PGRpdj5PcHRpb24gbmFtZTogPC9kaXY+PGlucHV0IGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWRldGFpbC1vcHRpb24tbmFtZVwiIHZhbHVlPVwiJHt0aGlzLmN1clN0YXRlLm9wdGlvbnNbMF0ubmFtZX1cIi8+PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWlucHV0XCI+PGRpdj5TdGF0dXMgY29kZTogPC9kaXY+PGlucHV0IGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWRldGFpbC1zdGF0dXNcIiB2YWx1ZT1cIiR7dGhpcy5jdXJTdGF0ZS5vcHRpb25zWzBdLnN0YXR1c31cIi8+PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWlucHV0XCI+PGRpdj5EZWxheTogPC9kaXY+PGlucHV0IGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWRldGFpbC1kZWxheVwiIHZhbHVlPVwiMFwiLz48L2Rpdj5cbiAgICAgICAgICAgICAgPGJyLz5cbiAgICAgICAgICAgICAgPHNwYW4+UmVzcG9uc2U6PC9zcGFuPiAgICA8YnV0dG9uIGNsYXNzPVwibGVvbmFyZG8tYnV0dG9uIGxlb25hcmRvLXN0YXRlcy1kZXRhaWwtZWRpdFwiPkFkdmFuY2VkPC9idXR0b24+IFxuICAgICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWpzb25cIj4ke3RoaXMuZ2V0UmVzU3RyaW5nKHRoaXMuY3VyU3RhdGUub3B0aW9uc1swXS5kYXRhKX08L3RleHRhcmVhPjwvcD5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxlb25hcmRvLXN0YXRlcy1kZXRhaWwtYnV0dG9uc1wiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJsZW9uYXJkby1idXR0b24gbGVvbmFyZG8tc3RhdGVzLWRldGFpbC1zYXZlXCI+U2F2ZTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJsZW9uYXJkby1idXR0b24gbGVvbmFyZG8tc3RhdGVzLWRldGFpbC1jYW5jZWxcIiA+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvZGl2PmA7XG5cbiAgICB0aGlzLnZpZXdOb2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgRXZlbnRzLm9uSXRlbSh0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5sZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWVkaXQnKSwgJ2NsaWNrJywgdGhpcy5lZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICBFdmVudHMub25JdGVtT25jZSh0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5sZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWNhbmNlbCcpLCAnY2xpY2snLCB0aGlzLm9uQ2FuY2VsLmJpbmQodGhpcykpO1xuICAgIEV2ZW50cy5vbkl0ZW1PbmNlKHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignLmxlb25hcmRvLXN0YXRlcy1kZXRhaWwtc2F2ZScpLCAnY2xpY2snLCB0aGlzLm9uU2F2ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIG9wZW4oc3RhdGUpIHtcbiAgICB0aGlzLmN1clN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICB0aGlzLm9wZW5TdGF0ZSA9IHRydWU7XG4gICAgRXZlbnRzLmRpc3BhdGNoKEV2ZW50cy5PUEVOX01FTlUpO1xuICB9XG5cbiAgZWRpdE1vZGUoKXtcbiAgICBjb25zdCBlZGl0b3IgPSBuZXcgQ29kZUVkaXRvcih0aGlzLmNsb3NlRWRpdE1vZGUuYmluZCh0aGlzKSwgdGhpcy5jbG9zZUVkaXRNb2RlLmJpbmQodGhpcyksIHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcihcIi5sZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWpzb25cIikudmFsdWUpO1xuICAgIGVkaXRvci5yZW5kZXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgY2xvc2VFZGl0TW9kZShkYXRhKXtcbiAgICBpZighZGF0YSl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcihcIi5sZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWpzb25cIikudmFsdWUgPSB0aGlzLmdldFJlc1N0cmluZyhkYXRhKTtcbiAgfVxuXG4gIGNsb3NlKHN0YXRlPykge1xuICAgIGlmIChzdGF0ZSAmJiB0aGlzLmN1clN0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgdGhpcy5vcGVuKHN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVuU3RhdGUgPSBmYWxzZTtcbiAgICBFdmVudHMuZGlzcGF0Y2goRXZlbnRzLkNMT1NFX01FTlUpO1xuICB9XG5cbiAgdG9nZ2xlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMub3BlblN0YXRlKSB7XG4gICAgICB0aGlzLmNsb3NlKHN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVuKHN0YXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmVzU3RyaW5nKHJlc29wbnNlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCByZXNTdHI6IHN0cmluZztcblxuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiByZXNvcG5zZSl7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICByZXNTdHIgPSByZXNvcG5zZS50b1N0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIHJlc1N0ciA9IEpTT04uc3RyaW5naWZ5KHJlc29wbnNlLCBudWxsLCA0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcmVzU3RyID0gcmVzb3Buc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIHJlc1N0cjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1N0cjtcbiAgfVxuXG4gIHByaXZhdGUgb25DYW5jZWwoZXZlbnQ6IEV2ZW50KSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBvblNhdmUoKSB7XG4gICAgY29uc3QgdXJsVmFsOiBzdHJpbmcgPSB0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoXCIubGVvbmFyZG8tc3RhdGVzLWRldGFpbC1vcHRpb24tdXJsXCIpLnZhbHVlO1xuICAgIGNvbnN0IHN0YXR1c1ZhbDogc3RyaW5nID0gdGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKFwiLmxlb25hcmRvLXN0YXRlcy1kZXRhaWwtc3RhdHVzXCIpLnZhbHVlO1xuICAgIGNvbnN0IGRlbGF5VmFsOiBzdHJpbmcgPSB0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoXCIubGVvbmFyZG8tc3RhdGVzLWRldGFpbC1kZWxheVwiKS52YWx1ZTtcbiAgICBjb25zdCBqc29uVmFsOiBzdHJpbmcgPSB0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoXCIubGVvbmFyZG8tc3RhdGVzLWRldGFpbC1qc29uXCIpLnZhbHVlO1xuICAgIGNvbnN0IG9wdGlvbk5hbWVWYWw6IHN0cmluZyA9IHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcihcIi5sZW9uYXJkby1zdGF0ZXMtZGV0YWlsLW9wdGlvbi1uYW1lXCIpLnZhbHVlO1xuICAgIHRoaXMuY3VyU3RhdGUudXJsID0gdXJsVmFsO1xuICAgIHRoaXMuY3VyU3RhdGUuYWN0aXZlT3B0aW9uLnN0YXR1cyA9IHN0YXR1c1ZhbDtcbiAgICB0aGlzLmN1clN0YXRlLmFjdGl2ZU9wdGlvbi5kZWxheSA9IGRlbGF5VmFsO1xuICAgIHRoaXMuY3VyU3RhdGUuYWN0aXZlT3B0aW9uLm5hbWUgPSBvcHRpb25OYW1lVmFsO1xuICAgIGlmICghdGhpcy5jdXJTdGF0ZS5yZWNvcmRlZCkge1xuICAgICAgdGhpcy5jdXJTdGF0ZS5uYW1lID0gdGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKCcubGVvbmFyZG8tc3RhdGVzLWRldGFpbC1zdGF0ZS1uYW1lJykudmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG5cbiAgICAgIHRoaXMuY3VyU3RhdGUuYWN0aXZlT3B0aW9uLmRhdGEgPSBKU09OLnBhcnNlKGpzb25WYWwpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5jdXJTdGF0ZS5hY3RpdmVPcHRpb24uZGF0YSA9IGpzb25WYWw7XG4gICAgfVxuXG5cbiAgICBMZW9uYXJkby5hZGRPclVwZGF0ZVNhdmVkU3RhdGUodGhpcy5jdXJTdGF0ZSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vbGVvbmFyZG8uZC50c1wiIC8+XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vdWktdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi8uLi91aS1ldmVudHMnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnLi4vLi4vLi4vRE9NRWxlbWVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5hcmlvc0xpc3QgZXh0ZW5kcyBET01FbGVtZW50IHtcblxuICBzdGF0aWMgU0VMRUNURURfQ0xBU1MgPSAnbGVvbmFyZG8tc2VsZWN0ZWQtc2NlbmFyaW8nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGA8ZGl2IGlkPVwibGVvbmFyZG8tc2NlbmFyaW9zLWxpc3RcIiBjbGFzcz1cImxlb25hcmRvLXNjZW5hcmlvcy1saXN0XCI+PC9kaXY+YCk7XG4gICAgdGhpcy5ib2R5RXZlbnRzU3Vicy5wdXNoKEV2ZW50cy5vbihFdmVudHMuQUREX1NDRU5BUklPLCB0aGlzLmFkZFNjZW5hcmlvLmJpbmQodGhpcykpKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmNsZWFyRXZlbnRTdWJzKCk7XG4gICAgdGhpcy52aWV3Tm9kZS5hcHBlbmRDaGlsZChVdGlscy5nZXRFbGVtZW50RnJvbUh0bWwoYDxkaXY+U2NlbmFyaW9zPC9kaXY+YCkpO1xuICAgIGNvbnN0IHVsID0gVXRpbHMuZ2V0RWxlbWVudEZyb21IdG1sKGA8dWw+PC91bD5gKTtcbiAgICBMZW9uYXJkby5nZXRTY2VuYXJpb3MoKVxuICAgICAgLm1hcCh0aGlzLmdldFNjZW5hcmlvRWxlbWVudC5iaW5kKHRoaXMpKVxuICAgICAgLmZvckVhY2goKHNjZW5hcmlvRWxtKSA9PiB7XG4gICAgICAgIHVsLmFwcGVuZENoaWxkKHNjZW5hcmlvRWxtKTtcbiAgICAgIH0pO1xuICAgIHRoaXMudmlld05vZGUuYXBwZW5kQ2hpbGQodWwpO1xuXG4gIH1cblxuICBnZXRTY2VuYXJpb0VsZW1lbnQoc2NlbmFyaW8pIHtcbiAgICBjb25zdCBlbCA9IFV0aWxzLmdldEVsZW1lbnRGcm9tSHRtbChgPGxpPiR7c2NlbmFyaW99PC9saT5gKTtcbiAgICB0aGlzLm9uSXRlbShlbCwgJ2NsaWNrJywgdGhpcy5zZXRTY2VuYXJpby5iaW5kKHRoaXMsIHNjZW5hcmlvLCBlbCkpO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHByaXZhdGUgc2V0U2NlbmFyaW8oc2NlbmFyaW86IHN0cmluZywgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3Qgc3RhdGVzOiBBcnJheTxhbnk+ID0gTGVvbmFyZG8uZ2V0U2NlbmFyaW8oc2NlbmFyaW8pO1xuICAgIEV2ZW50cy5kaXNwYXRjaChFdmVudHMuVE9HR0xFX1NUQVRFUywgZmFsc2UpO1xuICAgIHN0YXRlcy5mb3JFYWNoKChzdGF0ZSk9PiB7XG4gICAgICBFdmVudHMuZGlzcGF0Y2goYCR7RXZlbnRzLlRPR0dMRV9TVEFURVN9OiR7c3RhdGUubmFtZX1gLCBzdGF0ZS5vcHRpb24pO1xuICAgIH0pO1xuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvckFsbCgnbGknKSwgMClcbiAgICAgIC5mb3JFYWNoKGxpID0+IGxpLmNsYXNzTGlzdC5yZW1vdmUoU2NlbmFyaW9zTGlzdC5TRUxFQ1RFRF9DTEFTUykpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoU2NlbmFyaW9zTGlzdC5TRUxFQ1RFRF9DTEFTUyk7XG5cbiAgfVxuXG4gIHByaXZhdGUgYWRkU2NlbmFyaW8oZXZlbnQ6IEN1c3RvbUV2ZW50KSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxufVxuIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uL2xlb25hcmRvLmQudHNcIiAvPlxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3VpLXV0aWxzJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vdWktZXZlbnRzJztcbmltcG9ydCBTdGF0ZXNMaXN0IGZyb20gJy4vc3RhdGVzLWxpc3Qvc3RhdGVzLWxpc3QnO1xuaW1wb3J0IFNjZW5hcmlvc0xpc3QgZnJvbSAnLi9zY2VuYXJpb3MtbGlzdC9zY2VuYXJpb3MtbGlzdCc7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICcuLi8uLi9ET01FbGVtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmFyaW9zIGV4dGVuZHMgRE9NRWxlbWVudHtcblxuICBzdGF0ZUxpc3Q6IFN0YXRlc0xpc3Q7XG4gIHNjZW5hcmlvc0xpc3Q6IFNjZW5hcmlvc0xpc3Q7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYDxkaXYgaWQ9XCJsZW9uYXJkby1zY2VuYXJpb3NcIiBjbGFzcz1cImxlb25hcmRvLXNjZW5hcmlvc1wiPjwvZGl2PmApO1xuICAgIHRoaXMuc3RhdGVMaXN0ID0gbmV3IFN0YXRlc0xpc3QoKTtcbiAgICB0aGlzLnNjZW5hcmlvc0xpc3QgPSBuZXcgU2NlbmFyaW9zTGlzdCgpO1xuICAgIHRoaXMudmlld05vZGUuYXBwZW5kQ2hpbGQodGhpcy5zY2VuYXJpb3NMaXN0LmdldCgpKTtcbiAgICB0aGlzLnZpZXdOb2RlLmFwcGVuZENoaWxkKHRoaXMuc3RhdGVMaXN0LmdldCgpKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnN0YXRlTGlzdC5yZW5kZXIoKTtcbiAgICB0aGlzLnNjZW5hcmlvc0xpc3QucmVuZGVyKCk7XG4gIH1cblxuICAvLyBPdmVycmlkZSBiYXNlIHNvIHdlIGRvbnQgY2xlYXIgdmlld05vZGVcbiAgZGVzdHJveSgpIHtcblxuICB9XG59XG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vdWktdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi8uLi8uLi91aS1ldmVudHMnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnLi4vLi4vLi4vLi4vRE9NRWxlbWVudCc7XG5pbXBvcnQgQ29kZUVkaXRvciBmcm9tICcuLi8uLi8uLi8uLi9jb2RlLWVkaXRvci9jb2RlLWVkaXRvcic7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZURldGFpbCBleHRlbmRzIERPTUVsZW1lbnQge1xuXG4gIG9wZW5TdGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBjdXJTdGF0ZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9uU2F2ZUNCLCBwcml2YXRlIG9uQ2FuY2VsQ0IpIHtcbiAgICBzdXBlcihgPGRpdiBpZD1cImxlb25hcmRvLXN0YXRlLWRldGFpbFwiIGNsYXNzPVwibGVvbmFyZG8tc3RhdGUtZGV0YWlsXCI+PC9kaXY+YCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy52aWV3Tm9kZS5pbm5lckhUTUwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWRldGFpbC1jb250YWluZXJcIj4gXG4gICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLXRvcFwiPkVkaXQgb3B0aW9uIDxzdHJvbmc+JHt0aGlzLmN1clN0YXRlLmFjdGl2ZU9wdGlvbi5uYW1lfTwvc3Ryb25nPlxuICAgICAgICBmb3IgPHN0cm9uZz4ke3RoaXMuY3VyU3RhdGUubmFtZX08L3N0cm9uZz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWRldGFpbC1pbnB1dFwiPjxkaXY+U3RhdHVzIGNvZGU6IDwvZGl2PjxpbnB1dCBjbGFzcz1cImxlb25hcmRvLXN0YXRlcy1kZXRhaWwtc3RhdHVzXCIgdmFsdWU9XCIke3RoaXMuY3VyU3RhdGUuYWN0aXZlT3B0aW9uLnN0YXR1c31cIi8+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWlucHV0XCI+PGRpdj5EZWxheTogPC9kaXY+PGlucHV0IGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWRldGFpbC1kZWxheVwiIHZhbHVlPVwiJHt0aGlzLmN1clN0YXRlLmFjdGl2ZU9wdGlvbi5kZWxheX1cIi8+PC9kaXY+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGJyLz4gXG4gICAgICAgICAgPHNwYW4+UmVzcG9uc2U6PC9zcGFuPiAgICA8YnV0dG9uIGNsYXNzPVwibGVvbmFyZG8tYnV0dG9uIGxlb25hcmRvLXN0YXRlcy1kZXRhaWwtZWRpdFwiPkFkdmFuY2VkPC9idXR0b24+ICAgICAgXG4gICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWRldGFpbC1qc29uXCI+JHt0aGlzLmdldFJlc1N0cmluZyh0aGlzLmN1clN0YXRlLmFjdGl2ZU9wdGlvbi5kYXRhKX08L3RleHRhcmVhPiAgICAgICAgICBcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWJ1dHRvbnNcIj4gICAgICAgIFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJsZW9uYXJkby1idXR0b24gbGVvbmFyZG8tc3RhdGVzLWRldGFpbC1zYXZlXCI+U2F2ZTwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJsZW9uYXJkby1idXR0b24gbGVvbmFyZG8tc3RhdGVzLWRldGFpbC1jYW5jZWxcIiA+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgIDwvZGl2PmA7XG4gICAgICAgIEV2ZW50cy5vbkl0ZW0odGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKCcubGVvbmFyZG8tc3RhdGVzLWRldGFpbC1lZGl0JyksICdjbGljaycsIHRoaXMuZWRpdE1vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIEV2ZW50cy5vbkl0ZW1PbmNlKHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignLmxlb25hcmRvLXN0YXRlcy1kZXRhaWwtY2FuY2VsJyksJ2NsaWNrJywgdGhpcy5vbkNhbmNlbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgRXZlbnRzLm9uSXRlbU9uY2UodGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKCcubGVvbmFyZG8tc3RhdGVzLWRldGFpbC1zYXZlJyksICdjbGljaycsIHRoaXMub25TYXZlLmJpbmQodGhpcykpO1xuXG4gIH1cblxuICBvcGVuKHN0YXRlKSB7XG4gICAgdGhpcy5jdXJTdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgdGhpcy5vcGVuU3RhdGUgPSB0cnVlO1xuICAgIEV2ZW50cy5kaXNwYXRjaChFdmVudHMuT1BFTl9NRU5VKTtcbiAgfVxuXG4gIGNsb3NlKHN0YXRlPykge1xuICAgIGlmKHN0YXRlICYmIHRoaXMuY3VyU3RhdGUgIT09IHN0YXRlKXtcbiAgICAgIHRoaXMub3BlbihzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vcGVuU3RhdGUgPSBmYWxzZTtcbiAgICBFdmVudHMuZGlzcGF0Y2goRXZlbnRzLkNMT1NFX01FTlUpO1xuICB9XG5cbiAgdG9nZ2xlKHN0YXRlKSB7XG4gICAgaWYodGhpcy5vcGVuU3RhdGUpe1xuICAgICAgdGhpcy5jbG9zZShzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlbihzdGF0ZSk7XG4gIH1cblxuICBlZGl0TW9kZSgpe1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyBDb2RlRWRpdG9yKHRoaXMuY2xvc2VFZGl0TW9kZS5iaW5kKHRoaXMpLCB0aGlzLmNsb3NlRWRpdE1vZGUuYmluZCh0aGlzKSwgdGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKFwiLmxlb25hcmRvLXN0YXRlcy1kZXRhaWwtanNvblwiKS52YWx1ZSk7XG4gICAgZWRpdG9yLnJlbmRlcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBjbG9zZUVkaXRNb2RlKGRhdGEpe1xuICAgIGlmKCFkYXRhKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKFwiLmxlb25hcmRvLXN0YXRlcy1kZXRhaWwtanNvblwiKS52YWx1ZSA9IHRoaXMuZ2V0UmVzU3RyaW5nKGRhdGEpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRSZXNTdHJpbmcocmVzb3Buc2U6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IHJlc1N0cjogc3RyaW5nO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiByZXNvcG5zZSl7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICByZXNTdHIgPSByZXNvcG5zZS50b1N0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIHJlc1N0ciA9IEpTT04uc3RyaW5naWZ5KHJlc29wbnNlLCBudWxsLCA0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcmVzU3RyID0gcmVzb3Buc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIHJlc1N0cjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1N0cjtcbiAgfVxuXG4gIHByaXZhdGUgb25DYW5jZWwoKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIHRoaXMub25DYW5jZWxDQigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvblNhdmUoKSB7XG4gICAgY29uc3Qgc3RhdHVzVmFsOnN0cmluZyA9IHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcihcIi5sZW9uYXJkby1zdGF0ZXMtZGV0YWlsLXN0YXR1c1wiKS52YWx1ZTtcbiAgICBjb25zdCBkZWxheVZhbDpzdHJpbmcgPSB0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoXCIubGVvbmFyZG8tc3RhdGVzLWRldGFpbC1kZWxheVwiKS52YWx1ZTtcbiAgICBjb25zdCBqc29uVmFsOnN0cmluZyA9IHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcihcIi5sZW9uYXJkby1zdGF0ZXMtZGV0YWlsLWpzb25cIikudmFsdWU7XG5cbiAgICB0aGlzLmN1clN0YXRlLmFjdGl2ZU9wdGlvbi5zdGF0dXMgPSBzdGF0dXNWYWw7XG4gICAgdGhpcy5jdXJTdGF0ZS5hY3RpdmVPcHRpb24uZGVsYXkgPSBkZWxheVZhbDtcbiAgICB0cnl7XG4gICAgICBpZihqc29uVmFsLnRyaW0oKS5pbmRleE9mKCdmdW5jdGlvbicpID09PSAwKXtcbiAgICAgICAgdGhpcy5jdXJTdGF0ZS5hY3RpdmVPcHRpb24uZGF0YSA9IGV2YWwoJygnICsganNvblZhbCArICcpJyk7XG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICB0aGlzLmN1clN0YXRlLmFjdGl2ZU9wdGlvbi5kYXRhID0gSlNPTi5wYXJzZShqc29uVmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgdGhpcy5jdXJTdGF0ZS5hY3RpdmVPcHRpb24uZGF0YSA9IGpzb25WYWw7XG4gICAgfVxuXG4gICAgTGVvbmFyZG8uYWRkT3JVcGRhdGVTYXZlZFN0YXRlKHRoaXMuY3VyU3RhdGUpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICB0aGlzLm9uU2F2ZUNCKCk7XG4gIH1cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi8uLi9sZW9uYXJkby5kLnRzXCIgLz5cbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi8uLi91aS11dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uLy4uLy4uL3VpLWV2ZW50cyc7XG5pbXBvcnQgRHJvcERvd24gZnJvbSAnLi4vLi4vLi4vLi4vZHJvcC1kb3duL2Ryb3AtZG93bic7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICcuLi8uLi8uLi8uLi9ET01FbGVtZW50JztcbmltcG9ydCB7RXZlbnRTdWJ9IGZyb20gJy4uLy4uLy4uLy4uL3VpLWV2ZW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlSXRlbSBleHRlbmRzIERPTUVsZW1lbnQge1xuXG4gIHJhbmRvbUlEOiBzdHJpbmc7XG4gIGRyb3BEb3duOiBEcm9wRG93bjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0YXRlLCBwcml2YXRlIG9uUmVtb3ZlOiBGdW5jdGlvbikge1xuICAgIHN1cGVyKGA8ZGl2IGNsYXNzPVwibGVvbmFyZG8tc3RhdGUtaXRlbVwiPjwvZGl2PmApO1xuXG4gICAgdGhpcy5yYW5kb21JRCA9IFV0aWxzLmd1aWRHZW5lcmF0b3IoKTtcbiAgICB0aGlzLmRyb3BEb3duID0gbmV3IERyb3BEb3duKHRoaXMuc3RhdGUub3B0aW9ucywgdGhpcy5zdGF0ZS5hY3RpdmVPcHRpb24gfHwgdGhpcy5zdGF0ZS5vcHRpb25zWzBdLCAhdGhpcy5zdGF0ZS5hY3RpdmUsIHRoaXMuY2hhbmdlQWN0aXZlT3B0aW9uLmJpbmQodGhpcyksIHRoaXMucmVtb3ZlT3B0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYm9keUV2ZW50c1N1YnMucHVzaChFdmVudHMub24oRXZlbnRzLlRPR0dMRV9TVEFURVMsIHRoaXMudG9nZ2xlQWxsc3RhdGUuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuYm9keUV2ZW50c1N1YnMucHVzaChFdmVudHMub24oYCR7RXZlbnRzLlRPR0dMRV9TVEFURVN9OiR7dGhpcy5zdGF0ZS5uYW1lfWAsIHRoaXMuc2V0U3RhdGVTdGF0ZS5iaW5kKHRoaXMpKSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy52aWV3Tm9kZS5pbm5lckhUTUwgPSBgXG4gICAgICAgIDxpbnB1dCAke3RoaXMuaXNDaGVja2VkKCl9IGlkPVwibGVvbmFyZG8tc3RhdGUtdG9nZ2xlLSR7dGhpcy5yYW5kb21JRH1cIiBjbGFzcz1cImxlb25hcmRvLXRvZ2dsZSBsZW9uYXJkby10b2dnbGUtaW9zXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJsZW9uYXJkby10b2dnbGUtYnRuXCIgZm9yPVwibGVvbmFyZG8tc3RhdGUtdG9nZ2xlLSR7dGhpcy5yYW5kb21JRCB9XCI+PC9sYWJlbD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJsZW9uYXJkby1zdGF0ZS12ZXJiIGxlb25hcmRvLXN0YXRlLXZlcmItJHt0aGlzLnN0YXRlLnZlcmIudG9Mb3dlckNhc2UoKX1cIj4ke3RoaXMuc3RhdGUudmVyYn08L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibGVvbmFyZG8tc3RhdGUtZGF0YS1jb250YWluZXJcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImxlb25hcmRvLXN0YXRlLW5hbWVcIj4ke3RoaXMuc3RhdGUubmFtZX08L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJsZW9uYXJkby1zdGF0ZS11cmxcIj4ke3RoaXMuc3RhdGUudXJsIHx8ICcnfTwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPmA7XG4gICAgdGhpcy52aWV3Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmRyb3BEb3duLmdldCgpKTtcbiAgICB0aGlzLmRyb3BEb3duLnJlbmRlcigpO1xuICAgIHRoaXMudmlld05vZGUuYXBwZW5kQ2hpbGQoVXRpbHMuZ2V0RWxlbWVudEZyb21IdG1sKGA8ZGl2IHRpdGxlPVwiUmVtb3ZlIFN0YXRlXCIgY2xhc3M9XCJsZW9uYXJkby14LWJ0biBsZW9uYXJkby1zdGF0ZS1yZW1vdmVcIj48L2Rpdj5gKSk7XG4gICAgdGhpcy5vbkl0ZW0odGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKGAubGVvbmFyZG8tdG9nZ2xlLWJ0bmApLCAnY2xpY2snLCB0aGlzLnRvZ2dsZVN0YXRlLmJpbmQodGhpcykpO1xuICAgIEV2ZW50cy5vbkl0ZW1PbmNlKHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcihgLmxlb25hcmRvLXN0YXRlLXJlbW92ZWApLCAnY2xpY2snLCB0aGlzLnJlbW92ZVN0YXRlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5uYW1lO1xuICB9XG5cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICB0b2dnbGVWaXNpYmxlKHNob3c6IGJvb2xlYW4pIHtcbiAgICBpZiAoc2hvdykge1xuICAgICAgdGhpcy52aWV3Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdsZW9uYXJkby1zdGF0ZS1pdGVtLWhpZGRlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpZXdOb2RlLmNsYXNzTGlzdC5hZGQoJ2xlb25hcmRvLXN0YXRlLWl0ZW0taGlkZGVuJyk7XG4gICAgfVxuICB9XG5cbiAgc2V0U3RhdGUoc3RhdGU6IEJvb2xlYW4sIHNldFZpZXc6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgdGhpcy5zdGF0ZS5hY3RpdmUgPSBzdGF0ZTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIExlb25hcmRvLmFjdGl2YXRlU3RhdGVPcHRpb24odGhpcy5zdGF0ZS5uYW1lLCB0aGlzLnN0YXRlLmFjdGl2ZU9wdGlvbi5uYW1lKTtcbiAgICAgIHRoaXMuZHJvcERvd24uZW5hYmxlRHJvcERvd24oKTtcbiAgICAgIGlmIChzZXRWaWV3KSB7XG4gICAgICAgIHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignLmxlb25hcmRvLXRvZ2dsZScpWydjaGVja2VkJ10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIExlb25hcmRvLmRlYWN0aXZhdGVTdGF0ZSh0aGlzLnN0YXRlLm5hbWUpO1xuICAgICAgdGhpcy5kcm9wRG93bi5kaXNhYmxlRHJvcERvd24oKTtcbiAgICAgIGlmIChzZXRWaWV3KSB7XG4gICAgICAgIHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignLmxlb25hcmRvLXRvZ2dsZScpWydjaGVja2VkJ10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzQ2hlY2tlZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmFjdGl2ZSA/ICdjaGVja2VkJyA6ICcnO1xuICB9XG5cbiAgcHJpdmF0ZSB0b2dnbGVTdGF0ZShldmVudDogRXZlbnQpIHtcbiAgICB0aGlzLnNldFN0YXRlKCF0aGlzLnN0YXRlLmFjdGl2ZSwgZmFsc2UpO1xuICB9XG5cbiAgcHJpdmF0ZSB0b2dnbGVBbGxzdGF0ZShldmVudDogQ3VzdG9tRXZlbnQpIHtcbiAgICB0aGlzLnNldFN0YXRlKGV2ZW50LmRldGFpbCk7XG4gIH1cblxuICBwcml2YXRlIHNldFN0YXRlU3RhdGUoZXZlbnQ6IEN1c3RvbUV2ZW50KSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh0cnVlKTtcbiAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc29tZSgob3B0aW9uKSA9PiB7XG4gICAgICBpZiAob3B0aW9uLm5hbWUgPT09IGV2ZW50LmRldGFpbCkge1xuICAgICAgICB0aGlzLmRyb3BEb3duLnNldEFjdGl2ZUl0ZW0oZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VBY3RpdmVPcHRpb24ob3B0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgY2hhbmdlQWN0aXZlT3B0aW9uKG9wdGlvbikge1xuICAgIHRoaXMuc3RhdGUuYWN0aXZlT3B0aW9uID0gb3B0aW9uO1xuICAgIExlb25hcmRvLmFjdGl2YXRlU3RhdGVPcHRpb24odGhpcy5zdGF0ZS5uYW1lLCB0aGlzLnN0YXRlLmFjdGl2ZU9wdGlvbi5uYW1lKVxuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVTdGF0ZShldmVudDogRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLm9uUmVtb3ZlKHRoaXMuc3RhdGUubmFtZSwgdGhpcy52aWV3Tm9kZSk7XG4gICAgTGVvbmFyZG8ucmVtb3ZlU3RhdGUodGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZU9wdGlvbihpdGVtKSB7XG4gICAgTGVvbmFyZG8ucmVtb3ZlT3B0aW9uKHRoaXMuc3RhdGUsIGl0ZW0pO1xuICB9XG5cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi8uLi8uLi9sZW9uYXJkby5kLnRzXCIgLz5cbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi8uLi8uLi91aS11dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uLy4uLy4uLy4uL3VpLWV2ZW50cyc7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICcuLi8uLi8uLi8uLi8uLi9ET01FbGVtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRkU2NlbmFyaW8gZXh0ZW5kcyBET01FbGVtZW50e1xuXG4gIG9wZW5TdGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGA8ZGl2IGlkPVwibGVvbmFyZG8tYWRkLXNjZW5hcmlvXCIgY2xhc3M9XCJsZW9uYXJkby1hZGQtc2NlbmFyaW9cIj48L2Rpdj5gKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmNsZWFyRXZlbnRTdWJzKCk7XG4gICAgdGhpcy52aWV3Tm9kZS5pbm5lckhUTUwgPSBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJsZW9uYXJkby1hZGQtc2NlbmFyaW8tYm94XCI+XG4gICAgICAgICAgPHNwYW4+U2NlbmFyaW8gTmFtZTogPC9zcGFuPlxuICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImxlb25hcmRvLWFkZC1zY2VuYXJpby1uYW1lXCIvPlxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJsZW9uYXJkby1idXR0b24gbGVvbmFyZG8tYWRkLXNjZW5hcmlvLXNhdmVcIj5TYXZlPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImxlb25hcmRvLWJ1dHRvbiBsZW9uYXJkby1hZGQtc2NlbmFyaW8tY2FuY2VsXCI+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgIDwvZGl2PmA7XG4gICAgdGhpcy5vbkl0ZW0oPEhUTUxFbGVtZW50PnRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignLmxlb25hcmRvLWFkZC1zY2VuYXJpby1jYW5jZWwnKSwgJ2NsaWNrJywgdGhpcy5vbkNhbmNlbC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9uSXRlbSg8SFRNTEVsZW1lbnQ+dGhpcy52aWV3Tm9kZS5xdWVyeVNlbGVjdG9yKCcubGVvbmFyZG8tYWRkLXNjZW5hcmlvLXNhdmUnKSwgJ2NsaWNrJywgdGhpcy5vblNhdmUuYmluZCh0aGlzKSk7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgdGhpcy5vcGVuU3RhdGUgPSB0cnVlO1xuICAgIHRoaXMudmlld05vZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLm9wZW5TdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudmlld05vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG4gIHRvZ2dsZSgpIHtcbiAgICBpZih0aGlzLm9wZW5TdGF0ZSl7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkNhbmNlbCgpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICBwcml2YXRlIG9uU2F2ZSgpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgRXZlbnRzLmRpc3BhdGNoKEV2ZW50cy5BRERfU0NFTkFSSU8sIHRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignLmxlb25hcmRvLWFkZC1zY2VuYXJpby1uYW1lJykudmFsdWUpO1xuICB9XG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vLi4vbGVvbmFyZG8uZC50c1wiIC8+XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vdWktdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi8uLi8uLi91aS1ldmVudHMnO1xuaW1wb3J0IEFkZFNjZW5hcmlvIGZyb20gJy4vc3RhdGUtYWRkLXNjZW5hcmlvL3N0YXRlLWFkZC1zY2VuYXJpbyc7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICcuLi8uLi8uLi8uLi9ET01FbGVtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVzQmFyIGV4dGVuZHMgRE9NRWxlbWVudHtcbiAgYWN0aXZlQWxsU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgYWRkU2NlbmFyaW86IEFkZFNjZW5hcmlvID0gbmV3IEFkZFNjZW5hcmlvKCk7XG4gIGN1clNlYXJjaERhdGE6IHN0cmluZyA9ICcnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGA8ZGl2IGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWJhclwiPjwvZGl2PmApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuY2xlYXJFdmVudFN1YnMoKTtcbiAgICB0aGlzLnZpZXdOb2RlLmlubmVySFRNTCA9IGBcbiAgICAgICAgPGlucHV0IHZhbHVlPVwiJHt0aGlzLmN1clNlYXJjaERhdGF9XCIgY2xhc3M9XCJsZW9uYXJkby1zZWFyY2gtc3RhdGVcIiBuYW1lPVwibGVvbmFyZG8tc2VhcmNoLXN0YXRlXCIgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaC4uLlwiIC8+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJsZW9uYXJkby1idXR0b24gbGVvbmFyZG8tYWN0aXZhdGUtYWxsXCI+QWN0aXZhdGUgQWxsPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGVvbmFyZG8tYnV0dG9uIGxlb25hcmRvLWFkZC1zY2VuYXJpby1idG5cIj5BZGQgU2NlbmFyaW88L3NwYW4+XG4gICAgICAgIDwvZGl2PmA7XG4gICAgdGhpcy52aWV3Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmFkZFNjZW5hcmlvLmdldCgpKTtcbiAgICB0aGlzLmFkZFNjZW5hcmlvLnJlbmRlcigpO1xuICAgIHRoaXMub25JdGVtKDxIVE1MRWxlbWVudD50aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5sZW9uYXJkby1zZWFyY2gtc3RhdGUnKSwgJ2tleXVwJywgdGhpcy5zZWFyY2hTdGF0ZXMuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vbkl0ZW0oPEhUTUxFbGVtZW50PnRoaXMudmlld05vZGUucXVlcnlTZWxlY3RvcignLmxlb25hcmRvLWFjdGl2YXRlLWFsbCcpLCAnY2xpY2snLCB0aGlzLnRvZ2dsZUFjdGl2YXRlQWxsLmJpbmQodGhpcykpO1xuICAgIHRoaXMub25JdGVtKDxIVE1MRWxlbWVudD50aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5sZW9uYXJkby1hZGQtc2NlbmFyaW8tYnRuJyksICdjbGljaycsIHRoaXMub25BZGRTY2VuYXJpby5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNlYXJjaFN0YXRlcyh7dGFyZ2V0OiB7dmFsdWU6IHRoaXMuY3VyU2VhcmNoRGF0YX19KTtcbiAgfVxuXG4gIHNlYXJjaFN0YXRlcyhldnQpIHtcbiAgICB0aGlzLmN1clNlYXJjaERhdGEgPSBldnQudGFyZ2V0LnZhbHVlO1xuICAgIEV2ZW50cy5kaXNwYXRjaChFdmVudHMuRklMVEVSX1NUQVRFUywge3ZhbDogdGhpcy5jdXJTZWFyY2hEYXRhfSk7XG4gIH1cblxuICB0b2dnbGVBY3RpdmF0ZUFsbCgpIHtcbiAgICB0aGlzLmFjdGl2ZUFsbFN0YXRlID0gIXRoaXMuYWN0aXZlQWxsU3RhdGU7XG4gICAgTGVvbmFyZG8udG9nZ2xlQWN0aXZhdGVBbGwodGhpcy5hY3RpdmVBbGxTdGF0ZSk7XG4gICAgRXZlbnRzLmRpc3BhdGNoKEV2ZW50cy5UT0dHTEVfU1RBVEVTLCB0aGlzLmFjdGl2ZUFsbFN0YXRlKTtcbiAgICB0aGlzLnZpZXdOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5sZW9uYXJkby1hY3RpdmF0ZS1hbGwnKVsnaW5uZXJIVE1MJ10gPSB0aGlzLmFjdGl2ZUFsbFN0YXRlID8gJ0RlYWN0aXZhdGUgYWxsJyA6ICdBY3RpdmF0ZSBhbGwnO1xuICB9XG5cbiAgb25BZGRTY2VuYXJpbygpIHtcbiAgICB0aGlzLmFkZFNjZW5hcmlvLm9wZW4oKTtcbiAgfVxuXG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vbGVvbmFyZG8uZC50c1wiIC8+XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vdWktdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi8uLi91aS1ldmVudHMnO1xuaW1wb3J0IFN0YXRlSXRlbSBmcm9tICcuL3N0YXRlLWl0ZW0vc3RhdGUtaXRlbSc7XG5pbXBvcnQgU3RhdGVzQmFyIGZyb20gJy4vc3RhdGVzLWJhci9zdGF0ZXMtYmFyJztcbmltcG9ydCBTdGF0ZURldGFpbCBmcm9tICcuL3N0YXRlLWRldGFpbC9zdGF0ZXMtZGV0YWlsJztcbmltcG9ydCBET01FbGVtZW50IGZyb20gJy4uLy4uLy4uL0RPTUVsZW1lbnQnO1xuaW1wb3J0IHtFdmVudFN1Yn0gZnJvbSAnLi4vLi4vLi4vdWktZXZlbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVzTGlzdCBleHRlbmRzIERPTUVsZW1lbnQge1xuICBzdGF0ZXNCYXIgPSBuZXcgU3RhdGVzQmFyKCk7XG4gIHN0YXRlRGV0YWlsID0gbmV3IFN0YXRlRGV0YWlsKHRoaXMub25TdGF0ZURldGFpbFNhdmUuYmluZCh0aGlzKSwgdGhpcy5jbGVhclNlbGVjdGVkLmJpbmQodGhpcykpO1xuICBzdGF0ZXNFbGVtZW50czogU3RhdGVJdGVtW10gPSBbXTtcbiAgYm9keUV2ZW50U3ViczogQXJyYXk8RXZlbnRTdWI+ID0gW107XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYDxkaXYgaWQ9XCJsZW9uYXJkby1zdGF0ZXMtbGlzdFwiIGNsYXNzPVwibGVvbmFyZG8tc3RhdGVzLWxpc3RcIj48L2Rpdj5gKTtcbiAgICB0aGlzLmJvZHlFdmVudFN1YnMucHVzaChFdmVudHMub24oRXZlbnRzLkZJTFRFUl9TVEFURVMsIHRoaXMub25GaWx0ZXJTdGF0ZXMuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuYm9keUV2ZW50U3Vicy5wdXNoKEV2ZW50cy5vbihFdmVudHMuQUREX1NDRU5BUklPLCB0aGlzLmFkZFNjZW5hcmlvLmJpbmQodGhpcykpKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmNsZWFyRXZlbnRTdWJzKCk7XG4gICAgdGhpcy52aWV3Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnN0YXRlc0Jhci5nZXQoKSk7XG4gICAgRXZlbnRzLmRpc3BhdGNoKEV2ZW50cy5BVFRBQ0hfTUVOVV9JVEVNLCB0aGlzLnN0YXRlRGV0YWlsLmdldCgpKTtcbiAgICB0aGlzLnN0YXRlc0VsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgTGVvbmFyZG8uZ2V0U3RhdGVzKClcbiAgICAgIC5tYXAoKHN0YXRlKSA9PiBuZXcgU3RhdGVJdGVtKHN0YXRlLCB0aGlzLnJlbW92ZVN0YXRlQnlOYW1lLmJpbmQodGhpcykpKVxuICAgICAgLmZvckVhY2goKHN0YXRlRWxtKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGVzRWxlbWVudHMucHVzaChzdGF0ZUVsbSk7XG4gICAgICAgIHRoaXMudmlld05vZGUuYXBwZW5kQ2hpbGQoc3RhdGVFbG0uZ2V0KCkpO1xuICAgICAgICB0aGlzLm9uSXRlbShzdGF0ZUVsbS5nZXQoKSwgJ2NsaWNrJywgdGhpcy50b2dnbGVEZXRhaWwuYmluZCh0aGlzLCBzdGF0ZUVsbSkpO1xuICAgICAgICBzdGF0ZUVsbS5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIHRoaXMuc3RhdGVzQmFyLnJlbmRlcigpO1xuICB9XG5cbiAgb25GaWx0ZXJTdGF0ZXMoZGF0YTogQ3VzdG9tRXZlbnQpIHtcbiAgICB0aGlzLnN0YXRlc0VsZW1lbnRzLmZvckVhY2goKHN0YXRlRWxtOiBTdGF0ZUl0ZW0pID0+IHtcbiAgICAgIGlmIChzdGF0ZUVsbS5nZXROYW1lKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKGRhdGEuZGV0YWlsLnZhbC50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgIHN0YXRlRWxtLnRvZ2dsZVZpc2libGUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZUVsbS50b2dnbGVWaXNpYmxlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZVN0YXRlQnlOYW1lKHN0YXRlTmFtZTogc3RyaW5nLCBzdGF0ZVZpZXc6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5zdGF0ZXNFbGVtZW50cyA9IHRoaXMuc3RhdGVzRWxlbWVudHMuZmlsdGVyKChzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIHN0YXRlLmdldE5hbWUoKSAhPT0gc3RhdGVOYW1lO1xuICAgIH0pO1xuICAgIHRoaXMudmlld05vZGUucmVtb3ZlQ2hpbGQoc3RhdGVWaWV3KTtcbiAgfVxuXG4gIHByaXZhdGUgdG9nZ2xlRGV0YWlsKHN0YXRlRWxtOiBTdGF0ZUl0ZW0sIGV2ZW50OiBFdmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IG9wZW46IGJvb2xlYW4gPSBzdGF0ZUVsbS5nZXQoKS5jbGFzc0xpc3QuY29udGFpbnMoJ2xlb25hcmRvLXN0YXRlLWl0ZW0tZGV0YWlsZWQnKTtcbiAgICB0aGlzLmNsZWFyU2VsZWN0ZWQoKTtcbiAgICBpZighb3Blbil7XG4gICAgICBzdGF0ZUVsbS5nZXQoKS5jbGFzc0xpc3QuYWRkKCdsZW9uYXJkby1zdGF0ZS1pdGVtLWRldGFpbGVkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZURldGFpbC50b2dnbGUoc3RhdGVFbG0uZ2V0U3RhdGUoKSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyU2VsZWN0ZWQoKXtcbiAgICB0aGlzLnN0YXRlc0VsZW1lbnRzLmZvckVhY2goKGN1clN0YXRlKSA9PiB7XG4gICAgICBjdXJTdGF0ZS5nZXQoKS5jbGFzc0xpc3QucmVtb3ZlKCdsZW9uYXJkby1zdGF0ZS1pdGVtLWRldGFpbGVkJyk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uU3RhdGVEZXRhaWxTYXZlKCl7XG4gICAgdGhpcy5jbGVhclNlbGVjdGVkKCk7XG4gIH1cblxuICBwcml2YXRlIGFkZFNjZW5hcmlvKGV2ZW50OiBDdXN0b21FdmVudCkge1xuICAgIGNvbnN0IHN0YXRlczogQXJyYXk8YW55PiA9IHRoaXMuc3RhdGVzRWxlbWVudHMubWFwKChzdGF0ZUVsZW06IFN0YXRlSXRlbSkgPT4ge1xuICAgICAgcmV0dXJuIHN0YXRlRWxlbS5nZXRTdGF0ZSgpO1xuICAgIH0pLmZpbHRlcigoc3RhdGUpID0+IHN0YXRlLmFjdGl2ZSlcbiAgICAgIC5tYXAoKHN0YXRlOiBhbnkpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxuICAgICAgICAgIG9wdGlvbjogc3RhdGUuYWN0aXZlT3B0aW9uLm5hbWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgTGVvbmFyZG8uYWRkU2NlbmFyaW8oe1xuICAgICAgbmFtZTogZXZlbnQuZGV0YWlsLFxuICAgICAgc3RhdGVzOiBzdGF0ZXMsXG4gICAgICBmcm9tX2xvY2FsOiB0cnVlXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgXG4gIGRlc3Ryb3koKXtcbiAgICB0aGlzLmNsZWFyU2V0RXZlbnRTdWJzKHRoaXMuYm9keUV2ZW50U3Vicyk7XG4gIH1cblxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXRpbHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIHN0YXRpYyBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgc3RhdGljIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH1cblxuICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBzdGF0aWMgaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdHJpbmcoanNvbilcbiAgICAgID8gSlNPTi5wYXJzZShqc29uKVxuICAgICAgOiBqc29uO1xuICB9XG5cbiAgc3RhdGljIHRvSnNvbihvYmosIHByZXR0eT8pIHtcbiAgICBpZiAodGhpcy5pc1VuZGVmaW5lZChvYmopKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICghdGhpcy5pc051bWJlcihwcmV0dHkpKSB7XG4gICAgICBwcmV0dHkgPSBwcmV0dHkgPyAyIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgcHJldHR5KTtcbiAgfVxufVxuIl19

;

(function (doc, cssText) {
    var styleEl = doc.createElement("style");
    doc.getElementsByTagName("head")[0].appendChild(styleEl);
    if (styleEl.styleSheet) {
        if (!styleEl.styleSheet.disabled) {
            styleEl.styleSheet.cssText = cssText;
        }
    } else {
        try {
            styleEl.innerHTML = cssText;
        } catch (ignore) {
            styleEl.innerText = cssText;
        }
    }
}(document, ".leonardo-launcher {\n" +
"  position: fixed;\n" +
"  right: 40px;\n" +
"  bottom: 40px;\n" +
"  width: 70px;\n" +
"  cursor: pointer;\n" +
"  height: 70px;\n" +
"  z-index: 99999999999999999999999999;\n" +
"  background-size: contain;\n" +
"  background-repeat: no-repeat;\n" +
"  background-image: url('data:image/png;base64,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');\n" +
"}\n" +
".leonardo-main-view {\n" +
"  position: fixed;\n" +
"  display: flex;\n" +
"  top: 0;\n" +
"  right: 0;\n" +
"  left: 0;\n" +
"  height: 100%;\n" +
"  overflow: hidden;\n" +
"  background-color: white;\n" +
"  z-index: 9999999999999999999999999;\n" +
"}\n" +
".leonardo-main-view-hidden {\n" +
"  display: none;\n" +
"}\n" +
".leonardo-main-overlay {\n" +
"  opacity: 0.5;\n" +
"  pointer-events: none;\n" +
"}\n" +
".leonardo-main-view-body {\n" +
"  transition: width 200ms ease-in;\n" +
"  max-width: 100%;\n" +
"  width: 100%;\n" +
"  height: calc(100% - 47px);\n" +
"  will-change: width;\n" +
"}\n" +
".leonardo-main-view-menu {\n" +
"  position: absolute;\n" +
"  right: 0;\n" +
"  top: 0;\n" +
"  bottom: 0;\n" +
"  transition: transform 200ms ease-in;\n" +
"  will-change: transform;\n" +
"  transform: translateX(100%);\n" +
"  padding-top: 47px;\n" +
"}\n" +
".leonardo-main-view-menu-out {\n" +
"  transform: translateX(0);\n" +
"}\n" +
".leonardo-main-view-menu-in {\n" +
"  transform: translateX(100%);\n" +
"}\n" +
".leonardo-main-view-dialog {\n" +
"  position: absolute;\n" +
"  z-index: 100;\n" +
"  top: 50%;\n" +
"  left: 50%;\n" +
"  transform: translate(-50%, -50%);\n" +
"  width: auto;\n" +
"  height: auto;\n" +
"  display: none;\n" +
"}\n" +
".leonardo-header-container {\n" +
"  width: 100%;\n" +
"  z-index: 1;\n" +
"  border-bottom: 1px solid #ccc;\n" +
"  display: inline-block;\n" +
"  min-height: 44px;\n" +
"  overflow: hidden;\n" +
"}\n" +
".leonardo-header-container .leonardo-header-label {\n" +
"  display: inline-block;\n" +
"  font-size: 20px;\n" +
"  text-align: left;\n" +
"  padding: 3px 25px 0 15px;\n" +
"  line-height: 44px;\n" +
"  float: left;\n" +
"  text-transform: uppercase;\n" +
"  width: 170px;\n" +
"  font-weight: bold;\n" +
"  cursor: pointer;\n" +
"  color: #666666;\n" +
"}\n" +
".leonardo-header-container .leonardo-header-tabs {\n" +
"  display: inline-block;\n" +
"  font-size: 1.5em;\n" +
"  color: #666666;\n" +
"  text-align: left;\n" +
"  font-weight: bold;\n" +
"  height: 26px;\n" +
"}\n" +
".leonardo-header-container .leonardo-header-tabs > ul {\n" +
"  margin: 0 20px;\n" +
"  padding: 0;\n" +
"}\n" +
".leonardo-header-container .leonardo-header-tabs > ul .leonardo-header-tabItem {\n" +
"  display: inline-block;\n" +
"  line-height: 44px;\n" +
"  margin-right: 20px;\n" +
"  float: left;\n" +
"  text-align: center;\n" +
"  text-transform: uppercase;\n" +
"  font-size: 12px;\n" +
"  width: 170px;\n" +
"  cursor: pointer;\n" +
"}\n" +
".leonardo-header-container .leonardo-header-tabs > ul .leonardo-header-tabItem-selected {\n" +
"  border-top: 3px solid #f08222;\n" +
"}\n" +
".leonardo-dropdown {\n" +
"  position: relative;\n" +
"  font-size: 13px;\n" +
"  width: 200px;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-selected {\n" +
"  padding: 0 10px;\n" +
"  height: 26px;\n" +
"  line-height: 26px;\n" +
"  white-space: nowrap;\n" +
"  overflow: hidden;\n" +
"  text-overflow: ellipsis;\n" +
"  background: #43A047;\n" +
"  color: #fff;\n" +
"  border: 0;\n" +
"  margin-left: 0;\n" +
"  position: relative;\n" +
"  width: 100%;\n" +
"  cursor: pointer;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-selected[disabled] {\n" +
"  cursor: default;\n" +
"  opacity: 0.6;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-selected:hover {\n" +
"  color: lightblue;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-selected:hover .leonardo-dropdown-selected-arrow {\n" +
"  border-top: 7px solid lightblue;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-selected .leonardo-dropdown-selected-arrow {\n" +
"  position: absolute;\n" +
"  right: 5px;\n" +
"  top: 50%;\n" +
"  transform: translateY(-50%);\n" +
"  border-left: 7px solid transparent;\n" +
"  border-right: 7px solid transparent;\n" +
"  border-top: 7px solid aliceblue;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options {\n" +
"  position: absolute;\n" +
"  display: none;\n" +
"  z-index: 10;\n" +
"  margin-left: 0;\n" +
"  left: 0;\n" +
"  border: 1px solid #212121;\n" +
"  border-top: none;\n" +
"  width: 100%;\n" +
"  max-height: 300px;\n" +
"  overflow-y: auto;\n" +
"  padding: 0;\n" +
"  background: white;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list {\n" +
"  list-style: none;\n" +
"  margin: 0;\n" +
"  padding: 0;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item {\n" +
"  padding: 7px 5px;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item:hover {\n" +
"  background: lightblue;\n" +
"  cursor: pointer;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item .leonardo-dropdown-item-text {\n" +
"  display: inline-block;\n" +
"  width: 100%;\n" +
"  height: 100%;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item .leonardo-dropdown-item-x {\n" +
"  position: absolute;\n" +
"  right: 5px;\n" +
"  display: inline-block;\n" +
"  width: 12px;\n" +
"  height: 12px;\n" +
"  overflow: hidden;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item .leonardo-dropdown-item-x:hover::before,\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item .leonardo-dropdown-item-x:hover::after {\n" +
"  background: darkgray;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item .leonardo-dropdown-item-x::before,\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item .leonardo-dropdown-item-x::after {\n" +
"  content: '';\n" +
"  position: absolute;\n" +
"  height: 1px;\n" +
"  width: 100%;\n" +
"  top: 50%;\n" +
"  left: 0;\n" +
"  background: #000;\n" +
"  border-radius: 5px;\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item .leonardo-dropdown-item-x::before {\n" +
"  transform: rotate(45deg);\n" +
"}\n" +
".leonardo-dropdown .leonardo-dropdown-options .leonardo-dropdown-list .leonardo-dropdown-item .leonardo-dropdown-item-x::after {\n" +
"  transform: rotate(-45deg);\n" +
"}\n" +
".leonardo-views-container {\n" +
"  width: 100%;\n" +
"  height: 100%;\n" +
"}\n" +
".leonardo-scenarios {\n" +
"  height: 100%;\n" +
"  display: flex;\n" +
"}\n" +
".leonardo-states-list {\n" +
"  width: 100%;\n" +
"  height: 100%;\n" +
"  padding-left: 10px;\n" +
"  padding-top: 10px;\n" +
"  overflow: auto;\n" +
"  transition: width 200ms ease-out;\n" +
"}\n" +
".leonardo-states-list .leonardo-state-item:nth-child(2n+3) {\n" +
"  background: #eee;\n" +
"}\n" +
".leonardo-states-list .leonardo-state-item:hover {\n" +
"  cursor: pointer;\n" +
"  background: rgba(47, 204, 255, 0.32);\n" +
"}\n" +
".leonardo-states-list .leonardo-state-item-detailed {\n" +
"  background: #999966!important;\n" +
"}\n" +
".leonardo-states-list .leonardo-state-item-detailed:hover {\n" +
"  background: #ccccb3!important;\n" +
"}\n" +
".leonardo-states-bar {\n" +
"  display: flex;\n" +
"  justify-content: space-between;\n" +
"  margin-bottom: 10px;\n" +
"  padding-right: 1px;\n" +
"}\n" +
".leonardo-states-bar .leonardo-search-state {\n" +
"  border: 1px solid #ccc;\n" +
"  border-width: 0 0 1px 0;\n" +
"  width: 200px;\n" +
"  outline: none;\n" +
"  font-size: 15px;\n" +
"}\n" +
"::-webkit-input-placeholder {\n" +
"  color: #ccc !important;\n" +
"}\n" +
".leonardo-add-scenario {\n" +
"  display: none;\n" +
"  position: absolute;\n" +
"  right: 0;\n" +
"  top: 0;\n" +
"}\n" +
".leonardo-add-scenario .leonardo-add-scenario-box {\n" +
"  position: absolute;\n" +
"  display: flex;\n" +
"  height: 50px;\n" +
"  width: 425px;\n" +
"  right: 25px;\n" +
"  bottom: -90px;\n" +
"  border: 1px solid black;\n" +
"  background: white;\n" +
"  box-shadow: 4px 3px 5px 0 rgba(0, 0, 0, 0.75);\n" +
"  z-index: 1;\n" +
"  justify-content: space-between;\n" +
"  align-items: center;\n" +
"  padding: 5px;\n" +
"}\n" +
".leonardo-add-scenario .leonardo-add-scenario-box > input {\n" +
"  flex: 1;\n" +
"  height: 25px;\n" +
"  margin-left: 5px;\n" +
"}\n" +
".leonardo-add-scenario .leonardo-add-scenario-box > button {\n" +
"  margin-left: 5px;\n" +
"}\n" +
".leonardo-scenarios-list {\n" +
"  width: 200px;\n" +
"  padding-left: 15px;\n" +
"  padding-top: 10px;\n" +
"  border-right: 1px solid #ccc;\n" +
"  overflow: auto;\n" +
"}\n" +
".leonardo-scenarios-list > div {\n" +
"  font-weight: 500;\n" +
"}\n" +
".leonardo-scenarios-list ul {\n" +
"  margin: 0;\n" +
"  padding-top: 5px;\n" +
"  padding-left: 0;\n" +
"  font-size: 0.9rem;\n" +
"}\n" +
".leonardo-scenarios-list ul li {\n" +
"  list-style: none;\n" +
"  cursor: pointer;\n" +
"  max-width: calc(100% - 10px);\n" +
"  overflow: hidden;\n" +
"  text-overflow: ellipsis;\n" +
"  white-space: nowrap;\n" +
"  margin-bottom: 2px;\n" +
"}\n" +
".leonardo-scenarios-list ul li:hover {\n" +
"  text-decoration: underline;\n" +
"}\n" +
".leonardo-state-item {\n" +
"  display: flex;\n" +
"  margin-bottom: 3px;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-verb {\n" +
"  margin-right: 10px;\n" +
"  background: #000;\n" +
"  color: #fff;\n" +
"  text-align: center;\n" +
"  width: 60px;\n" +
"  min-width: 60px;\n" +
"  height: 25px;\n" +
"  line-height: 25px;\n" +
"  font-size: 12px;\n" +
"}\n" +
".leonardo-state-item .leonardo-toggle-btn {\n" +
"  margin-right: 15px;\n" +
"  align-self: center;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-verb-get {\n" +
"  background: #43A047;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-verb-custom {\n" +
"  background: #212121;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-verb-post {\n" +
"  background: #F57C00;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-verb-put {\n" +
"  background: #0066cc;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-verb-delete {\n" +
"  background: #003366;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-data-container {\n" +
"  align-self: center;\n" +
"  flex: 1;\n" +
"  overflow: hidden;\n" +
"  white-space: nowrap;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-data-container .leonardo-state-name {\n" +
"  font-size: 0.9rem;\n" +
"  white-space: nowrap;\n" +
"  max-width: 50%;\n" +
"  text-overflow: ellipsis;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-data-container .leonardo-state-url {\n" +
"  font-size: 0.7rem;\n" +
"  align-self: center;\n" +
"  margin-left: 10px;\n" +
"  color: grey;\n" +
"  white-space: nowrap;\n" +
"  max-width: 50%;\n" +
"  text-overflow: ellipsis;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-remove {\n" +
"  margin: 0 5px;\n" +
"  align-self: center;\n" +
"  border: 1px inset #E0E0E0;\n" +
"  padding: 10px;\n" +
"  border-radius: 5px;\n" +
"}\n" +
".leonardo-state-item .leonardo-state-remove:active {\n" +
"  border: 1px solid #E0E0E0;\n" +
"}\n" +
".leonardo-state-item.leonardo-state-item-hidden {\n" +
"  display: none;\n" +
"}\n" +
".leonardo-state-detail {\n" +
"  height: 100%;\n" +
"  border: 1px solid #ccc;\n" +
"  border-top: none;\n" +
"  background: white;\n" +
"  z-index: 100;\n" +
"  border-top: 2px solid #ccc;\n" +
"  padding: 10px;\n" +
"  color: #212121;\n" +
"  width: 400px;\n" +
"  overflow: auto;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-container {\n" +
"  margin-top: 0;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-top {\n" +
"  font-size: 19px;\n" +
"  padding-bottom: 20px;\n" +
"  border-bottom: 1px solid #ccc;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-input {\n" +
"  width: 100%;\n" +
"  font-size: 14px;\n" +
"  display: block;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-input input {\n" +
"  display: inline-block;\n" +
"  width: 95%;\n" +
"  color: #78788c;\n" +
"  padding: 10px;\n" +
"  box-sizing: border-box;\n" +
"  background: none;\n" +
"  outline: none;\n" +
"  resize: none;\n" +
"  border: 0;\n" +
"  transition: all .3s;\n" +
"  border-bottom: 1px solid #bebed2;\n" +
"  font-size: 14px;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-input input:focus {\n" +
"  border-bottom: 1px solid #78788c;\n" +
"}\n" +
".leonardo-state-detail div {\n" +
"  margin-top: 20px;\n" +
"}\n" +
".leonardo-state-detail textarea {\n" +
"  display: block;\n" +
"  height: 200px;\n" +
"  width: 100%;\n" +
"  border: 1px solid #E0E0E0;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-edit {\n" +
"  float: right;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-buttons {\n" +
"  margin: auto;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-buttons button {\n" +
"  border-radius: 3px;\n" +
"  border: 1px solid #0066cc;\n" +
"  color: dimgray;\n" +
"  margin-top: 10px;\n" +
"  width: 49%;\n" +
"  height: 35px;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-buttons button:first-child {\n" +
"  color: white;\n" +
"  background: #0066cc;\n" +
"  border: 1px solid #E0E0E0;\n" +
"}\n" +
".leonardo-state-detail .leonardo-states-detail-buttons button:first-child:hover {\n" +
"  background: cornflowerblue;\n" +
"}\n" +
".leonardo-state-detail-recorder {\n" +
"  height: 100%;\n" +
"  border: 1px solid #ccc;\n" +
"  border-top: none;\n" +
"  background: white;\n" +
"  z-index: 100;\n" +
"  border-top: 2px solid #ccc;\n" +
"  padding: 10px;\n" +
"  color: #212121;\n" +
"  width: 400px;\n" +
"  overflow: auto;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-container {\n" +
"  margin-top: 0;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-top {\n" +
"  font-size: 19px;\n" +
"  padding-bottom: 20px;\n" +
"  border-bottom: 1px solid #ccc;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-input {\n" +
"  width: 100%;\n" +
"  font-size: 14px;\n" +
"  display: block;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-input input {\n" +
"  display: inline-block;\n" +
"  width: 95%;\n" +
"  color: #78788c;\n" +
"  padding: 10px;\n" +
"  box-sizing: border-box;\n" +
"  background: none;\n" +
"  outline: none;\n" +
"  resize: none;\n" +
"  border: 0;\n" +
"  transition: all .3s;\n" +
"  border-bottom: 1px solid #bebed2;\n" +
"  font-size: 14px;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-input input:focus {\n" +
"  border-bottom: 1px solid #78788c;\n" +
"}\n" +
".leonardo-state-detail-recorder div {\n" +
"  margin-top: 20px;\n" +
"}\n" +
".leonardo-state-detail-recorder textarea {\n" +
"  display: block;\n" +
"  height: 200px;\n" +
"  width: 100%;\n" +
"  border: 1px solid #bebed2;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-edit {\n" +
"  float: right;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-buttons {\n" +
"  margin: auto;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-buttons button {\n" +
"  border-radius: 3px;\n" +
"  border: 1px solid #0066cc;\n" +
"  color: dimgray;\n" +
"  margin-top: 10px;\n" +
"  width: 49%;\n" +
"  height: 35px;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-buttons button:first-child {\n" +
"  color: white;\n" +
"  background: #0066cc;\n" +
"  border: 1px solid #E0E0E0;\n" +
"}\n" +
".leonardo-state-detail-recorder .leonardo-states-detail-buttons button:first-child:hover {\n" +
"  background: cornflowerblue;\n" +
"}\n" +
".leonardo-recorder {\n" +
"  height: 100%;\n" +
"}\n" +
".leonardo-recorder-list {\n" +
"  height: 100%;\n" +
"  overflow: auto;\n" +
"  position: relative;\n" +
"  top: 0;\n" +
"  bottom: 0;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container {\n" +
"  text-decoration: none;\n" +
"  padding: 0;\n" +
"  margin: 0;\n" +
"  overflow: auto;\n" +
"  height: 100%;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-item-selected {\n" +
"  background: #999966!important;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-item-selected:hover {\n" +
"  background: #ccccb3!important;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item {\n" +
"  display: flex;\n" +
"  border-bottom: 1px solid #ccc;\n" +
"  text-decoration: none;\n" +
"  color: #555;\n" +
"  padding: 5px;\n" +
"  font-size: 13px;\n" +
"  cursor: pointer;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item:hover {\n" +
"  background: #ddd !important;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-url {\n" +
"  flex-grow: 10;\n" +
"  white-space: nowrap;\n" +
"  overflow: hidden;\n" +
"  text-overflow: ellipsis;\n" +
"  padding-right: 5px;\n" +
"  line-height: 25px;\n" +
"  font-size: 13px;\n" +
"  color: #555;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-name {\n" +
"  background: #53131E;\n" +
"  display: inline-block;\n" +
"  padding: 5px 10px;\n" +
"  font-size: 12px;\n" +
"  margin: 0 2px;\n" +
"  color: white;\n" +
"  justify-content: flex-end;\n" +
"  align-self: flex-end;\n" +
"  white-space: nowrap;\n" +
"  text-align: center;\n" +
"  width: 150px;\n" +
"  overflow: hidden;\n" +
"  text-overflow: ellipsis;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-name-new {\n" +
"  background: blue;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-verb {\n" +
"  margin-right: 10px;\n" +
"  background: #000;\n" +
"  color: #fff;\n" +
"  text-align: center;\n" +
"  width: 60px;\n" +
"  height: 25px;\n" +
"  line-height: 25px;\n" +
"  font-size: 12px;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-verb-get {\n" +
"  background: #43A047;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-verb-custom {\n" +
"  background: #212121;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-verb-post {\n" +
"  background: #F57C00;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-verb-put {\n" +
"  background: #0066cc;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item .leonardo-recorder-list-verb-delete {\n" +
"  background: #003366;\n" +
"}\n" +
".leonardo-recorder-list .leonardo-recorder-list-container .leonardo-recorder-list-item:nth-child(even) {\n" +
"  background: #F2F2F2;\n" +
"}\n" +
".leonardo-export {\n" +
"  overflow: auto;\n" +
"}\n" +
".leonardo-export .leonardo-export-buttons {\n" +
"  float: right;\n" +
"  margin-right: 30px;\n" +
"  margin-top: 30px;\n" +
"  border: 2px solid;\n" +
"  border-radius: 6px;\n" +
"  width: 180px;\n" +
"  height: 42px;\n" +
"  font-size: 110%;\n" +
"}\n" +
".leonardo-export .leonardo-exported-code {\n" +
"  width: 95%;\n" +
"  height: 400px;\n" +
"  overflow-y: scroll;\n" +
"  margin: auto;\n" +
"  border: 1px solid gray;\n" +
"  border-radius: 5px;\n" +
"}\n" +
".leonardo-export .leonardo-spacer {\n" +
"  height: 100px;\n" +
"}\n" +
".leonardo-export button {\n" +
"  outline: none;\n" +
"}\n" +
".leonardo-code-editor {\n" +
"  height: 600px;\n" +
"  width: 900px;\n" +
"  background: white;\n" +
"  color: #1d1d1d;\n" +
"  z-index: 1050;\n" +
"  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.3);\n" +
"  border-radius: 3px;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-header {\n" +
"  height: 40px;\n" +
"  padding: 10px;\n" +
"  color: #666666;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-header .leonardo-code-editor-beautify {\n" +
"  font-size: 12px;\n" +
"  float: right;\n" +
"  color: #0066cc;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-header .leonardo-code-editor-beautify:hover {\n" +
"  color: lightblue;\n" +
"  cursor: pointer;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-body {\n" +
"  height: 500px;\n" +
"  border-top: 1px solid #E0E0E0;\n" +
"  border-bottom: 1px solid #E0E0E0;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-body #leonardo-code-editor-edit-area {\n" +
"  height: 100%;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-footer {\n" +
"  height: 100px;\n" +
"  padding: 0 10px 10px 10px;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-footer button {\n" +
"  float: right;\n" +
"  border-radius: 3px;\n" +
"  border: 1px solid #0066cc;\n" +
"  color: dimgray;\n" +
"  margin-top: 10px;\n" +
"  width: 100px;\n" +
"  height: 35px;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-footer button:first-child {\n" +
"  color: white;\n" +
"  background: #0066cc;\n" +
"  border: 1px solid #E0E0E0;\n" +
"}\n" +
".leonardo-code-editor .leonardo-code-editor-footer button:first-child:hover {\n" +
"  background: cornflowerblue;\n" +
"}\n" +
".leonardo-toggle {\n" +
"  display: none!important;\n" +
"}\n" +
".leonardo-toggle,\n" +
".leonardo-toggle:after,\n" +
".leonardo-toggle:before,\n" +
".leonardo-toggle *,\n" +
".leonardo-toggle *:after,\n" +
".leonardo-toggle *:before,\n" +
".leonardo-toggle + .leonardo-toggle-btn {\n" +
"  box-sizing: border-box;\n" +
"}\n" +
".leonardo-toggle::selection,\n" +
".leonardo-toggle:after::selection,\n" +
".leonardo-toggle:before::selection,\n" +
".leonardo-toggle *::selection,\n" +
".leonardo-toggle *:after::selection,\n" +
".leonardo-toggle *:before::selection,\n" +
".leonardo-toggle + .leonardo-toggle-btn::selection {\n" +
"  background: none;\n" +
"}\n" +
".leonardo-toggle + .leonardo-toggle-btn {\n" +
"  outline: 0;\n" +
"  display: block;\n" +
"  width: 3em;\n" +
"  min-width: 50px;\n" +
"  height: 1.5em;\n" +
"  position: relative;\n" +
"  cursor: pointer;\n" +
"  user-select: none;\n" +
"}\n" +
".leonardo-toggle + .leonardo-toggle-btn:after,\n" +
".leonardo-toggle + .leonardo-toggle-btn:before {\n" +
"  position: relative;\n" +
"  display: block;\n" +
"  content: \"\";\n" +
"  width: 50%;\n" +
"  height: 100%;\n" +
"}\n" +
".leonardo-toggle + .leonardo-toggle-btn:after {\n" +
"  left: 0;\n" +
"}\n" +
".leonardo-toggle + .leonardo-toggle-btn:before {\n" +
"  display: none;\n" +
"}\n" +
".leonardo-toggle:checked + .leonardo-toggle-btn:after {\n" +
"  left: 50%;\n" +
"}\n" +
".leonardo-toggle-ios + .leonardo-toggle-btn {\n" +
"  background: #fbfbfb;\n" +
"  border-radius: 2em;\n" +
"  padding: 2px;\n" +
"  transition: all .4s ease;\n" +
"  border: 1px solid #e8eae9;\n" +
"}\n" +
".leonardo-toggle-ios + .leonardo-toggle-btn:after {\n" +
"  border-radius: 2em;\n" +
"  background: #fbfbfb;\n" +
"  transition: left 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), padding 0.3s ease, margin 0.3s ease;\n" +
"  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1), 0 4px 0 rgba(0, 0, 0, 0.08);\n" +
"}\n" +
".leonardo-toggle-ios + .leonardo-toggle-btn:hover:after {\n" +
"  will-change: padding;\n" +
"}\n" +
".leonardo-toggle-ios + .leonardo-toggle-btn:active {\n" +
"  box-shadow: inset 0 0 0 2em #e8eae9;\n" +
"}\n" +
".leonardo-toggle-ios + .leonardo-toggle-btn:active:after {\n" +
"  padding-right: .8em;\n" +
"}\n" +
".leonardo-toggle-ios:checked + .leonardo-toggle-btn {\n" +
"  background: #43A047;\n" +
"}\n" +
".leonardo-toggle-ios:checked + .leonardo-toggle-btn:active {\n" +
"  box-shadow: none;\n" +
"}\n" +
".leonardo-toggle-ios:checked + .leonardo-toggle-btn:active:after {\n" +
"  margin-left: -0.8em;\n" +
"}\n" +
".leonardo-button {\n" +
"  background: white;\n" +
"  color: #212121;\n" +
"  border: 1px solid #E0E0E0;\n" +
"  font-size: 12px;\n" +
"  cursor: pointer;\n" +
"  padding: 5px 10px;\n" +
"  border-radius: 2px;\n" +
"}\n" +
".leonardo-button:hover {\n" +
"  background: #E0E0E0;\n" +
"}\n" +
".leonardo-x-btn {\n" +
"  overflow: hidden;\n" +
"  position: relative;\n" +
"  width: 12px;\n" +
"  height: 12px;\n" +
"}\n" +
".leonardo-x-btn:hover::before,\n" +
".leonardo-x-btn:hover::after {\n" +
"  background: darkgray;\n" +
"}\n" +
".leonardo-x-btn::before,\n" +
".leonardo-x-btn::after {\n" +
"  content: '';\n" +
"  position: absolute;\n" +
"  height: 1px;\n" +
"  width: 100%;\n" +
"  top: 50%;\n" +
"  left: 0;\n" +
"  background: #000;\n" +
"  border-radius: 5px;\n" +
"}\n" +
".leonardo-x-btn::before {\n" +
"  transform: rotate(45deg);\n" +
"}\n" +
".leonardo-x-btn::after {\n" +
"  transform: rotate(-45deg);\n" +
"}"));
